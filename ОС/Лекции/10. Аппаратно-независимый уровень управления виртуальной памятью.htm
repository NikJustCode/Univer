<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>INTUIT.ru::Интернет-Университет Информационных Технологий</title>
<link href="10. Аппаратно-независимый уровень управления виртуальной памятью_files/printabl.css" type="text/css" rel="stylesheet">
</head>
<body leftmargin="6" topmargin="6" marginheight="6" marginwidth="6">


<div align="left">
<span style="color: #000000; font-weight: bold;">
&nbsp;&nbsp;
<span style="font-size:12pt;">Интернет-Университет Информационных Технологий</span>
</span>
</div>

&nbsp;&nbsp;
<span align="rright" style="color: #330066; text-decoration:underline;">http://www.INTUIT.ru</span>


<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td height="8" colspan=3><img src="10. Аппаратно-независимый уровень управления виртуальной памятью_files/empty000.gif" width="1" height="8"></td></tr>
<tr><td class="orang" height="1" colspan=3><img src="10. Аппаратно-независимый уровень управления виртуальной памятью_files/empty000.gif" width="1" height="1"></td></tr>
<tr><td height="8" colspan=3><img src="10. Аппаратно-независимый уровень управления виртуальной памятью_files/empty000.gif" width="1" height="8"></td></tr>
<tr valign="top">
<td><img src="10. Аппаратно-независимый уровень управления виртуальной памятью_files/empty000.gif" width="8" height="1"></td>
<td>
	<!-- content -->
	<table border="0" cellpadding="0" cellspacing="0" width="100%">
	<tr><td class="head">Основы операционных систем</td></tr>
<tr><td height="4"><img src="10. Аппаратно-независимый уровень управления виртуальной памятью_files/empty000.gif" width="1" height="4"></td></tr>
	<tr><td class="orang" height="1"><img src="10. Аппаратно-независимый уровень управления виртуальной памятью_files/empty000.gif" width="1" height="1"></td></tr>
	<tr><td height="8"><img src="10. Аппаратно-независимый уровень управления виртуальной памятью_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td><span class="headsub">


10. Лекция:

 Аппаратно-независимый уровень управления виртуальной памятью: версия для печати и PDA</span>

<br>
<span class="rtxt">Большинство ОС используют сегментно-страничную виртуальную память. Для обеспечения нужной производительности менеджер памяти ОС старается поддерживать в оперативной памяти актуальную информацию, пытаясь угадать, к каким логическим адресам последует обращение в недалеком будущем.
</span>

</td></tr>

	<tr><td height="8"><img src="10. Аппаратно-независимый уровень управления виртуальной памятью_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td class="orang" height="1"><img src="10. Аппаратно-независимый уровень управления виртуальной памятью_files/empty000.gif" width="1" height="1"></td></tr>
	<tr><td height="8"><img src="10. Аппаратно-независимый уровень управления виртуальной памятью_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td>


<h3 ></h3><p  id="id_1">В данной лекции рассмотрена аппаратно-независимая часть подсистемы управления виртуальной памятью, которая связана с конкретной аппаратной реализацией с помощью аппаратно-зависимой части. </p><div  class="lecture_mark" id="mark_1"></div><p  id="id_2">Большинство ОС используют сегментно-страничную виртуальную память. Для обеспечения нужной производительности менеджер памяти ОС старается поддерживать в оперативной памяти актуальную информацию, пытаясь угадать, к каким логическим адресам последует обращение в недалеком будущем. Решающую роль здесь играет удачный выбор <span class="keyword">стратегии замещения</span>, реализованной в <span class="keyword">алгоритме выталкивания страниц</span>.</p><div  class="lecture_mark" id="mark_2"></div><h3 >Исключительные ситуации при работе с памятью</h3><p  id="id_3">Из материала предыдущей лекции следует, что отображение виртуального адреса в физический осуществляется при помощи таблицы страниц. Для каждой виртуальной страницы запись в таблице страниц содержит номер соответствующего страничного кадра в оперативной памяти, а также атрибуты страницы для контроля обращений к памяти.</p><div  class="lecture_mark" id="mark_3"></div><p  id="id_4"><a name="keyword-context.1"></a>Что же происходит, когда нужной страницы в памяти нет или операция обращения к памяти недопустима? Естественно, что операционная система должна быть как-то оповещена о происшедшем. Обычно для этого используется механизм исключительных ситуаций (exceptions). При попытке выполнить подобное обращение к виртуальной странице возникает исключительная ситуация <span class="keyword_def">"страничное нарушение"</span> (<span class="keyword">page fault</span>), приводящая к вызову специальной последовательности команд для обработки конкретного вида <span class="keyword">страничного нарушения</span>. </p><div  class="lecture_mark" id="mark_4"></div><p  id="id_5"><span class="keyword">Страничное нарушение</span> может происходить в самых разных случаях: при отсутствии страницы в оперативной памяти, при попытке записи в страницу с атрибутом "только чтение" или при попытке чтения или записи страницы с атрибутом "только выполнение". В любом из этих случаев вызывается обработчик <span class="keyword">страничного нарушения</span>, являющийся частью операционной системы. Ему обычно передается причина возникновения исключительной ситуации и виртуальный адрес, обращение к которому вызвало нарушение.</p><div  class="lecture_mark" id="mark_5"></div><p  id="id_6">Нас будет интересовать конкретный вариант <span class="keyword">страничного нарушения</span> - обращение к отсутствующей странице, поскольку именно его обработка во многом определяет производительность страничной системы. Когда программа обращается к виртуальной странице, отсутствующей в основной памяти, операционная система должна выделить страницу основной памяти, переместить в нее копию виртуальной страницы из внешней памяти и модифицировать соответствующий элемент таблицы страниц.</p><div  class="lecture_mark" id="mark_6"></div><p  id="id_7">Повышение производительности вычислительной системы может быть достигнуто за счет уменьшения частоты <span class="keyword">страничных нарушений</span>, а также за счет увеличения скорости их обработки. Время эффективного доступа к отсутствующей в оперативной памяти странице складывается из:</p><div  class="lecture_mark" id="mark_7"></div><ul  id="id_8"><li>обслуживания исключительной ситуации (<span class="keyword">page fault</span>);</li><li>чтения (подкачки) страницы из вторичной памяти (иногда, при недостатке места в основной памяти, необходимо вытолкнуть одну из страниц из основной памяти во вторичную, то есть осуществить замещение страницы);</li><li>возобновления выполнения процесса, вызвавшего данный <span class="keyword">page fault</span>.</li></ul><div  class="lecture_mark" id="mark_8"></div><p  id="id_12">Для решения первой и третьей задач ОС выполняет до нескольких сот машинных инструкций в течение нескольких десятков микросекунд. Время подкачки страницы близко к нескольким десяткам миллисекунд. Проведенные исследования показывают, что вероятности <span class="keyword">page fault</span> 5x10<sup>-7</sup> оказывается достаточно, чтобы снизить производительность страничной схемы управления памятью на 10%. Таким образом, уменьшение частоты <span class="keyword">page faults</span> является одной из ключевых задач системы управления памятью. Ее решение обычно связано с правильным выбором алгоритма замещения страниц.</p><div  class="lecture_mark" id="mark_12"></div><h3 >Стратегии управления страничной памятью</h3><p  id="id_13">Программное обеспечение подсистемы управления памятью связано с реализацией следующих стратегий:</p><div  class="lecture_mark" id="mark_13"></div><p  id="id_14"><a name="keyword-context.2"></a><span class="keyword_def">Стратегия выборки (fetch policy)</span> - в какой момент следует переписать страницу из вторичной памяти в первичную. Существует два основных варианта выборки - по запросу и с упреждением. Алгоритм выборки по запросу вступает в действие в тот момент, когда процесс обращается к отсутствующей странице, содержимое которой находится на диске. Его реализация заключается в загрузке страницы с диска в свободную физическую страницу и коррекции соответствующей записи таблицы страниц.</p><div  class="lecture_mark" id="mark_14"></div><p  id="id_15">Алгоритм выборки с упреждением осуществляет опережающее чтение, то есть кроме страницы, вызвавшей исключительную ситуацию, в память также загружается несколько страниц, окружающих ее (обычно соседние страницы располагаются во внешней памяти последовательно и могут быть считаны за одно обращение к диску). Такой алгоритм призван уменьшить накладные расходы, связанные с большим количеством исключительных ситуаций, возникающих при работе со значительными объемами данных или кода; кроме того, оптимизируется работа с диском.</p><div  class="lecture_mark" id="mark_15"></div><p  id="id_16"><a name="keyword-context.3"></a><span class="keyword_def">Стратегия размещения (placement policy)</span> - в какой участок первичной памяти поместить поступающую страницу. В системах со страничной организацией все просто - в любой свободный страничный кадр. В случае систем с сегментной организацией необходима стратегия, аналогичная стратегии с динамическим распределением.</p><div  class="lecture_mark" id="mark_16"></div><p  id="id_17"><a name="keyword-context.4"></a><span class="keyword_def">Стратегия замещения (replacement policy)</span> - какую страницу нужно вытолкнуть во внешнюю память, чтобы освободить место в оперативной памяти. Разумная <span class="keyword">стратегия замещения</span>, реализованная в соответствующем алгоритме замещения страниц, позволяет хранить в памяти самую необходимую информацию и тем самым снизить частоту <span class="keyword">страничных нарушений</span>. Замещение должно происходить с учетом выделенного каждому процессу количества кадров. Кроме того, нужно решить, должна ли замещаемая страница принадлежать процессу, который инициировал замещение, или она должна быть выбрана среди всех кадров основной памяти.</p><div  class="lecture_mark" id="mark_17"></div><h3 >Алгоритмы замещения страниц</h3><p  id="id_18">Итак, наиболее ответственным действием менеджера памяти является выделение кадра оперативной памяти для размещения в ней виртуальной страницы, находящейся во внешней памяти. Напомним, что мы рассматриваем ситуацию, когда размер виртуальной памяти для каждого процесса может существенно превосходить размер основной памяти. Это означает, что при выделении страницы основной памяти с большой вероятностью не удастся найти свободный страничный кадр. В этом случае операционная система в соответствии с заложенными в нее критериями должна:</p><div  class="lecture_mark" id="mark_18"></div><ul  id="id_19"><li>найти некоторую занятую страницу основной памяти;</li><li>переместить в случае надобности ее содержимое во внешнюю память;</li><li>переписать в этот страничный кадр содержимое нужной виртуальной страницы из внешней памяти;</li><li>должным образом модифицировать необходимый элемент соответствующей таблицы страниц; </li><li>продолжить выполнение процесса, которому эта виртуальная страница понадобилась.</li></ul><div  class="lecture_mark" id="mark_19"></div><p  id="id_25">Заметим, что при замещении приходится дважды передавать страницу между основной и вторичной памятью. Процесс замещения может быть оптимизирован за счет использования бита модификации (один из атрибутов страницы в таблице страниц). Бит модификации устанавливается компьютером, если хотя бы один байт был записан на страницу. При выборе кандидата на замещение проверяется бит модификации. Если бит не установлен, нет необходимости переписывать данную страницу на диск, ее копия на диске уже имеется. Подобный метод также применяется к read-only-страницам, они никогда не модифицируются. Эта схема уменьшает время обработки <span class="keyword">page fault</span>.</p><div  class="lecture_mark" id="mark_25"></div><p  id="id_26">Существует большое количество разнообразных алгоритмов замещения страниц. Все они делятся на локальные и глобальные. Локальные алгоритмы, в отличие от глобальных, распределяют фиксированное или динамически настраиваемое число страниц для каждого процесса. Когда процесс израсходует все предназначенные ему страницы, система будет удалять из физической памяти одну из его страниц, а не из страниц других процессов. Глобальный же алгоритм замещения в случае возникновения исключительной ситуации удовлетворится освобождением любой физической страницы, независимо от того, какому процессу она принадлежала.</p><div  class="lecture_mark" id="mark_26"></div><p  id="id_27">Глобальные алгоритмы имеют ряд недостатков. Во-первых, они делают одни процессы чувствительными к поведению других процессов. Например, если один процесс в системе одновременно использует большое количество страниц памяти, то все остальные приложения будут в результате ощущать сильное замедление из-за недостатка кадров памяти для своей работы. Во-вторых, некорректно работающее приложение может подорвать работу всей системы (если, конечно, в системе не предусмотрено ограничение на размер памяти, выделяемой процессу), пытаясь захватить больше памяти. Поэтому в многозадачной системе иногда приходится использовать более сложные локальные алгоритмы. Применение локальных алгоритмов требует хранения в операционной системе списка физических кадров, выделенных каждому процессу. Этот список страниц иногда называют <b>резидентным множеством</b> процесса. В одном из следующих разделов рассмотрен вариант алгоритма подкачки, основанный на приведении резидентного множества в соответствие так называемому <b>рабочему набору</b> процесса.</p><div  class="lecture_mark" id="mark_27"></div><p  id="id_28">Эффективность алгоритма обычно оценивается на конкретной последовательности ссылок к памяти, для которой подсчитывается число возникающих <span class="keyword">page faults</span>. Эта последовательность называется <b>строкой обращений</b> (reference string). Мы можем генерировать строку обращений искусственным образом при помощи датчика случайных чисел или трассируя конкретную систему. Последний метод дает слишком много ссылок, для уменьшения числа которых можно сделать две вещи:</p><div  class="lecture_mark" id="mark_28"></div><ul  id="id_29"><li>для конкретного размера страниц можно запоминать только их номера, а не адреса, на которые идет ссылка; </li><li>несколько подряд идущих ссылок на одну страницу можно фиксировать один раз.</li></ul><div  class="lecture_mark" id="mark_29"></div><p  id="id_32">Как уже говорилось, большинство процессоров имеют простейшие аппаратные средства, позволяющие собирать некоторую статистику обращений к памяти. Эти средства обычно включают два специальных флага на каждый элемент таблицы страниц. Флаг ссылки (reference бит) автоматически устанавливается, когда происходит любое обращение к этой странице, а уже рассмотренный выше флаг изменения (modify бит) устанавливается, если производится запись в эту страницу. Операционная система периодически проверяет установку таких флагов, для того чтобы выделить активно используемые страницы, после чего значения этих флагов сбрасываются. </p><div  class="lecture_mark" id="mark_32"></div><p  id="id_33">Рассмотрим ряд алгоритмов замещения страниц.</p><div  class="lecture_mark" id="mark_33"></div><h4 >Алгоритм FIFO. Выталкивание первой пришедшей страницы</h4><p  id="id_34">Простейший алгоритм. Каждой странице присваивается временная метка. Реализуется это просто созданием очереди страниц, в конец которой страницы попадают, когда загружаются в физическую память, а из начала берутся, когда требуется освободить память. Для замещения выбирается старейшая страница. К сожалению, эта стратегия с достаточной вероятностью будет приводить к замещению активно используемых страниц, например страниц кода текстового процессора при редактировании файла. Заметим, что при замещении активных страниц все работает корректно, но <span class="keyword">page fault</span> происходит немедленно.</p><div  class="lecture_mark" id="mark_34"></div><h5 >Аномалия Билэди (Belady)</h5><p  id="id_35">На первый взгляд кажется очевидным, что чем больше в памяти страничных кадров, тем реже будут иметь место <span class="keyword">page faults</span>. Удивительно, но это не всегда так. <a name="keyword-context.5"></a>Как установил Билэди с коллегами, определенные последовательности обращений к страницам в действительности приводят к увеличению числа <span class="keyword">страничных нарушений</span> при увеличении кадров, выделенных процессу. Это явление носит название <span class="keyword_def">"аномалии Билэди"</span> или "аномалии <span class="keyword">FIFO</span>".</p><div  class="lecture_mark" id="mark_35"></div><p  id="id_36">Система с тремя кадрами (9 faults) оказывается более производительной, чем с четырьмя кадрами (10 faults), для строки обращений к памяти <span class="texample">012301401234</span> при выборе стратегии <span class="keyword">FIFO</span>.</p><div  class="lecture_mark" id="mark_36"></div><p  align="left" id="id_38"><a name="image.10.1"></a><div><img src="10. Аппаратно-независимый уровень управления виртуальной памятью_files/10-10000.gif" alt="Аномалия Билэди: (a) - FIFO с тремя страничными кадрами; (b) - FIFO с четырьмя страничными кадрами" width="428" height="315"></div><br><b>Рис. 10.1.</b> 
        Аномалия Билэди: (a) - FIFO с тремя страничными кадрами; (b) - FIFO с четырьмя страничными кадрами</p><div  class="lecture_mark" id="mark_38"></div><p  id="id_39"><span class="keyword">Аномалию Билэди</span> следует считать скорее курьезом, чем фактором, требующим серьезного отношения, который иллюстрирует сложность ОС, где интуитивный подход не всегда приемлем.</p><div  class="lecture_mark" id="mark_39"></div><h4 >Оптимальный алгоритм (OPT)</h4><p  id="id_40">Одним из последствий открытия <span class="keyword">аномалии Билэди</span> стал поиск оптимального алгоритма, который при заданной строке обращений имел бы минимальную частоту <span class="keyword">page faults</span> среди всех других алгоритмов. Такой алгоритм был найден. Он прост: замещай страницу, которая не будет использоваться в течение самого длительного периода времени.</p><div  class="lecture_mark" id="mark_40"></div><p  id="id_41">Каждая страница должна быть помечена числом инструкций, которые будут выполнены, прежде чем на эту страницу будет сделана первая ссылка. Выталкиваться должна страница, для которой это число наибольшее.</p><div  class="lecture_mark" id="mark_41"></div><p  id="id_42">Этот алгоритм легко описать, но реализовать невозможно. ОС не знает, к какой странице будет следующее обращение. (Ранее такие проблемы возникали при планировании процессов - алгоритм SJF). </p><div  class="lecture_mark" id="mark_42"></div><p  id="id_43">Зато мы можем сделать вывод, что для того, чтобы алгоритм замещения был максимально близок к идеальному алгоритму, система должна как можно точнее предсказывать обращения процессов к памяти. Данный алгоритм применяется для оценки качества реализуемых алгоритмов.</p><div  class="lecture_mark" id="mark_43"></div><h4 >Выталкивание дольше всего не использовавшейся страницы. Алгоритм LRU </h4><p  id="id_44">Одним из приближений к алгоритму OPT является алгоритм, исходящий из эвристического правила, что недавнее прошлое - хороший ориентир для прогнозирования ближайшего будущего. </p><div  class="lecture_mark" id="mark_44"></div><p  id="id_45"><a name="keyword-context.6"></a>Ключевое отличие между <span class="keyword">FIFO</span> и оптимальным алгоритмом заключается в том, что один смотрит назад, а другой вперед. Если использовать прошлое для аппроксимации будущего, имеет смысл замещать страницу, которая не использовалась в течение самого долгого времени. Такой подход называется <span class="keyword_def">least recently used</span> алгоритм (<span class="keyword">LRU</span>). Работа алгоритма проиллюстрирована на рис. <a href="">рис. 10.2</a>. Сравнивая рис. 10.1 b и 10.2, можно увидеть, что использование LRU алгоритма позволяет сократить количество страничных нарушений.</p><div  class="lecture_mark" id="mark_45"></div><p  align="left" id="id_46"><a name="image.10.2"></a><div><img src="10. Аппаратно-независимый уровень управления виртуальной памятью_files/10-20000.gif" alt="Пример работы алгоритма LRU" width="420" height="150"></div><br><b>Рис. 10.2.</b> 
        Пример работы алгоритма LRU</p><div  class="lecture_mark" id="mark_46"></div><p  id="id_47"><span class="keyword">LRU</span> - хороший, но труднореализуемый алгоритм. Необходимо иметь связанный список всех страниц в памяти, в начале которого будут хранится недавно использованные страницы. Причем этот список должен обновляться при каждом обращении к памяти. Много времени нужно и на поиск страниц в таком списке. </p><div  class="lecture_mark" id="mark_47"></div><p  id="id_48">В [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#30">Таненбаум, 2002</a>] рассмотрен вариант реализации алгоритма <span class="keyword">LRU</span> со специальным 64-битным указателем, который автоматически увеличивается на единицу после выполнения каждой инструкции, а в таблице страниц имеется соответствующее поле, в которое заносится значение указателя при каждой ссылке на страницу. При возникновении <span class="keyword">page fault</span> выгружается страница с наименьшим значением этого поля.</p><div  class="lecture_mark" id="mark_48"></div><p  id="id_49">Как оптимальный алгоритм, так и <span class="keyword">LRU</span> не страдают от <span class="keyword">аномалии Билэди</span>. Существует класс алгоритмов, для которых при одной и той же строке обращений множество страниц в памяти для n кадров всегда является подмножеством страниц для n+1 кадра. Эти алгоритмы не проявляют <span class="keyword">аномалии Билэди</span> и называются стековыми (stack) алгоритмами.</p><div  class="lecture_mark" id="mark_49"></div><h4 >Выталкивание редко используемой страницы. Алгоритм NFU </h4><p  id="id_50">Поскольку большинство современных процессоров не предоставляют соответствующей аппаратной поддержки для реализации алгоритма <span class="keyword">LRU</span>, хотелось бы иметь алгоритм, достаточно близкий к <span class="keyword">LRU</span>, но не требующий специальной поддержки.</p><div  class="lecture_mark" id="mark_50"></div><p  id="id_51">Программная реализация алгоритма, близкого к <span class="keyword">LRU</span>, - алгоритм NFU(Not Frequently Used).</p><div  class="lecture_mark" id="mark_51"></div><p  id="id_52">Для него требуются программные счетчики, по одному на каждую страницу, которые сначала равны нулю. При каждом прерывании по времени (а не после каждой инструкции) операционная система сканирует все страницы в памяти и у каждой страницы с установленным флагом обращения увеличивает на единицу значение счетчика, а флаг обращения сбрасывает.</p><div  class="lecture_mark" id="mark_52"></div><p  id="id_53">Таким образом, кандидатом на освобождение оказывается страница с наименьшим значением счетчика, как страница, к которой реже всего обращались. Главный недостаток алгоритма NFU состоит в том, что он ничего не забывает. Например, страница, к которой очень часто обращались в течение некоторого времени, а потом обращаться перестали, все равно не будет удалена из памяти, потому что ее счетчик содержит большую величину. Например, в многопроходных компиляторах страницы, которые активно использовались во время первого прохода, могут надолго сохранить большие значения счетчика, мешая загрузке полезных в дальнейшем страниц.</p><div  class="lecture_mark" id="mark_53"></div><p  id="id_54">К счастью, возможна небольшая модификация алгоритма, которая позволяет ему "забывать". Достаточно, чтобы при каждом прерывании по времени содержимое счетчика сдвигалось вправо на 1 бит, а уже затем производилось бы его увеличение для страниц с установленным флагом обращения.</p><div  class="lecture_mark" id="mark_54"></div><p  id="id_55">Другим, уже более устойчивым недостатком алгоритма является длительность процесса сканирования таблиц страниц.</p><div  class="lecture_mark" id="mark_55"></div><h4 >Другие алгоритмы</h4><p  id="id_56">Для полноты картины можно упомянуть еще несколько алгоритмов.</p><div  class="lecture_mark" id="mark_56"></div><p  id="id_57">Например, алгоритм Second-Chance - модификация алгоритма <span class="keyword">FIFO</span>, которая позволяет избежать потери часто используемых страниц с помощью анализа флага обращений (бита ссылки) для самой старой страницы. Если флаг установлен, то страница, в отличие от алгоритма <span class="keyword">FIFO</span>, не выталкивается, а ее флаг сбрасывается, и страница переносится в конец очереди. Если первоначально флаги обращений были установлены для всех страниц (на все страницы ссылались), алгоритм Second-Chance превращается в алгоритм <span class="keyword">FIFO</span>. Данный алгоритм использовался в Multics и BSD Unix.</p><div  class="lecture_mark" id="mark_57"></div><p  id="id_58">В компьютере Macintosh использован алгоритм NRU (Not Recently-Used), где страница-"жертва" выбирается на основе анализа битов модификации и ссылки. Интересные стратегии, основанные на буферизации страниц, реализованы в VAX/VMS и Mach.</p><div  class="lecture_mark" id="mark_58"></div><p  id="id_59">Имеется также и много других алгоритмов замещения. Объем этого курса не позволяет рассмотреть их подробно. Подробное описание различных алгоритмов замещения можно найти в монографиях [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#16">Дейтел, 1987</a>], [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#34">Цикритис, 1977</a>], [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#30">Таненбаум, 2002</a>] и др.</p><div  class="lecture_mark" id="mark_59"></div><h3 >Управление количеством страниц, выделенных процессу. Модель рабочего множества</h3><p  id="id_60">В <span class="keyword">стратегиях замещения</span>, рассмотренных в предыдущем разделе, прослеживается предположение о том, что количество кадров, принадлежащих процессу, нельзя увеличить. Это приводит к необходимости выталкивания страницы. Рассмотрим более общий подход, базирующийся на концепции рабочего множества, сформулированной Деннингом [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#35">Denning, 1996</a>].</p><div  class="lecture_mark" id="mark_60"></div><p  id="id_61">Итак, что делать, если в распоряжении процесса имеется недостаточное число кадров? Нужно ли его приостановить с освобождением всех кадров? Что следует понимать под достаточным количеством кадров? </p><div  class="lecture_mark" id="mark_61"></div><h4 >Трешинг (Thrashing)</h4><p  id="id_62">Хотя теоретически возможно уменьшить число кадров процесса до минимума, существует какое-то число активно используемых страниц, без которого процесс часто генерирует <span class="keyword">page faults</span>. <a name="keyword-context.7"></a>Высокая частота <span class="keyword">страничных нарушений</span> называется <span class="keyword_def">трешинг</span> (thrashing, иногда употребляется русский термин "пробуксовка", см. <a href="">рис. 10.3</a>). Процесс находится в состоянии <span class="keyword">трешинга</span>, если при его работе больше времени уходит на подкачку страниц, нежели на выполнение команд. Такого рода критическая ситуация возникает вне зависимости от конкретных алгоритмов замещения.</p><div  class="lecture_mark" id="mark_62"></div><p  align="left" id="id_63"><a name="image.10.3"></a><div><img src="10. Аппаратно-независимый уровень управления виртуальной памятью_files/10-30000.gif" alt="Частота page faults в зависимости от количества кадров, выделенных процессу" width="426" height="179"></div><br><b>Рис. 10.3.</b> 
        Частота page faults в зависимости от количества кадров, выделенных процессу</p><div  class="lecture_mark" id="mark_63"></div><p  id="id_64">Часто результатом <span class="keyword">трешинга</span> является снижение производительности вычислительной системы. Один из нежелательных сценариев развития событий может выглядеть следующим образом. При глобальном алгоритме замещения процесс, которому не хватает кадров, начинает отбирать кадры у других процессов, которые в свою очередь начинают заниматься тем же. В результате все процессы попадают в очередь запросов к устройству вторичной памяти (находятся в состоянии ожидания), а очередь процессов в состоянии готовности пустеет. Загрузка процессора снижается. Операционная система реагирует на это увеличением степени мультипрограммирования, что приводит к еще большему <span class="keyword">трешингу</span> и дальнейшему снижению загрузки процессора. Таким образом, пропускная способность системы падает из-за <span class="keyword">трешинга</span>.</p><div  class="lecture_mark" id="mark_64"></div><p  id="id_65">Эффект <span class="keyword">трешинга</span>, возникающий при использовании глобальных алгоритмов, может быть ограничен за счет применения локальных алгоритмов замещения. При локальных алгоритмах замещения если даже один из процессов попал в <span class="keyword">трешинг</span>, это не сказывается на других процессах. Однако он много времени проводит в очереди к устройству выгрузки, затрудняя подкачку страниц остальных процессов.</p><div  class="lecture_mark" id="mark_65"></div><p  id="id_66">Критическая ситуация типа <span class="keyword">трешинга</span> возникает вне зависимости от конкретных алгоритмов замещения. Единственным алгоритмом, теоретически гарантирующим отсутствие <span class="keyword">трешинга</span>, является рассмотренный выше не реализуемый на практике оптимальный алгоритм.</p><div  class="lecture_mark" id="mark_66"></div><p  id="id_67">Итак, <span class="keyword">трешинг</span> - это высокая частота <span class="keyword">страничных нарушений</span>. Hеобходимо ее контролировать. Когда она высока, процесс нуждается в кадрах. Можно, устанавливая желаемую частоту <span class="keyword">page faults</span>, регулировать размер процесса, добавляя или отнимая у него кадры. Может оказаться целесообразным выгрузить процесс целиком. Освободившиеся кадры выделяются другим процессам с высокой частотой <span class="keyword">page faults</span>.</p><div  class="lecture_mark" id="mark_67"></div><p  id="id_68">Для предотвращения <span class="keyword">трешинга</span> требуется выделять процессу столько кадров, сколько ему нужно. Hо как узнать, сколько ему нужно? Необходимо попытаться выяснить, как много кадров процесс реально использует. Для решения этой задачи Деннинг использовал <span class="keyword">модель рабочего множества</span>, которая основана на применении принципа локальности. </p><div  class="lecture_mark" id="mark_68"></div><h4 >Модель рабочего множества</h4><p  id="id_69">Рассмотрим поведение реальных процессов.</p><div  class="lecture_mark" id="mark_69"></div><p  id="id_70">Процессы начинают работать, не имея в памяти необходимых страниц. В результате при выполнении первой же машинной инструкции возникает <span class="keyword">page fault</span>, требующий подкачки порции кода. Следующий <span class="keyword">page fault</span> происходит при локализации глобальных переменных и еще один - при выделении памяти для стека. После того как процесс собрал большую часть необходимых ему страниц, <span class="keyword">page faults</span> возникают редко.</p><div  class="lecture_mark" id="mark_70"></div><p  id="id_71">Таким образом, существует набор страниц <span class="texample">(P<sub>1</sub>, P<sub>2</sub>, ... P<sub>n</sub>)</span>, активно использующихся вместе, который позволяет процессу в момент времени <span class="texample">t</span> в течение некоторого периода <span class="texample">T</span> производительно работать, избегая большого количества <span class="keyword">page faults</span>. Этот набор страниц называется <b>рабочим множеством</b> <span class="texample">W(t,T)</span> (<b>working set</b>) процесса. Число страниц в рабочем множестве определяется параметром <span class="texample">Т</span>, является неубывающей функцией <span class="texample">T</span> и относительно невелико. Иногда <span class="texample">T</span> называют размером окна рабочего множества, через которое ведется наблюдение за процессом (см. <a href="">рис. 10.4</a>).</p><div  class="lecture_mark" id="mark_71"></div><p  align="left" id="id_79"><a name="image.10.4"></a><div><img src="10. Аппаратно-независимый уровень управления виртуальной памятью_files/10-40000.gif" alt="Пример рабочего множества процесса" width="425" height="82"></div><br><b>Рис. 10.4.</b> 
        Пример рабочего множества процесса</p><div  class="lecture_mark" id="mark_79"></div><p  id="id_80">Легко написать тестовую программу, которая систематически работает с большим диапазоном адресов, но, к счастью, большинство реальных процессов не ведут себя подобным образом, а проявляют свойство локальности. В течение любой фазы вычислений процесс работает с небольшим количеством страниц.</p><div  class="lecture_mark" id="mark_80"></div><p  id="id_81">Когда процесс выполняется, он двигается от одного рабочего множества к другому. Программа обычно состоит из нескольких рабочих множеств, которые могут перекрываться. Hапример, когда вызвана процедура, она определяет новое рабочее множество, состоящее из страниц, содержащих инструкции процедуры, ее локальные и глобальные переменные. После ее завершения процесс покидает это рабочее множество, но может вернуться к нему при новом вызове процедуры. Таким образом, рабочее множество определяется кодом и данными программы. Если процессу выделять меньше кадров, чем ему требуется для поддержки рабочего множества, он будет находиться в состоянии <span class="keyword">трешинга</span>.</p><div  class="lecture_mark" id="mark_81"></div><p  id="id_82">Принцип локальности ссылок препятствует частым изменениям рабочих наборов процессов. Формально это можно выразить следующим образом. Если в период времени <span class="texample">(t-T, t)</span> программа обращалась к страницам <span class="texample">W(t,T)</span>, то при надлежащем выборе <span class="texample">T</span> с большой вероятностью эта программа будет обращаться к тем же страницам в период времени <span class="texample">(t, t+T)</span>. Другими словами, принцип локальности утверждает, что если не слишком далеко заглядывать в будущее, то можно достаточно точно его прогнозировать исходя из прошлого. Понятно, что с течением времени рабочий набор процесса может изменяться (как по составу страниц, так и по их числу).</p><div  class="lecture_mark" id="mark_82"></div><p  id="id_87">Наиболее важное свойство рабочего множества - его размер. ОС должна выделить каждому процессу достаточное число кадров, чтобы поместилось его рабочее множество. Если кадры еще остались, то может быть инициирован другой процесс. Если рабочие множества процессов не помещаются в память и начинается <span class="keyword">трешинг</span>, то один из процессов можно выгрузить на диск.</p><div  class="lecture_mark" id="mark_87"></div><p  id="id_88">Решение о размещении процессов в памяти должно, следовательно, базироваться на размере его рабочего множества. Для впервые инициируемых процессов это решение может быть принято эвристически. Во время работы процесса система должна уметь определять: расширяет процесс свое рабочее множество или перемещается на новое рабочее множество. Если в состав атрибутов страницы включить время последнего использования <span class="texample">t<sub>i</sub></span> (для страницы с номером <span class="texample">i</span>), то принадлежность i-й страницы к рабочему набору, определяемому параметром <span class="texample">T</span> в момент времени <span class="texample">t</span> будет выражаться неравенством: <span class="texample">t-T &lt; t<sub>i</sub> &lt; t</span>. <span class="keyword">Алгоритм выталкивания страниц</span> WSClock, использующий информацию о рабочем наборе процесса, описан в [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#30">Таненбаум, 2002</a>].</p><div  class="lecture_mark" id="mark_88"></div><p  id="id_94">Другой способ реализации данного подхода может быть основан на отслеживании количества <span class="keyword">страничных нарушений</span>, вызываемых процессом. Если процесс часто генерирует <span class="keyword">page faults</span> и память не слишком заполнена, то система может увеличить число выделенных ему кадров. Если же процесс не вызывает исключительных ситуаций в течение некоторого времени и уровень генерации ниже какого-то порога, то число кадров процесса может быть урезано. Этот способ регулирует лишь размер множества страниц, принадлежащих процессу, и должен быть дополнен какой-либо <span class="keyword">стратегией замещения</span> страниц. Несмотря на то что система при этом может пробуксовывать в моменты перехода от одного рабочего множества к другому, предлагаемое решение в состоянии обеспечить наилучшую производительность для каждого процесса, не требуя никакой дополнительной настройки системы.</p><div  class="lecture_mark" id="mark_94"></div><h3 >Страничные демоны</h3><p  id="id_95">Подсистема виртуальной памяти работает производительно при наличии резерва свободных страничных кадров. Алгоритмы, обеспечивающие поддержку системы в состоянии отсутствия <span class="keyword">трешинга</span>, реализованы в составе фоновых процессов (их часто называют демонами или сервисами), которые периодически "просыпаются" и инспектируют состояние памяти. Если свободных кадров оказывается мало, они могут сменить <span class="keyword">стратегию замещения</span>. Их задача - поддерживать систему в состоянии наилучшей производительности.</p><div  class="lecture_mark" id="mark_95"></div><p  id="id_96">Примером такого рода процесса может быть фоновый процесс - сборщик страниц, реализующий облегченный вариант алгоритма откачки, основанный на использовании рабочего набора и применяемый во многих клонах ОС Unix (см., например,[<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#1">Bach, 1986</a>]). Данный демон производит откачку страниц, не входящих в рабочие наборы процессов. Он начинает активно работать, когда количество страниц в списке свободных страниц достигает установленного нижнего порога, и пытается выталкивать страницы в соответствии с собственной стратегией.</p><div  class="lecture_mark" id="mark_96"></div><p  id="id_97">Но если возникает требование страницы в условиях, когда список свободных страниц пуст, то начинает работать механизм свопинга, поскольку простое отнятие страницы у любого процесса (включая тот, который затребовал бы страницу) потенциально вело бы к ситуации thrashing, и разрушало бы рабочий набор некоторого процесса. Любой процесс, затребовавший страницу не из своего текущего рабочего набора, становится в очередь на выгрузку в расчете на то, что после завершения выгрузки хотя бы одного из процессов свободной памяти уже может быть достаточно. </p><div  class="lecture_mark" id="mark_97"></div><p  id="id_98">В ОС Windows 2000 аналогичную роль играет менеджер балансного набора (Working set manager), который вызывается раз в секунду или тогда, когда размер свободной памяти опускается ниже определенного предела, и отвечает за суммарную политику управления памятью и поддержку рабочих множеств.</p><div  class="lecture_mark" id="mark_98"></div><h3 >Программная поддержка сегментной модели памяти процесса</h3><p  id="id_99">Реализация функций операционной системы, связанных с поддержкой памяти, - ведение таблиц страниц, трансляция адреса, обработка страничных ошибок, управление ассоциативной памятью и др. - тесно связана со структурами данных, обеспечивающими удобное представление адресного пространства процесса. Формат этих структур сильно зависит от аппаратуры и особенностей конкретной ОС.</p><div  class="lecture_mark" id="mark_99"></div><p  id="id_100">Чаще всего виртуальная память процесса ОС разбивается на сегменты пяти типов: кода программы, данных, стека, разделяемый и сегмент файлов, отображаемых в память (см. <a href="">рис. 10.5</a>).</p><div  class="lecture_mark" id="mark_100"></div><p  id="id_101"><b>Сегмент программного кода</b> содержит только команды. Сегмент программного кода не модифицируется в ходе выполнения процесса, обычно страницы данного сегмента имеют атрибут read-only. Следствием этого является возможность использования одного экземпляра кода для разных процессов.</p><div  class="lecture_mark" id="mark_101"></div><p  id="id_102"><b>Сегмент данных</b>, содержащий переменные программы и сегмент стека, содержащий автоматические переменные, могут динамически менять свой размер (обычно данные в сторону увеличения адресов, а стек - в сторону уменьшения) и содержимое, должны быть доступны по чтению и записи и являются приватными сегментами процесса.</p><div  class="lecture_mark" id="mark_102"></div><p  align="left" id="id_103"><a name="image.10.5"></a><div><img src="10. Аппаратно-независимый уровень управления виртуальной памятью_files/10-50000.gif" alt="Образ процесса в памяти" width="424" height="286"></div><br><b>Рис. 10.5.</b> 
        Образ процесса в памяти</p><div  class="lecture_mark" id="mark_103"></div><p  id="id_104">С целью обобществления памяти между несколькими процессами создаются <b>разделяемые сегменты</b>, допускающие доступ по чтению и записи. Вариантом разделяемого сегмента может быть <b>сегмент файла, отображаемого в память</b>. Специфика таких сегментов состоит в том, что из них откачка осуществляется не в системную область выгрузки, а непосредственно в отображаемый файл. Реализация разделяемых сегментов основана на том, что логические страницы различных процессов связываются с одними и теми же страничными кадрами.</p><div  class="lecture_mark" id="mark_104"></div><p  id="id_105">Сегменты представляют собой непрерывные области (в Linux они так и называются - области) в виртуальном адресном пространстве процесса, выровненные по границам страниц. Каждая область состоит из набора страниц с одним и тем же режимом защиты. Между областями в виртуальном пространстве могут быть свободные участки. Естественно, что подобные объекты описаны соответствующими структурами (см., например, структуры <span class="texample">mm_struct</span> и <span class="texample">vm_area_struct</span> в Linux).</p><div  class="lecture_mark" id="mark_105"></div><p  id="id_108">Часть работы по организации сегментов может происходить с участием программиста. Особенно это заметно при низкоуровневом программировании. В частности, отдельные области памяти могут быть поименованы и использоваться для обмена данными между процессами. Два процесса могут общаться через разделяемую область памяти при условии, что им известно ее имя (пароль). Обычно это делается при помощи специальных вызовов (например, map и unmap), входящих в состав интерфейса виртуальной памяти.</p><div  class="lecture_mark" id="mark_108"></div><p  id="id_109">Загрузка исполняемого файла (системный вызов exec) осуществляется обычно через отображение (mapping) его частей (кода, данных) в соответствующие сегменты адресного пространства процесса. Например, сегмент кода является сегментом отображаемого в память файла, содержащего исполняемую программу. При попытке выполнить первую же инструкцию система обнаруживает, что нужной части кода в памяти нет, генерирует <span class="keyword">page fault</span> и подкачивает эту часть кода с диска. Далее процедура повторяется до тех пор, пока вся программа не окажется в оперативной памяти.</p><div  class="lecture_mark" id="mark_109"></div><p  id="id_110">Как уже говорилось, размер сегмента данных динамически меняется. Рассмотрим, как организована поддержка сегментов данных в Unix. Пользователь, запрашивая (библиотечные вызовы <span class="texample">malloc</span>, <span class="texample">new</span>) или освобождая (<span class="texample">free</span>, <span class="texample">delete</span>) память для динамических данных, фактически изменяет границу выделенной процессу памяти через системный вызов <span class="texample">brk</span> (от слова break), который модифицирует значение переменной <span class="texample">brk</span> из структуры данных процесса. В результате происходит выделение физической памяти, граница <span class="texample">brk</span> смещается в сторону увеличения виртуальных адресов, а соответствующие строки таблиц страниц получают осмысленные значения. При помощи того же вызова <span class="texample">brk</span> пользователь может уменьшить размер сегмента данных. На практике освобожденная пользователем виртуальная память (библиотечные вызовы <span class="texample">free</span>, <span class="texample">delete</span>) системе не возвращается. На это есть две причины. Во-первых, для уменьшения размеров сегмента данных необходимо организовать его уплотнение или "сборку мусора". А во-вторых, незанятые внутри сегмента данных области естественным образом будут вытолкнуты из оперативной памяти вследствие того, что к ним не будет обращений. Ведение списков занятых и свободных областей памяти в сегменте данных пользователя осуществляется на уровне системных библиотек.</p><div  class="lecture_mark" id="mark_110"></div><p  id="id_121">Более подробно информация об адресных пространствах процессов в Unix изложена в [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#36">Кузнецов</a>], [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#1">Bach, 1986</a>].</p><div  class="lecture_mark" id="mark_121"></div><h3 >Отдельные аспекты функционирования менеджера памяти</h3><p  id="id_122">Корректная работа менеджера памяти помимо принципиальных вопросов, связанных с выбором абстрактной модели виртуальной памяти и ее аппаратной поддержкой, обеспечивается также множеством нюансов и мелких деталей. В качестве примера такого рода компонента рассмотрим более подробно <b>локализацию страниц в памяти</b>, которая применяется в тех случаях, когда поддержка страничной системы приводит к необходимости разрешить определенным страницам, хранящим буферы ввода-вывода, другие важные данные и код, быть блокированными в памяти. </p><div  class="lecture_mark" id="mark_122"></div><p  id="id_123">Рассмотрим случай, когда система виртуальной памяти может вступить в конфликт с подсистемой ввода-вывода. Например, процесс может запросить ввод в буфер и ожидать его завершения. Управление передастся другому процессу, который может вызвать <span class="keyword">page fault</span> и, с отличной от нуля вероятностью, спровоцировать выгрузку той страницы, куда должен быть осуществлен ввод первым процессом. Подобные ситуации нуждаются в дополнительном контроле, особенно если ввод-вывод реализован с использованием механизма прямого доступа к памяти (DMA). Одно из решений данной проблемы - вводить данные в не вытесняемый буфер в пространстве ядра, а затем копировать их в пользовательское пространство.</p><div  class="lecture_mark" id="mark_123"></div><p  id="id_124">Второе решение - локализовать страницы в памяти, используя специальный бит локализации, входящий в состав атрибутов страницы. Локализованная страница замещению не подлежит. Бит локализации сбрасывается после завершения операции ввода-вывода.</p><div  class="lecture_mark" id="mark_124"></div><p  id="id_125">Другое использование бита локализации может иметь место и при нормальном замещении страниц. Рассмотрим следующую цепь событий. Низкоприоритетный процесс после длительного ожидания получил в свое распоряжение процессор и подкачал с диска нужную ему страницу. Если он сразу после этого будет вытеснен высокоприоритетным процессом, последний может легко заместить вновь подкачанную страницу низкоприоритетного, так как на нее не было ссылок. Имеет смысл вновь загруженные страницы помечать битом локализации до первой ссылки, иначе низкоприоритетный процесс так и не начнет работать.</p><div  class="lecture_mark" id="mark_125"></div><p  id="id_126">Использование бита локализации может быть опасным, если забыть его отключить. Если такая ситуация имеет место, страница становится неиспользуемой. SunOS разрешает использование данного бита в качестве подсказки, которую можно игнорировать, когда пул свободных кадров становится слишком маленьким. </p><div  class="lecture_mark" id="mark_126"></div><p  id="id_127">Другим важным применением локализации является ее использование в системах мягкого <b>реального времени</b>. Рассмотрим процесс или нить реального времени. Вообще говоря, виртуальная память - антитеза вычислений реального времени, так как дает непредсказуемые задержки при подкачке страниц. Поэтому системы реального времени почти не используют виртуальную память. ОС Solaris поддерживает как реальное время, так и разделение времени. Для решения проблемы <span class="keyword">page faults</span>, Solaris разрешает процессам сообщать системе, какие страницы важны для процесса, и локализовать их в памяти. В результате возможно выполнение процесса, реализующего задачу реального времени, содержащего локализованные страницы, где временные задержки страничной системы будут минимизированы.</p><div  class="lecture_mark" id="mark_127"></div><p  id="id_128">Помимо системы локализации страниц, есть и другие интересные проблемы, возникающие в процессе управления памятью. Так, например, бывает непросто осуществить повторное выполнение инструкции, вызвавшей <span class="keyword">page fault</span>. Представляют интерес и алгоритмы отложенного выделения памяти (копирование при записи и др.). Ограниченный объем данного курса не позволяет рассмотреть их более подробно.</p><div  class="lecture_mark" id="mark_128"></div><h3 >Заключение</h3><p  id="id_129">Описанная система управления памятью является совокупностью программно-технических средств, обеспечивающих производительное функционирование современных компьютеров. Успех реализации той части ОС, которая относится к управлению виртуальной памятью, определяется близостью архитектуры аппаратных средств, поддерживающих виртуальную память, к абстрактной модели виртуальной памяти ОС. Справедливости ради заметим, что в подавляющем большинстве современных компьютеров аппаратура выполняет функции, существенно превышающие потребности модели ОС, так что создание аппаратно-зависимой части подсистемы управления виртуальной памятью ОС в большинстве случаев не является чрезмерно сложной задачей. </p><div  class="lecture_mark" id="mark_129"></div>


	</td>
	</tr>
	<tr><td height="8"><img src="10. Аппаратно-независимый уровень управления виртуальной памятью_files/empty000.gif" width="1" height="8"></td></tr>
	</table>
	<!-- /content -->

</td>
<td><img src="10. Аппаратно-независимый уровень управления виртуальной памятью_files/empty000.gif" width="8" height="1"></td>
</tr>
</table>
<!-- /bottom -->
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td class="orang" height="1"><img src="10. Аппаратно-независимый уровень управления виртуальной памятью_files/empty000.gif" width="1" height="1"></td></tr>
<td class="ltxt" align=center>&copy; INTUIT.ru, 2003-2008. Все права защищены.</td>
</tr>
</table>
<!-- /bottom -->

<script src="10. Аппаратно-независимый уровень управления виртуальной памятью_files/urchin00.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-3475067-1";
urchinTracker();
</script></body>
</html>


<!-- This document saved from http://www.intuit.ru/department/os/osintro/10/osintro_10.html -->
