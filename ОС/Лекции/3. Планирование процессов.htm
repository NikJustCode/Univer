<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>INTUIT.ru::Интернет-Университет Информационных Технологий</title>
<link href="3. Планирование процессов_files/printabl.css" type="text/css" rel="stylesheet">
</head>
<body leftmargin="6" topmargin="6" marginheight="6" marginwidth="6">


<div align="left">
<span style="color: #000000; font-weight: bold;">
&nbsp;&nbsp;
<span style="font-size:12pt;">Интернет-Университет Информационных Технологий</span>
</span>
</div>

&nbsp;&nbsp;
<span align="rright" style="color: #330066; text-decoration:underline;">http://www.INTUIT.ru</span>


<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td height="8" colspan=3><img src="3. Планирование процессов_files/empty000.gif" width="1" height="8"></td></tr>
<tr><td class="orang" height="1" colspan=3><img src="3. Планирование процессов_files/empty000.gif" width="1" height="1"></td></tr>
<tr><td height="8" colspan=3><img src="3. Планирование процессов_files/empty000.gif" width="1" height="8"></td></tr>
<tr valign="top">
<td><img src="3. Планирование процессов_files/empty000.gif" width="8" height="1"></td>
<td>
	<!-- content -->
	<table border="0" cellpadding="0" cellspacing="0" width="100%">
	<tr><td class="head">Основы операционных систем</td></tr>
<tr><td height="4"><img src="3. Планирование процессов_files/empty000.gif" width="1" height="4"></td></tr>
	<tr><td class="orang" height="1"><img src="3. Планирование процессов_files/empty000.gif" width="1" height="1"></td></tr>
	<tr><td height="8"><img src="3. Планирование процессов_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td><span class="headsub">


3. Лекция:

 Планирование процессов: версия для печати и PDA</span>

<br>
<span class="rtxt">В этой лекции рассматриваются вопросы, связанные с различными уровнями планирования процессов в операционных системах. Описываются основные цели и критерии планирования, а также параметры, на которых оно основывается. Приведены различные алгоритмы планирования.
</span>

</td></tr>

	<tr><td height="8"><img src="3. Планирование процессов_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td class="orang" height="1"><img src="3. Планирование процессов_files/empty000.gif" width="1" height="1"></td></tr>
	<tr><td height="8"><img src="3. Планирование процессов_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td>


<h3 ></h3><blockquote >Я планов наших люблю громадьё...<div class="xml_quote_author">В. В. Маяковский</div></blockquote><blockquote >Чем тщательнее мы планируем свою деятельность,
тем меньше времени остается на ее осуществление.</blockquote><p  id="id_3">Из анналов Госплана</p><div  class="lecture_mark" id="mark_3"></div><p  id="id_4">Всякий раз, когда нам приходится иметь дело с ограниченным количеством ресурсов и несколькими их потребителями, будь то фонд заработной платы в трудовом коллективе или студенческая вечеринка с несколькими ящиками пива, мы вынуждены заниматься распределением наличных ресурсов между потребителями или, другими словами, планированием использования ресурсов. Такое планирование должно иметь четко поставленные цели (чего мы хотим добиться за счет распределения ресурсов) и алгоритмы, соответствующие целям и опирающиеся на <span class="keyword">параметры</span> потребителей. Только при правильном выборе <span class="keyword">критериев</span> и алгоритмов можно избежать таких вопросов, как: "Почему я получаю в десять раз меньше, чем мой шеф?" или "А где мое пиво?". Настоящая лекция посвящена <span class="keyword">планированию исполнения процессов</span> в мультипрограммных вычислительных системах или, иначе говоря, <span class="keyword">планированию процессов</span>.</p><div  class="lecture_mark" id="mark_4"></div><h3 >Уровни планирования </h3><p  id="id_5">В первой лекции, рассматривая эволюцию компьютерных систем, мы говорили о двух видах <span class="keyword">планирования</span> в вычислительных системах: <span class="keyword">планировании</span> заданий и <span class="keyword">планировании</span> использования процессора. <span class="keyword">Планирование</span> заданий появилось в пакетных системах после того, как для хранения сформированных пакетов заданий начали использоваться магнитные диски. Магнитные диски, являясь устройствами прямого доступа, позволяют загружать задания в компьютер в произвольном порядке, а не только в том, в котором они были записаны на диск. Изменяя порядок загрузки заданий в вычислительную систему, можно повысить эффективность ее использования. <a name="keyword-context.1"></a>Процедуру выбора очередного задания для загрузки в машину, т. е. для порождения соответствующего процесса, мы и назвали <span class="keyword_def">планированием</span> заданий. <span class="keyword">Планирование</span> использования процессора впервые возникает в мультипрограммных вычислительных системах, где в состоянии готовность могут одновременно находиться несколько процессов. Именно для процедуры выбора из них одного процесса, который получит процессор в
свое распоряжение, т. е. будет переведен в состояние исполнение, мы использовали это словосочетание. Теперь, познакомившись с концепцией процессов в вычислительных системах, оба вида <span class="keyword">планирования</span> мы будем рассматривать как различные <span class="keyword_def">уровни планирования процессов</span>.</p><div  class="lecture_mark" id="mark_5"></div><p  id="id_6"><a name="keyword-context.2"></a><a name="keyword-context.3"></a><span class="keyword">Планирование</span> заданий используется в качестве <span class="keyword_def">долгосрочного планирования процессов</span>. Оно отвечает за порождение новых процессов в системе, определяя ее <span class="keyword_def">степень мультипрограммирования</span>, т. е. количество процессов, одновременно находящихся в ней. Если <span class="keyword">степень мультипрограммирования</span> системы поддерживается постоянной, т. е. среднее количество процессов в компьютере не меняется, то новые процессы могут появляться только после завершения ранее загруженных. Поэтому <span class="keyword">долгосрочное планирование</span> осуществляется достаточно редко, между появлением новых процессов могут проходить минуты и даже десятки минут. Решение о выборе для запуска того или иного процесса оказывает влияние на функционирование вычислительной системы на протяжении достаточно длительного времени. Отсюда и название этого <span class="keyword">уровня планирования</span> – <span class="keyword">долгосрочное</span>. В некоторых операционных системах <span class="keyword">долгосрочное планирование</span> сведено к минимуму или отсутствует вовсе. Так, например, во многих интерактивных системах разделения времени порождение процесса происходит 
сразу после появления соответствующего запроса. Поддержание разумной <span class="keyword">степени мультипрограммирования</span> осуществляется за счет ограничения количества пользователей, которые могут работать в системе, и особенностей человеческой психологии. Если между нажатием на клавишу и появлением символа на экране проходит 20–30 секунд, то многие пользователи предпочтут прекратить работу и продолжить ее, когда система будет менее загружена.</p><div  class="lecture_mark" id="mark_6"></div><p  id="id_7"><a name="keyword-context.4"></a><span class="keyword">Планирование</span> использования процессора применяется в качестве <span class="keyword_def">краткосрочного планирования процессов</span>. Оно проводится, к примеру, при обращении исполняющегося процесса к устройствам ввода-вывода или просто по завершении определенного интервала времени. Поэтому <span class="keyword">краткосрочное планирование</span> осуществляется, как правило, не реже одного раза в 100 миллисекунд. Выбор нового процесса для исполнения оказывает влияние на функционирование системы до наступления очередного аналогичного события, т. е. в течение короткого промежутка времени, чем и обусловлено название этого <span class="keyword">уровня планирования</span> – <span class="keyword">краткосрочное</span>.</p><div  class="lecture_mark" id="mark_7"></div><p  id="id_8"><a name="keyword-context.5"></a>В некоторых вычислительных системах бывает выгодно для повышения производительности временно удалить какой-либо частично выполнившийся процесс из оперативной памяти на диск, а позже вернуть его обратно для дальнейшего выполнения. Такая процедура в англоязычной литературе получила название swapping, что можно перевести на русский язык как "перекачка", хотя в специальной литературе оно употребляется без перевода – свопинг. Когда и какой из процессов нужно перекачать на диск и вернуть обратно, решается дополнительным промежуточным <span class="keyword">уровнем планирования процессов</span> – <span class="keyword_def">среднесрочным</span>.</p><div  class="lecture_mark" id="mark_8"></div><h3 >Критерии планирования и требования к алгоритмам </h3><p  id="id_9">Для каждого <span class="keyword">уровня планирования процессов</span> можно предложить много различных алгоритмов. Выбор конкретного алгоритма определяется классом задач, решаемых вычислительной системой, и целями, которых мы хотим достичь, используя <span class="keyword">планирование</span>. К числу таких целей можно отнести следующие:</p><div  class="lecture_mark" id="mark_9"></div><ul  id="id_10"><li>Справедливость – гарантировать каждому заданию или процессу определенную часть времени использования процессора в компьютерной системе, стараясь не допустить возникновения ситуации, когда процесс одного пользователя постоянно занимает процессор, в то время как процесс другого пользователя фактически не начинал выполняться.</li><li>Эффективность – постараться занять процессор на все 100% рабочего времени, не позволяя ему простаивать в ожидании процессов, готовых к исполнению. В реальных вычислительных системах загрузка процессора колеблется от 40 до 90%.</li><li><a name="keyword-context.6"></a>Сокращение полного времени выполнения (<span class="keyword_def">turnaround time</span>) – обеспечить минимальное время между стартом процесса или постановкой задания в очередь для загрузки и его завершением.</li><li><a name="keyword-context.7"></a>Сокращение времени ожидания (<span class="keyword_def">waiting time</span>) – сократить время, которое проводят процессы в состоянии готовность и задания в очереди для загрузки.</li><li>Сокращение времени отклика (<span class="keyword_def">response time</span>) – минимизировать время, которое требуется процессу в интерактивных системах для ответа на запрос пользователя.</li></ul><div  class="lecture_mark" id="mark_10"></div><p  id="id_16">Независимо от поставленных целей <span class="keyword">планирования</span> желательно также, чтобы алгоритмы обладали следующими свойствами.</p><div  class="lecture_mark" id="mark_16"></div><ul  id="id_17"><li>Были предсказуемыми. Одно и то же задание должно выполняться приблизительно за одно и то же время. Применение алгоритма <span class="keyword">планирования</span> не должно приводить, к примеру, к извлечению квадратного корня из 4 за сотые доли секунды при одном запуске и за несколько суток – при втором запуске.</li><li>Были связаны с минимальными накладными расходами. Если на каждые 100 миллисекунд, выделенные процессу для использования процессора, будет приходиться 200 миллисекунд на определение того, какой именно процесс получит процессор в свое распоряжение, и на переключение контекста, то такой алгоритм, очевидно, применять не стоит.</li><li>Равномерно загружали ресурсы вычислительной системы, отдавая предпочтение тем процессам, которые будут занимать малоиспользуемые ресурсы. </li><li>Обладали масштабируемостью, т. е. не сразу теряли работоспособность при увеличении нагрузки. Например, рост количества процессов в системе в два раза не должен приводить к увеличению полного времени выполнения процессов на порядок.</li></ul><div  class="lecture_mark" id="mark_17"></div><p  id="id_22">Многие из приведенных выше целей и свойств являются противоречивыми. Улучшая работу алгоритма с точки зрения одного <span class="keyword">критерия</span>, мы ухудшаем ее с точки зрения другого. Приспосабливая алгоритм под один класс задач, мы тем самым дискриминируем задачи другого класса. "В одну телегу впрячь не можно коня и трепетную лань". Ничего не поделаешь. Такова жизнь.</p><div  class="lecture_mark" id="mark_22"></div><h3 >Параметры планирования </h3><p  id="id_23"><a name="keyword-context.8"></a>Для осуществления поставленных целей разумные алгоритмы <span class="keyword">планирования</span> должны опираться на какие-либо характеристики процессов в системе, заданий в очереди на загрузку, состояния самой вычислительной системы, иными словами, на <span class="keyword_def">параметры</span><span class="keyword"> планирования</span>. В этом разделе мы опишем ряд таких <span class="keyword">параметров</span>, не претендуя на полноту изложения. </p><div  class="lecture_mark" id="mark_23"></div><p  id="id_24">Все <span class="keyword">параметры</span><span class="keyword"> планирования</span> можно разбить на две большие группы: статические <span class="keyword">параметры</span> и динамические <span class="keyword">параметры</span>. Статические <span class="keyword">параметры</span> не изменяются в ходе функционирования вычислительной системы, динамические же, напротив, подвержены постоянным изменениям.</p><div  class="lecture_mark" id="mark_24"></div><p  id="id_25">К статическим <span class="keyword">параметрам</span> вычислительной системы можно отнести предельные значения ее ресурсов (размер оперативной памяти, максимальное количество памяти на диске для осуществления свопинга, количество подключенных устройств ввода-вывода и т. п.). Динамические <span class="keyword">параметры</span> системы описывают количество свободных ресурсов на данный момент.</p><div  class="lecture_mark" id="mark_25"></div><p  id="id_26">К статическим <span class="keyword">параметрам</span> процессов относятся характеристики, как правило присущие заданиям уже на этапе загрузки.</p><div  class="lecture_mark" id="mark_26"></div><ul  id="id_27"><li>Каким пользователем запущен процесс или сформировано задание.</li><li>Насколько важной является поставленная задача, т. е. каков <span class="keyword">приоритет</span> ее выполнения.</li><li>Сколько процессорного времени запрошено пользователем для решения задачи.</li><li>Каково соотношение процессорного времени и времени, необходимого для осуществления операций ввода-вывода.</li><li>Какие ресурсы вычислительной системы (оперативная память, устройства ввода-вывода, специальные библиотеки и системные программы и т. д.) и в каком количестве необходимы заданию.</li></ul><div  class="lecture_mark" id="mark_27"></div><p  id="id_33">Алгоритмы <span class="keyword">долгосрочного планирования</span> используют в своей работе статические и динамические <span class="keyword">параметры</span> вычислительной системы и статические <span class="keyword">параметры</span> процессов (динамические <span class="keyword">параметры</span> процессов на этапе загрузки заданий еще не известны). Алгоритмы <span class="keyword">краткосрочного</span> и <span class="keyword">среднесрочного планирования</span> дополнительно учитывают и динамические характеристики процессов. Для <span class="keyword">среднесрочного планирования</span> в качестве таких характеристик может использоваться следующая информация:</p><div  class="lecture_mark" id="mark_33"></div><ul  id="id_34"><li>сколько времени прошло с момента выгрузки процесса на диск или его загрузки в оперативную память;</li><li>сколько оперативной памяти занимает процесс;</li><li>сколько процессорного времени уже предоставлено процессу.</li></ul><div  class="lecture_mark" id="mark_34"></div><p  align="left" id="id_38"><a name="image.3.1"></a><div><img src="3. Планирование процессов_files/10000000.gif" alt="Фрагмент деятельности процесса с выделением промежутков  непрерывного использования процессора и ожидания ввода-вывода" width="185" height="165"></div><br><b>Рис. 3.1.</b> 
        Фрагмент деятельности процесса с выделением промежутков  непрерывного использования процессора и ожидания ввода-вывода</p><div  class="lecture_mark" id="mark_38"></div><p  id="id_39">Для <span class="keyword">краткосрочного планирования</span> нам понадобится ввести еще два динамических <span class="keyword">параметра</span>. Деятельность любого процесса можно представить как последовательность циклов использования процессора и ожидания завершения операций ввода-вывода. <a name="keyword-context.9"></a><a name="keyword-context.10"></a>Промежуток времени непрерывного использования процессора носит название <span class="keyword_def">CPU burst</span>, а промежуток времени непрерывного ожидания ввода-вывода – <span class="keyword_def">I/O burst</span>. На <a href="">рисунке 3.1.</a> показан фрагмент деятельности некоторого процесса на псевдоязыке программирования с выделением указанных промежутков. Для краткости мы будем использовать термины <span class="keyword">CPU burst</span> и <span class="keyword">I/O burst</span> без перевода. Значения продолжительности последних и очередных <span class="keyword">CPU burst</span> и <span class="keyword">I/O burst</span> являются важными динамическими <span class="keyword">параметрами</span> процесса.</p><div  class="lecture_mark" id="mark_39"></div><h3 >Вытесняющее и невытесняющее планирование </h3><p  id="id_40">Процесс <span class="keyword">планирования</span> осуществляется частью операционной системы, называемой планировщиком. Планировщик может принимать решения о выборе для исполнения нового процесса из числа находящихся в состоянии готовность в следующих четырех случаях.</p><div  class="lecture_mark" id="mark_40"></div><ol  id="id_41"><li>Когда процесс переводится из состояния исполнение в состояние закончил исполнение.</li><li>Когда процесс переводится из состояния исполнение в состояние ожидание.</li><li>Когда процесс переводится из состояния исполнение в состояние готовность (например, после прерывания от таймера).</li><li>Когда процесс переводится из состояния ожидание в состояние готовность (завершилась операция ввода-вывода или произошло другое событие). Подробно процедура такого перевода рассматривалась в лекции 2 (раздел "Переключение контекста"), где мы показали, почему при этом возникает возможность смены процесса, находящегося в состоянии исполнение.</li></ol><div  class="lecture_mark" id="mark_41"></div><p  id="id_46">В случаях 1 и 2 процесс, находившийся в состоянии исполнение, не может дальше исполняться, и операционная система вынуждена осуществлять планирование выбирая новый процесс для выполнения. В случаях 3 и 4 <span class="keyword">планирование</span> может как проводиться, так и не проводиться, планировщик не вынужден обязательно принимать решение о выборе процесса для выполнения, процесс, находившийся в состоянии исполнение может просто продолжить свою работу. Если в операционной системе планирование осуществляется только в вынужденных ситуациях, говорят, что имеет место <span class="keyword">невытесняющее (nonpreemptive) планирование</span>. Если планировщик принимает и вынужденные, и невынужденные решения, говорят о <span class="keyword">вытесняющем (preemptive) планировании</span>. Термин <span class="keyword">"вытесняющее планирование"</span> возник потому, что исполняющийся процесс помимо своей воли может быть вытеснен из состояния исполнение другим процессом.</p><div  class="lecture_mark" id="mark_46"></div><p  id="id_47"><a name="keyword-context.11"></a><span class="keyword_def">Невытесняющее планирование</span> используется, например, в MS Windows 3.1 и ОС Apple Macintosh. При таком режиме <span class="keyword">планирования</span> процесс занимает столько процессорного времени, сколько ему необходимо. При этом переключение процессов возникает только при желании самого исполняющегося процесса передать управление (для ожидания завершения операции ввода-вывода или по окончании работы). Этот метод <span class="keyword">планирования</span> относительно просто реализуем и достаточно эффективен, так как позволяет выделить большую часть процессорного времени для работы самих процессов и до минимума сократить затраты на переключение контекста. Однако при <span class="keyword">невытесняющем планировании</span> возникает проблема возможности полного захвата процессора одним процессом, который вследствие каких-либо причин (например, из-за ошибки в программе) зацикливается и не может передать управление другому процессу. В такой ситуации спасает только перезагрузка всей вычислительной системы.</p><div  class="lecture_mark" id="mark_47"></div><p  id="id_48"><a name="keyword-context.12"></a><span class="keyword_def">Вытесняющее планирование</span> обычно используется в системах разделения времени. В этом режиме <span class="keyword">планирования</span> процесс может быть приостановлен в любой момент исполнения. Операционная система устанавливает специальный таймер для генерации сигнала прерывания по истечении некоторого интервала времени – <span class="keyword">кванта</span>. После прерывания процессор передается в распоряжение следующего процесса. Временные прерывания помогают гарантировать приемлемое время отклика процессов для пользователей, работающих в диалоговом режиме, и предотвращают "зависание" компьютерной системы из-за зацикливания какой-либо программы.</p><div  class="lecture_mark" id="mark_48"></div><h3 >Алгоритмы планирования </h3><p  id="id_49">Существует достаточно большой набор разнообразных алгоритмов <span class="keyword">планирования</span>, которые предназначены для достижения различных целей и эффективны для разных классов задач. Многие из них могут использоваться на нескольких <span class="keyword">уровнях планирования</span>. В этом разделе мы рассмотрим некоторые наиболее употребительные алгоритмы применительно к процессу кратковременного <span class="keyword">планирования</span>.</p><div  class="lecture_mark" id="mark_49"></div><h4 >First-Come, First-Served (FCFS)</h4><p  id="id_50"><a name="keyword-context.13"></a>Простейшим алгоритмом <span class="keyword">планирования</span> является алгоритм, который принято обозначать аббревиатурой <span class="keyword_def">FCFS</span> по первым буквам его английского названия – First-Come, First-Served (первым пришел, первым обслужен). Представим себе, что процессы, находящиеся в состоянии готовность, выстроены в очередь. Когда процесс переходит в состояние готовность, он, а точнее, ссылка на его PCB помещается в конец этой очереди. Выбор нового процесса для исполнения осуществляется из начала очереди с удалением оттуда ссылки на его PCB. Очередь подобного типа имеет в программировании специальное наименование – FIFO<sup><a href="" class="objectName">1)</a></sup>, сокращение от First In, First Out (первым вошел, 

первым вышел). </p><div  class="lecture_mark" id="mark_50"></div><p  id="id_52">Такой алгоритм выбора процесса осуществляет <span class="keyword">невытесняющее планирование</span>. Процесс, получивший в свое распоряжение процессор, занимает его до истечения текущего <span class="texample"><span class="keyword">CPU burst</span></span>. После этого для выполнения выбирается новый процесс из начала очереди.</p><div  class="lecture_mark" id="mark_52"></div><div  class="xml_table_env" id="id_54"><a name="table.3.1"></a><table border="0" class="xml_table" cellpadding="2" cellspacing="1"><caption>
                    Таблица 3.1.
                    </caption><tr><th bgcolor="#d8d8d8">Процесс</th><td bgcolor="#eaeaea" valign="top">p<sub>0</sub></td><td bgcolor="#eaeaea" valign="top">p<sub>1</sub></td><td bgcolor="#eaeaea" valign="top">p<sub>2</sub></td></tr><tr><th bgcolor="#d8d8d8">Продолжительность очередного <span class="keyword">CPU burst</span></th><td bgcolor="#eaeaea" valign="top">13</td><td bgcolor="#eaeaea" valign="top">4</td><td bgcolor="#eaeaea" valign="top">1</td></tr></table></div><div  class="lecture_mark" id="mark_54"></div><p  id="id_55">Преимуществом <span class="keyword">алгоритма FCFS</span> является легкость его реализации, но в то же время он имеет и много недостатков. Рассмотрим следующий пример. Пусть в состоянии готовность находятся три процесса <span class="texample">p<sub>0</sub></span>, <span class="texample">p<sub>1</sub></span> и <span class="texample">p<sub>2</sub></span>, для которых известны времена их очередных <span class="texample"><span class="keyword">CPU burst</span></span>. Эти времена приведены в <a href="">таблице 3.1.</a> в некоторых условных единицах. Для простоты будем полагать, что вся деятельность процессов ограничивается использованием только одного промежутка <span class="texample"><span class="keyword">CPU burst</span></span>, что процессы не совершают операций ввода-вывода и что время переключения контекста так мало, что им можно пренебречь.</p><div  class="lecture_mark" id="mark_55"></div><p  id="id_61">Если процессы расположены в очереди процессов, готовых к исполнению, в порядке <span class="texample">p<sub>0</sub></span>, <span class="texample">p<sub>1</sub></span>, <span class="texample">p<sub>2</sub></span>, то картина их выполнения выглядит так, как показано на <a href="">рисунке 3.2</a>. Первым для выполнения выбирается процесс <span class="texample">p<sub>0</sub></span>, который получает процессор на все время своего <span class="texample"><span class="keyword">CPU burst</span></span>, т. е. на <span class="texample">13</span> единиц времени. После его окончания в состояние исполнение переводится процесс <span class="texample">p<sub>1</sub></span>, он занимает процессор на <span class="texample">4</span> единицы времени. И, наконец, возможность работать получает процесс <span class="texample">p<sub>2</sub></span>. Время ожидания для процесса <span class="texample">p<sub>0</sub></span> составляет <span class="texample">0</span> единиц времени, для процесса <span class="texample">p<sub>1</sub></span> – <span class="texample">13</span> единиц, для процесса <span class="texample">p<sub>2</sub></span> – <span class="texample">13 + 4 = 17</span> единиц. Таким образом, среднее время ожидания в этом случае – <span class="texample">(0 + 13 + 17)/3 = 10</span> единиц времени. Полное 

время выполнения для процесса <span class="texample">p<sub>0</sub></span> составляет <span class="texample">13</span> единиц времени, для процесса <span class="texample">p<sub>1</sub></span> – <span class="texample">13 + 4 = 17</span> единиц, для процесса <span class="texample">p<sub>2</sub></span> – <span class="texample">13 + 4 + 1 = 18</span> единиц. Среднее полное время выполнения оказывается равным <span class="texample">(13 + 17 + 18)/3 = 16</span> единицам времени.</p><div  class="lecture_mark" id="mark_61"></div><p  align="left" id="id_85"><a name="image.3.2"></a><div><img src="3. Планирование процессов_files/20000000.gif" alt="Выполнение процессов при порядке p0,p1,p2" width="339" height="148"></div><br><b>Рис. 3.2.</b> 
        Выполнение процессов при порядке p0,p1,p2</p><div  class="lecture_mark" id="mark_85"></div><p  id="id_86">Если те же самые процессы расположены в порядке <span class="texample">p<sub>2</sub></span>, <span class="texample">p<sub>1</sub></span>, <span class="texample">p<sub>0</sub></span>, то картина их выполнения будет соответствовать <a href="">рисунку 3.3</a>. Время ожидания для процесса <span class="texample">p<sub>0</sub></span> равняется <span class="texample">5</span> единицам времени, для процесса <span class="texample">p<sub>1</sub></span> – <span class="texample">1</span> единице, для процесса <span class="texample">p<sub>2</sub></span> – <span class="texample">0</span> единиц. Среднее время ожидания составит <span class="texample">(5 + 1 + 0)/3 = 2</span> единицы времени. Это в <span class="texample">5</span> (!) раз меньше, чем в предыдущем случае. Полное время выполнения для процесса <span class="texample">p<sub>0</sub></span> получается равным <span class="texample">18</span> единицам времени, для процесса <span class="texample">p<sub>1</sub></span> – <span class="texample">5</span> единицам, для процесса <span class="texample">p<sub>2</sub></span> – <span class="texample">1</span> единице. Среднее полное время выполнения составляет <span class="texample">(18 + 5 + 1)/3 = 8</span> единиц времени, что почти в <span class="texample">2</span> раза меньше, чем при первой расстановке процессов.</p><div  class="lecture_mark" id="mark_86"></div><p  align="left" id="id_106"><a name="image.3.3"></a><div><img src="3. Планирование процессов_files/30000000.gif" alt="Выполнение процессов при порядке p2, p1, p0" width="338" height="147"></div><br><b>Рис. 3.3.</b> 
        Выполнение процессов при порядке p2, p1, p0</p><div  class="lecture_mark" id="mark_106"></div><p  id="id_107">Как мы видим, среднее время ожидания и среднее полное время выполнения для этого алгоритма существенно зависят от порядка расположения процессов в очереди. Если у нас есть процесс с длительным <span class="texample"><span class="keyword">CPU burst</span></span>, то короткие процессы, перешедшие в состояние готовность после длительного процесса, будут очень долго ждать начала выполнения. Поэтому <span class="keyword">алгоритм FCFS</span> практически неприменим для систем разделения времени – слишком большим получается среднее время отклика в интерактивных процессах.</p><div  class="lecture_mark" id="mark_107"></div><h4 >Round Robin (RR)</h4><p  id="id_109"><a name="keyword-context.14"></a>Модификацией <span class="keyword">алгоритма FCFS</span> является алгоритм, получивший название Round Robin (Round Robin – это вид детской карусели в США) или сокращенно <span class="keyword_def">RR</span>. По сути дела, это тот же самый алгоритм, только реализованный в режиме <span class="keyword">вытесняющего планирования</span>. Можно представить себе все множество готовых процессов организованным циклически – процессы сидят на карусели. Карусель вращается так, что каждый процесс находится около процессора небольшой фиксированный <span class="keyword">квант времени</span>, обычно <span class="texample">10</span> – <span class="texample">100</span> миллисекунд (см. <a href="">рис. 3.4.</a>). Пока процесс находится рядом с процессором, он получает процессор в свое распоряжение и может исполняться.</p><div  class="lecture_mark" id="mark_109"></div><p  align="left" id="id_112"><a name="image.3.4"></a><div><img src="3. Планирование процессов_files/40000000.gif" alt="Процессы на карусели" width="339" height="188"></div><br><b>Рис. 3.4.</b> 
        Процессы на карусели</p><div  class="lecture_mark" id="mark_112"></div><p  id="id_113">Реализуется такой алгоритм так же, как и предыдущий, с помощью организации процессов, находящихся в состоянии готовность, в очередь FIFO. Планировщик выбирает для очередного исполнения процесс, расположенный в начале очереди, и устанавливает таймер для генерации прерывания по истечении определенного <span class="keyword">кванта времени</span>. При выполнении процесса возможны два варианта. </p><div  class="lecture_mark" id="mark_113"></div><ul  id="id_114"><li>Время непрерывного использования процессора, необходимое процессу (остаток текущего <span class="texample"><span class="keyword">CPU burst</span></span>), меньше или равно продолжительности <span class="keyword">кванта времени</span>. Тогда процесс по своей воле освобождает процессор до истечения <span class="keyword">кванта времени</span>, на исполнение поступает новый процесс из начала очереди, и таймер начинает отсчет <span class="keyword">кванта</span> заново.</li><li>Продолжительность остатка текущего <span class="texample"><span class="keyword">CPU burst</span></span> процесса больше, чем <span class="keyword">квант времени</span>. Тогда по истечении этого <span class="keyword">кванта</span> процесс прерывается таймером и помещается в конец очереди процессов, готовых к исполнению, а процессор выделяется для использования процессу, находящемуся в ее начале.</li></ul><div  class="lecture_mark" id="mark_114"></div><p  id="id_119">Рассмотрим предыдущий пример с порядком процессов <span class="texample">p<sub>0</sub></span>, <span class="texample">p<sub>1</sub></span>, <span class="texample">p<sub>2</sub></span> и величиной <span class="keyword">кванта времени</span> равной <span class="texample">4</span>. Выполнение этих процессов иллюстрируется <a href="">таблицей 3.2</a>. Обозначение <span class="texample">"И"</span> используется в ней для процесса, находящегося в состоянии исполнение, обозначение <span class="texample">"Г"</span> – для процессов в состоянии готовность, пустые ячейки соответствуют завершившимся процессам. Состояния процессов показаны на протяжении соответствующей единицы времени, т. е. колонка с номером <span class="texample">1</span> соответствует промежутку времени от <span class="texample">0</span> до <span class="texample">1</span>.</p><div  class="lecture_mark" id="mark_119"></div><div  class="xml_table_env" id="id_129"><a name="table.3.2"></a><table border="0" class="xml_table" cellpadding="2" cellspacing="1"><caption>
                    Таблица 3.2.
                    </caption><tr><th bgcolor="#d8d8d8">Время</th><td bgcolor="#eaeaea" valign="top">1</td><td bgcolor="#eaeaea" valign="top">2</td><td bgcolor="#eaeaea" valign="top">3</td><td bgcolor="#eaeaea" valign="top">4</td><td bgcolor="#eaeaea" valign="top">5</td><td bgcolor="#eaeaea" valign="top">6</td><td bgcolor="#eaeaea" valign="top">7</td><td bgcolor="#eaeaea" valign="top">8</td><td bgcolor="#eaeaea" valign="top">9</td><td bgcolor="#eaeaea" valign="top">10</td><td bgcolor="#eaeaea" valign="top">11</td><td bgcolor="#eaeaea" valign="top">12</td><td bgcolor="#eaeaea" valign="top">13</td><td bgcolor="#eaeaea" valign="top">14</td><td bgcolor="#eaeaea" valign="top">15</td><td bgcolor="#eaeaea" valign="top">16</td><td bgcolor="#eaeaea" valign="top">17</td><td bgcolor="#eaeaea" valign="top">18</td></tr><tr><th bgcolor="#d8d8d8">p<sub>0</sub></th><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td></tr><tr><th bgcolor="#d8d8d8">p<sub>1</sub></th><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td></tr><tr><th bgcolor="#d8d8d8">p<sub>2</sub></th><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td></tr></table></div><div  class="lecture_mark" id="mark_129"></div><p  id="id_130">Первым для исполнения выбирается процесс <span class="texample">p<sub>0</sub></span>. Продолжительность его <span class="texample">CPU burst</span> больше, чем величина <span class="keyword">кванта времени</span>, и поэтому процесс исполняется до истечения <span class="keyword">кванта</span>, т. е. в течение <span class="texample">4</span> единиц времени. После этого он помещается в конец очереди готовых к исполнению процессов, которая принимает вид <span class="texample">p<sub>1</sub></span>, <span class="texample">p<sub>2</sub></span>, <span class="texample">p<sub>0</sub></span>. Следующим начинает выполняться процесс <span class="texample">p<sub>1</sub></span>. Время его исполнения совпадает с величиной выделенного <span class="keyword">кванта</span>, поэтому процесс работает до своего завершения. Теперь очередь процессов в состоянии готовность состоит из двух процессов, <span class="texample">p<sub>2</sub></span> и <span class="texample">p<sub>0</sub></span>. Процессор выделяется процессу <span class="texample">p<sub>2</sub></span>. Он завершается до истечения отпущенного ему процессорного времени, и очередные <span class="keyword">кванты</span> отмеряются процессу <span class="texample">p<sub>0</sub></span> – единственному не закончившему к этому моменту свою работу. Время ожидания для процесса 
<span class="texample">p<sub>0</sub></span> (количество символов <span class="texample">"Г"</span> в соответствующей строке) составляет <span class="texample">5</span> единиц времени, для процесса <span class="texample">p<sub>1</sub></span> – <span class="texample">4</span> единицы времени, для процесса <span class="texample">p<sub>2</sub></span> – <span class="texample">8</span> единиц времени. Таким образом, среднее время ожидания для этого алгоритма получается равным <span class="texample">(5 + 4 + 8)/3 = 5,6(6)</span> единицы времени. Полное время выполнения для процесса <span class="texample">p<sub>0</sub></span> (количество непустых столбцов в соответствующей строке) составляет <span class="texample">18</span> единиц времени, для процесса <span class="texample">p<sub>1</sub></span> – <span class="texample">8</span> единиц, для процесса <span class="texample">p<sub>2</sub></span> – <span class="texample">9</span> единиц. Среднее полное время выполнения оказывается равным <span class="texample">(18 + 8 + 9)/3 = 11,6(6)</span> единицы времени. </p><div  class="lecture_mark" id="mark_130"></div><p  id="id_157">Легко увидеть, что среднее время ожидания и среднее полное время выполнения для обратного порядка процессов не отличаются от соответствующих времен для <span class="keyword">алгоритма FCFS</span> и составляют <span class="texample">2</span> и <span class="texample">8</span> единиц времени соответственно.</p><div  class="lecture_mark" id="mark_157"></div><p  id="id_160">На производительность <span class="keyword">алгоритма RR</span> сильно влияет величина <span class="keyword">кванта времени</span>. Рассмотрим тот же самый пример с порядком процессов <span class="texample">p<sub>0</sub></span>, <span class="texample">p<sub>1</sub></span>, <span class="texample">p<sub>2</sub></span> для величины <span class="keyword">кванта времени</span>, равной <span class="texample">1</span> (см. <a href="">табл. 3.3.</a>). Время ожидания для процесса <span class="texample">p<sub>0</sub></span> составит <span class="texample">5</span> единиц времени, для процесса <span class="texample">p<sub>1</sub></span> – тоже <span class="texample">5</span> единиц, для процесса <span class="texample">p<sub>2</sub></span> – <span class="texample">2</span> единицы. В этом случае среднее время ожидания получается равным <span class="texample">(5 + 5 + 2)/3 = 4</span> единицам времени. Среднее полное время исполнения составит <span class="texample">(18 + 9 + 3)/3 = 10</span> единиц времени.</p><div  class="lecture_mark" id="mark_160"></div><div  class="xml_table_env" id="id_173"><a name="table.3.3"></a><table border="0" class="xml_table" cellpadding="2" cellspacing="1"><caption>
                    Таблица 3.3.
                    </caption><tr><th bgcolor="#d8d8d8">Время</th><td bgcolor="#eaeaea" valign="top">1</td><td bgcolor="#eaeaea" valign="top">2</td><td bgcolor="#eaeaea" valign="top">3</td><td bgcolor="#eaeaea" valign="top">4</td><td bgcolor="#eaeaea" valign="top">5</td><td bgcolor="#eaeaea" valign="top">6</td><td bgcolor="#eaeaea" valign="top">7</td><td bgcolor="#eaeaea" valign="top">8</td><td bgcolor="#eaeaea" valign="top">9</td><td bgcolor="#eaeaea" valign="top">10</td><td bgcolor="#eaeaea" valign="top">11</td><td bgcolor="#eaeaea" valign="top">12</td><td bgcolor="#eaeaea" valign="top">13</td><td bgcolor="#eaeaea" valign="top">14</td><td bgcolor="#eaeaea" valign="top">15</td><td bgcolor="#eaeaea" valign="top">16</td><td bgcolor="#eaeaea" valign="top">17</td><td bgcolor="#eaeaea" valign="top">18</td></tr><tr><th bgcolor="#d8d8d8">p<sub>0</sub></th><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td></tr><tr><th bgcolor="#d8d8d8">p<sub>1</sub></th><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td></tr><tr><th bgcolor="#d8d8d8">p<sub>2</sub></th><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td></tr></table></div><div  class="lecture_mark" id="mark_173"></div><p  id="id_174">При очень больших величинах <span class="keyword">кванта времени</span>, когда каждый процесс успевает завершить свой <span class="texample">CPU burst</span> до возникновения прерывания по времени, <span class="keyword">алгоритм RR</span> вырождается в <span class="keyword">алгоритм FCFS</span>. При очень малых величинах создается иллюзия того, что каждый из <span class="texample">n</span> процессов работает на собственном виртуальном процессоре с производительностью <span class="texample">~ 1/n</span> от производительности реального процессора. Правда, это справедливо лишь при теоретическом анализе при условии пренебрежения временами переключения контекста процессов. В реальных условиях при слишком малой величине <span class="keyword">кванта времени</span> и, соответственно, слишком частом переключении контекста накладные расходы на переключение резко снижают производительность системы.</p><div  class="lecture_mark" id="mark_174"></div><h4 >Shortest-Job-First (SJF) </h4><p  id="id_178"><a name="keyword-context.15"></a>При рассмотрении алгоритмов <span class="keyword">FCFS</span> и <span class="keyword">RR</span> мы видели, насколько существенным для них является порядок расположения процессов в очереди процессов, готовых к исполнению. Если короткие задачи расположены в очереди ближе к ее началу, то общая производительность этих алгоритмов значительно возрастает. Если бы мы знали время следующих <span class="texample">CPU burst</span> для процессов, находящихся в состоянии готовность, то могли бы выбрать для исполнения не процесс из начала очереди, а процесс с минимальной длительностью <span class="texample">CPU burst</span>. Если же таких процессов два или больше, то для выбора одного из них можно использовать уже известный нам <span class="keyword">алгоритм FCFS</span>. Квантование времени при этом не применяется. Описанный алгоритм получил название "кратчайшая работа первой" или Shortest Job First (<span class="keyword_def">SJF</span>). </p><div  class="lecture_mark" id="mark_178"></div><p  id="id_181"><span class="keyword">SJF-алгоритм</span><span class="keyword"> краткосрочного планирования</span> может быть как <span class="keyword">вытесняющим</span>, так и <span class="keyword">невытесняющим</span>. При <span class="keyword">невытесняющем </span><span class="keyword">SJF</span>-<span class="keyword">планировании</span> процессор предоставляется избранному процессу на все необходимое ему время, независимо от событий, происходящих в вычислительной системе. При <span class="keyword">вытесняющем </span><span class="keyword">SJF</span>-<span class="keyword">планировании</span> учитывается появление новых процессов в очереди готовых к исполнению (из числа вновь родившихся или разблокированных) во время работы выбранного процесса. Если <span class="texample">CPU burst</span> нового процесса меньше, чем остаток <span class="texample">CPU burst</span> у исполняющегося, то исполняющийся процесс вытесняется новым.</p><div  class="lecture_mark" id="mark_181"></div><p  id="id_184">Рассмотрим пример работы <span class="keyword">невытесняющего </span><span class="keyword">алгоритма SJF</span>. Пусть в состоянии готовность находятся четыре процесса, <span class="texample">p<sub>0</sub></span>, <span class="texample">p<sub>1</sub></span>, <span class="texample">p<sub>2</sub></span> и <span class="texample">p<sub>3</sub></span>, для которых известны времена их очередных <span class="texample">CPU burst</span>. Эти времена приведены в <a href="">таблице 3.4</a>. Как и прежде, будем полагать, что вся деятельность процессов ограничивается использованием только одного промежутка <span class="texample">CPU burst</span>, что процессы не совершают операций ввода-вывода и что временем переключения контекста можно пренебречь. </p><div  class="lecture_mark" id="mark_184"></div><div  class="xml_table_env" id="id_191"><a name="table.3.4"></a><table border="0" class="xml_table" cellpadding="2" cellspacing="1"><caption>
                    Таблица 3.4.
                    </caption><tr><th bgcolor="#d8d8d8">Процесс</th><td bgcolor="#eaeaea" valign="top">p<sub>0</sub></td><td bgcolor="#eaeaea" valign="top">p<sub>1</sub></td><td bgcolor="#eaeaea" valign="top">p<sub>2</sub></td><td bgcolor="#eaeaea" valign="top">p<sub>3</sub></td></tr><tr><th bgcolor="#d8d8d8">Продолжительность очередного CPU burst</th><td bgcolor="#eaeaea" valign="top">5</td><td bgcolor="#eaeaea" valign="top">3</td><td bgcolor="#eaeaea" valign="top">7</td><td bgcolor="#eaeaea" valign="top">1</td></tr></table></div><div  class="lecture_mark" id="mark_191"></div><p  id="id_192">При использовании <span class="keyword">невытесняющего</span> <span class="keyword">алгоритма SJF</span> первым для исполнения будет выбран процесс <span class="texample">p<sub>3</sub></span>, имеющий наименьшее значение продолжительности очередного <span class="texample">CPU burst</span>. После его завершения для исполнения выбирается процесс <span class="texample">p<sub>1</sub></span>, затем <span class="texample">p<sub>0</sub></span> и, наконец, <span class="texample">p<sub>2</sub></span>. Эта картина отражена в <a href="">таблице 3.5</a>.</p><div  class="lecture_mark" id="mark_192"></div><div  class="xml_table_env" id="id_198"><a name="table.3.5"></a><table border="0" class="xml_table" cellpadding="2" cellspacing="1"><caption>
                    Таблица 3.5.
                    </caption><tr><th bgcolor="#d8d8d8">Время</th><td bgcolor="#eaeaea" valign="top">1</td><td bgcolor="#eaeaea" valign="top">2</td><td bgcolor="#eaeaea" valign="top">3</td><td bgcolor="#eaeaea" valign="top">4</td><td bgcolor="#eaeaea" valign="top">5</td><td bgcolor="#eaeaea" valign="top">6</td><td bgcolor="#eaeaea" valign="top">7</td><td bgcolor="#eaeaea" valign="top">8</td><td bgcolor="#eaeaea" valign="top">9</td><td bgcolor="#eaeaea" valign="top">10</td><td bgcolor="#eaeaea" valign="top">11</td><td bgcolor="#eaeaea" valign="top">12</td><td bgcolor="#eaeaea" valign="top">13</td><td bgcolor="#eaeaea" valign="top">14</td><td bgcolor="#eaeaea" valign="top">15</td><td bgcolor="#eaeaea" valign="top">16</td></tr><tr><th bgcolor="#d8d8d8">p<sub>0</sub></th><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td></tr><tr><th bgcolor="#d8d8d8">p<sub>1</sub></th><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td></tr><tr><th bgcolor="#d8d8d8">p<sub>2</sub></th><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td></tr><tr><th bgcolor="#d8d8d8">p<sub>3</sub></th><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td></tr></table></div><div  class="lecture_mark" id="mark_198"></div><p  id="id_199">Как мы видим, среднее время ожидания для <span class="keyword">алгоритма SJF</span> составляет <span class="texample">(4 + 1 + 9 + 0)/4 = 3,5</span> единицы времени. Легко посчитать, что для <span class="keyword">алгоритма FCFS</span> при порядке процессов <span class="texample">p<sub>0</sub></span>, <span class="texample">p<sub>1</sub></span>, <span class="texample">p<sub>2</sub></span>, <span class="texample">p<sub>3</sub></span> эта величина будет равняться <span class="texample">(0 + 5 + 8 + 15)/4 = 7</span> единицам времени, т. е. будет в два раза больше, чем для <span class="keyword">алгоритма SJF</span>. Можно показать, что для заданного набора процессов (если в очереди не появляются новые процессы) <span class="keyword">алгоритм SJF</span> является оптимальным с точки зрения минимизации среднего времени ожидания среди класса <span class="keyword">невытесняющих</span> алгоритмов.</p><div  class="lecture_mark" id="mark_199"></div><p  id="id_206">Для рассмотрения примера <span class="keyword">вытесняющего </span><span class="keyword">SJF</span><span class="keyword"> планирования</span> мы возьмем ряд процессов <span class="texample">p0</span>, <span class="texample">p1</span>, <span class="texample">p2</span> и <span class="texample">p3</span> с различными временами <span class="texample">CPU burst</span> и различными моментами их появления в очереди процессов, готовых к исполнению (см. <a href="">табл. 3.6.</a>).</p><div  class="lecture_mark" id="mark_206"></div><div  class="xml_table_env" id="id_212"><a name="table.3.6"></a><table border="0" class="xml_table" cellpadding="2" cellspacing="1"><caption>
                    Таблица 3.6.
                    </caption><tr><th bgcolor="#d8d8d8">Процесс</th><th bgcolor="#d8d8d8">Время появления в очереди очередного CPU burst</th><th bgcolor="#d8d8d8">Продолжительность</th></tr><tr><th bgcolor="#d8d8d8">p<sub>0</sub></th><td bgcolor="#eaeaea" valign="top">0</td><td bgcolor="#eaeaea" valign="top">6</td></tr><tr><th bgcolor="#d8d8d8">p<sub>1</sub></th><td bgcolor="#eaeaea" valign="top">2</td><td bgcolor="#eaeaea" valign="top">2</td></tr><tr><th bgcolor="#d8d8d8">p<sub>2</sub></th><td bgcolor="#eaeaea" valign="top">6</td><td bgcolor="#eaeaea" valign="top">7</td></tr><tr><th bgcolor="#d8d8d8">p<sub>3</sub></th><td bgcolor="#eaeaea" valign="top">0</td><td bgcolor="#eaeaea" valign="top">5</td></tr></table></div><div  class="lecture_mark" id="mark_212"></div><p  id="id_213">В начальный момент времени в состоянии готовность находятся только два процесса, <span class="texample">p<sub>0</sub></span> и <span class="texample">p<sub>3</sub></span>. Меньшее время очередного <span class="texample">CPU burst</span> оказывается у процесса <span class="texample">p<sub>3</sub></span>, поэтому он и выбирается для исполнения (см. <a href="">таблицу 3.7.</a>). По прошествии <span class="texample">2</span> единиц времени в систему поступает процесс <span class="texample">p<sub>1</sub></span>. Время его <span class="texample">CPU burst</span> меньше, чем остаток <span class="texample">CPU burst</span> у процесса <span class="texample">p<sub>3</sub></span>, который вытесняется из состояния исполнение и переводится в состояние готовность. По прошествии еще <span class="texample">2</span> единиц времени процесс <span class="texample">p<sub>1</sub></span> завершается, и для исполнения вновь выбирается процесс <span class="texample">p<sub>3</sub></span>. В момент времени <span class="texample">t = 6</span> в очереди процессов, готовых к исполнению, появляется процесс <span class="texample">p<sub>2</sub></span>, но поскольку ему для работы нужно <span class="texample">7</span> единиц времени, а процессу <span class="texample">p<sub>3</sub></span>

осталось трудиться всего <span class="texample">1</span> единицу времени, то процесс <span class="texample">p<sub>3</sub></span> остается в состоянии исполнение. После его завершения в момент времени <span class="texample">t = 7</span> в очереди находятся процессы <span class="texample">p<sub>0</sub></span> и <span class="texample">p<sub>2</sub></span>, из которых выбирается процесс <span class="texample">p<sub>0</sub></span>. Наконец, последним получит возможность выполняться процесс <span class="texample">p<sub>2</sub></span>.</p><div  class="lecture_mark" id="mark_213"></div><div  class="xml_table_env" id="id_237"><a name="table.3.7"></a><table border="0" class="xml_table" cellpadding="2" cellspacing="1"><caption>
                    Таблица 3.7.
                    </caption><tr><th bgcolor="#d8d8d8">Время</th><td bgcolor="#eaeaea" valign="top">1</td><td bgcolor="#eaeaea" valign="top">2</td><td bgcolor="#eaeaea" valign="top">3</td><td bgcolor="#eaeaea" valign="top">4</td><td bgcolor="#eaeaea" valign="top">5</td><td bgcolor="#eaeaea" valign="top">6</td><td bgcolor="#eaeaea" valign="top">7</td><td bgcolor="#eaeaea" valign="top">8</td><td bgcolor="#eaeaea" valign="top">9</td><td bgcolor="#eaeaea" valign="top">10</td><td bgcolor="#eaeaea" valign="top">11</td><td bgcolor="#eaeaea" valign="top">12</td><td bgcolor="#eaeaea" valign="top">13</td><td bgcolor="#eaeaea" valign="top">14</td><td bgcolor="#eaeaea" valign="top">15</td><td bgcolor="#eaeaea" valign="top">16</td><td bgcolor="#eaeaea" valign="top">17</td><td bgcolor="#eaeaea" valign="top">18</td><td bgcolor="#eaeaea" valign="top">19</td><td bgcolor="#eaeaea" valign="top">20</td></tr><tr><th bgcolor="#d8d8d8">p<sub>0</sub></th><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td></tr><tr><th bgcolor="#d8d8d8">p<sub>1</sub></th><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td></tr><tr><th bgcolor="#d8d8d8">p<sub>2</sub></th><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td></tr><tr><th bgcolor="#d8d8d8">p<sub>3</sub></th><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td></tr></table></div><div  class="lecture_mark" id="mark_237"></div><p  id="id_238">Основную сложность при реализации <span class="keyword">алгоритма SJF</span> представляет невозможность точного знания продолжительности очередного <span class="texample">CPU burst</span> для исполняющихся процессов. В пакетных системах количество процессорного времени, необходимое заданию для выполнения, указывает пользователь при формировании задания. Мы можем брать эту величину для осуществления <span class="keyword">долгосрочного </span><span class="keyword">SJF</span>-<span class="keyword">планирования</span>. Если пользователь укажет больше времени, чем ему нужно, он будет ждать результата дольше, чем мог бы, так как задание будет загружено в систему позже. Если же он укажет меньшее количество времени, задача может не досчитаться до конца. Таким образом, в пакетных системах решение задачи оценки времени использования процессора перекладывается на плечи пользователя. При <span class="keyword">краткосрочном планировании</span> мы можем делать только прогноз длительности следующего <span class="texample">CPU burst</span>, исходя из предыстории работы процесса. Пусть <span class="texample">&#964;(n)</span> – величина <span class="texample">n</span>-го <span class="texample">CPU burst</span>, <span class="texample">T(n + 1)</span> – предсказываемое значение для <span class="texample">n + 1</span>-го <span class="texample">CPU burst</span>, <span class="texample"><img src="3. Планирование процессов_files/alpha000.gif" width="8" height="18" border="0" alt="" style="position: relative; top: 2px"></span> – некоторая величина в диапазоне от <span class="texample">0</span> до <span class="texample">1</span>.</p><div  class="lecture_mark" id="mark_238"></div><p  id="id_250">Определим рекуррентное соотношение</p><div  class="lecture_mark" id="mark_250"></div><div  class="example"><pre>
T(n+1)= <img src="3. Планирование процессов_files/alpha000.gif" width="8" height="18" border="0" alt="" style="position: relative; top: 2px">&#964;(n)+(1-<img src="3. Планирование процессов_files/alpha000.gif" width="8" height="18" border="0" alt="" style="position: relative; top: 2px">)T(n)
</pre></div><p  id="id_252"><span class="texample">T(0)</span> положим произвольной константой. Первое слагаемое учитывает последнее поведение процесса, тогда как второе слагаемое учитывает его предысторию. При <span class="texample"><img src="3. Планирование процессов_files/alpha000.gif" width="8" height="18" border="0" alt="" style="position: relative; top: 2px"> = 0</span> мы перестаем следить за последним поведением процесса, фактически полагая</p><div  class="lecture_mark" id="mark_252"></div><div  class="example"><pre>
T(n)= T(n+1)=...=T(0)
</pre></div><p  id="id_256">т. е. оценивая все <span class="texample">CPU burst</span> одинаково, исходя из некоторого начального предположения.</p><div  class="lecture_mark" id="mark_256"></div><p  id="id_258">Положив <span class="texample"><img src="3. Планирование процессов_files/alpha000.gif" width="8" height="18" border="0" alt="" style="position: relative; top: 2px"> = 1</span>, мы забываем о предыстории процесса. В этом случае мы полагаем, что время очередного <span class="texample">CPU burst</span> будет совпадать со временем последнего <span class="texample">CPU burst</span>:</p><div  class="lecture_mark" id="mark_258"></div><div  class="example"><pre>
T(n+1)= &#964;(n)
</pre></div><p  id="id_263">Обычно выбирают <span class="texample"><img src="3. Планирование процессов_files/alpha000.gif" width="8" height="18" border="0" alt="" style="position: relative; top: 2px"> = 1/2</span> для равноценного учета последнего поведения и предыстории. Надо отметить, что такой выбор <span class="texample"><img src="3. Планирование процессов_files/alpha000.gif" width="8" height="18" border="0" alt="" style="position: relative; top: 2px"></span> удобен и для быстрой организации вычисления оценки <span class="texample">T(n + 1)</span>. Для подсчета новой оценки нужно взять старую оценку, сложить с измеренным временем <span class="texample">CPU burst</span> и полученную сумму разделить на <span class="texample">2</span>, например, сдвинув ее на <span class="texample">1</span> бит вправо. Полученные оценки <span class="texample">T(n + 1)</span> применяются как продолжительности очередных промежутков времени непрерывного использования процессора для <span class="keyword">краткосрочного </span><span class="keyword">SJF</span>-<span class="keyword">планирования</span>.</p><div  class="lecture_mark" id="mark_263"></div><h4 >Гарантированное планирование </h4><p  id="id_271">При интерактивной работе <span class="texample">N</span> пользователей в вычислительной системе можно применить алгоритм <span class="keyword">планирования</span>, который гарантирует, что каждый из пользователей будет иметь в своем распоряжении <span class="texample">~1/N</span> часть процессорного времени. Пронумеруем всех пользователей от <span class="texample">1</span> до <span class="texample">N</span>. Для каждого пользователя с номером <span class="texample">i</span> введем две величины: <span class="texample">T<sub>i</sub></span> – время нахождения пользователя в системе или, другими словами, длительность сеанса его общения с машиной и <span class="texample">&#964;<sub>i</sub></span> – суммарное процессорное время уже выделенное всем его процессам в течение сеанса. Справедливым для пользователя было бы получение <span class="texample">T<sub>i</sub>/N</span> процессорного времени. Если</p><div  class="lecture_mark" id="mark_271"></div><div  class="example"><pre>
&#964;<sub>i</sub>&lt;&lt;T<sub>i</sub>/N  
</pre></div><p  id="id_281">то <span class="texample">i</span>-й пользователь несправедливо обделен процессорным временем. Если же </p><div  class="lecture_mark" id="mark_281"></div><div  class="example"><pre>
&#964;<sub>i</sub>&gt;&gt;T<sub>i</sub>/N 
</pre></div><p  id="id_284">то система явно благоволит к пользователю с номером <span class="texample">i</span>. Вычислим для процессов каждого пользователя значение коэффициента справедливости</p><div  class="lecture_mark" id="mark_284"></div><div  class="example"><pre>
&#964;<sub>i</sub>N/T<sub>i</sub> 
</pre></div><p  id="id_287">и будем предоставлять очередной <span class="keyword">квант времени</span> готовому процессу с наименьшей величиной этого отношения. Предложенный алгоритм называют алгоритмом <span class="keyword">гарантированного планирования</span>. К недостаткам этого алгоритма можно отнести невозможность предугадать поведение пользователей. Если некоторый пользователь отправится на пару часов пообедать и поспать, не прерывая сеанса работы, то по возвращении его процессы будут получать неоправданно много процессорного времени.</p><div  class="lecture_mark" id="mark_287"></div><h4 >Приоритетное планирование </h4><p  id="id_288"><span class="keyword">Алгоритмы SJF</span> и <span class="keyword">гарантированного планирования</span> представляют собой частные случаи <span class="keyword">приоритетного планирования</span>. <a name="keyword-context.16"></a><a name="keyword-context.17"></a>При <span class="keyword_def">приоритетном планировании</span> каждому процессу присваивается определенное числовое значение – <span class="keyword">приоритет</span>, в соответствии с которым ему выделяется процессор. Процессы с одинаковыми <span class="keyword">приоритетами</span> планируются в порядке <span class="keyword">FCFS</span>. Для <span class="keyword">алгоритма SJF</span> в качестве такого <span class="keyword">приоритета выступает</span> оценка продолжительности следующего <span class="texample">CPU burst</span>. Чем меньше значение этой оценки, тем более высокий <span class="keyword">приоритет</span> имеет процесс. Для алгоритма <span class="keyword">гарантированного планирования </span><span class="keyword">приоритетом</span> служит вычисленный коэффициент справедливости. Чем он меньше, тем больше у процесса <span class="keyword_def">приоритет</span>.</p><div  class="lecture_mark" id="mark_288"></div><p  id="id_290">Алгоритмы назначения <span class="keyword">приоритетов</span> процессов могут опираться как на внутренние параметры, связанные с происходящим внутри вычислительной системы, так и на внешние по отношению к ней. К внутренним параметрам относятся различные количественные и качественные характеристики процесса такие как: ограничения по времени использования процессора, требования к размеру памяти, число открытых файлов и используемых устройств ввода-вывода, отношение средних продолжительностей <span class="keyword">I/O burst</span> к <span class="texample">CPU burst</span> и т. д. Алгоритмы SJF и гарантированного планирования используют внутренние параметры. В качестве внешних параметров могут выступать важность процесса для достижения каких-либо целей, стоимость оплаченного процессорного времени и другие политические факторы. Высокий внешний <span class="keyword">приоритет</span> может быть присвоен задаче лектора или того, кто заплатил $100 за работу в течение одного часа.</p><div  class="lecture_mark" id="mark_290"></div><p  id="id_292"><span class="keyword">Планирование</span> с использованием <span class="keyword">приоритетов</span> может быть как <span class="keyword">вытесняющим</span>, так и <span class="keyword">невытесняющим</span>. При <span class="keyword">вытесняющем планировании</span> процесс с более высоким <span class="keyword">приоритетом</span>, появившийся в очереди готовых процессов, вытесняет исполняющийся процесс с более низким <span class="keyword">приоритетом</span>. В случае <span class="keyword">невытесняющего планирования</span> он просто становится в начало очереди готовых процессов. Давайте рассмотрим примеры использования различных режимов <span class="keyword">приоритетного</span><span class="keyword"> планирования</span>.</p><div  class="lecture_mark" id="mark_292"></div><p  id="id_293">Пусть в очередь процессов, находящихся в состоянии готовность, поступают те же процессы, что и в примере для <span class="keyword">вытесняющего </span><span class="keyword">алгоритма SJF</span>, только им дополнительно еще присвоены <span class="keyword">приоритеты</span> (см. <a href="">табл. 3.8.</a>). В вычислительных системах не существует определенного соглашения, какое значение <span class="keyword">приоритета</span> – <span class="texample">1</span> или <span class="texample">4</span> считать более <span class="keyword">приоритетным</span>. Во избежание путаницы, во всех наших примерах мы будем предполагать, что большее значение соответствует меньшему <span class="keyword">приоритету</span>, т. е. наиболее <span class="keyword">приоритетным</span> в нашем примере является процесс <span class="texample">p<sub>3</sub></span>, а наименее <span class="keyword">приоритетным</span> – процесс <span class="texample">p<sub>0</sub></span>.</p><div  class="lecture_mark" id="mark_293"></div><div  class="xml_table_env" id="id_298"><a name="table.3.8"></a><table border="0" class="xml_table" cellpadding="2" cellspacing="1"><caption>
                    Таблица 3.8.
                    </caption><tr><th bgcolor="#d8d8d8">Процесс</th><th bgcolor="#d8d8d8">Время появления в очереди</th><th bgcolor="#d8d8d8">Продолжительность очередного CPU burst</th><th bgcolor="#d8d8d8"><span class="keyword">Приоритет</span></th></tr><tr><th bgcolor="#d8d8d8">p<sub>0</sub></th><td bgcolor="#eaeaea" valign="top">0</td><td bgcolor="#eaeaea" valign="top">6</td><td bgcolor="#eaeaea" valign="top">4</td></tr><tr><th bgcolor="#d8d8d8">p<sub>1</sub></th><td bgcolor="#eaeaea" valign="top">2</td><td bgcolor="#eaeaea" valign="top">2</td><td bgcolor="#eaeaea" valign="top">3</td></tr><tr><th bgcolor="#d8d8d8">p<sub>2</sub></th><td bgcolor="#eaeaea" valign="top">6</td><td bgcolor="#eaeaea" valign="top">7</td><td bgcolor="#eaeaea" valign="top">2</td></tr><tr><th bgcolor="#d8d8d8">p<sub>3</sub></th><td bgcolor="#eaeaea" valign="top">0</td><td bgcolor="#eaeaea" valign="top">5</td><td bgcolor="#eaeaea" valign="top">1</td></tr></table></div><div  class="lecture_mark" id="mark_298"></div><p  id="id_299">Как будут вести себя процессы при использовании <span class="keyword">невытесняющего </span><span class="keyword">приоритетного планирования</span>? Первым для выполнения в момент времени <span class="texample">t = 0</span> выбирается процесс <span class="texample">p<sub>3</sub></span>, как обладающий наивысшим <span class="keyword">приоритетом</span>. После его завершения в момент времени <span class="texample">t = 5</span> в очереди процессов, готовых к исполнению, окажутся два процесса <span class="texample">p<sub>0</sub></span> и <span class="texample">p<sub>1</sub></span>. Больший <span class="keyword">приоритет</span> из них у процесса <span class="texample">p<sub>1</sub></span>, он и начнет выполняться (см. <a href="">табл. 3.9.</a>). Затем в момент времени <span class="texample">t = 8</span> для исполнения будет избран процесс <span class="texample">p<sub>2</sub></span>, и лишь потом – процесс <span class="texample">p<sub>0</sub></span>.</p><div  class="lecture_mark" id="mark_299"></div><div  class="xml_table_env" id="id_309"><a name="table.3.9"></a><table border="0" class="xml_table" cellpadding="2" cellspacing="1"><caption>
                    Таблица 3.9.
                    </caption><tr><th bgcolor="#d8d8d8">Время</th><td bgcolor="#eaeaea" valign="top">1</td><td bgcolor="#eaeaea" valign="top">2</td><td bgcolor="#eaeaea" valign="top">3</td><td bgcolor="#eaeaea" valign="top">4</td><td bgcolor="#eaeaea" valign="top">5</td><td bgcolor="#eaeaea" valign="top">6</td><td bgcolor="#eaeaea" valign="top">7</td><td bgcolor="#eaeaea" valign="top">8</td><td bgcolor="#eaeaea" valign="top">9</td><td bgcolor="#eaeaea" valign="top">10</td><td bgcolor="#eaeaea" valign="top">11</td><td bgcolor="#eaeaea" valign="top">12</td><td bgcolor="#eaeaea" valign="top">13</td><td bgcolor="#eaeaea" valign="top">14</td><td bgcolor="#eaeaea" valign="top">15</td><td bgcolor="#eaeaea" valign="top">16</td><td bgcolor="#eaeaea" valign="top">17</td><td bgcolor="#eaeaea" valign="top">18</td><td bgcolor="#eaeaea" valign="top">19</td><td bgcolor="#eaeaea" valign="top">20</td></tr><tr><th bgcolor="#d8d8d8">p<sub>0</sub></th><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td></tr><tr><th bgcolor="#d8d8d8">p<sub>1</sub></th><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td></tr><tr><th bgcolor="#d8d8d8">p<sub>2</sub></th><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td></tr><tr><th bgcolor="#d8d8d8">p<sub>3</sub></th><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td></tr></table></div><div  class="lecture_mark" id="mark_309"></div><p  id="id_310">Иным будет предоставление процессора процессам в случае <span class="keyword">вытесняющего </span><span class="keyword">приоритетного планирования</span> (см. <a href="">табл. 3.10.</a>). Первым, как и в предыдущем случае, начнет исполняться процесс <span class="texample">p<sub>3</sub></span>, а по его окончании – процесс <span class="texample">p<sub>1</sub></span>. Однако в момент времени <span class="texample">t = 6</span> он будет вытеснен процессом <span class="texample">p<sub>2</sub></span> и продолжит свое выполнение только в момент времени <span class="texample">t = 13</span>. Последним, как и раньше, будет исполняться процесс <span class="texample">p<sub>0</sub></span>.</p><div  class="lecture_mark" id="mark_310"></div><div  class="xml_table_env" id="id_317"><a name="table.3.10"></a><table border="0" class="xml_table" cellpadding="2" cellspacing="1"><caption>
                    Таблица 3.10.
                    </caption><tr><th bgcolor="#d8d8d8">Время</th><td bgcolor="#eaeaea" valign="top">1</td><td bgcolor="#eaeaea" valign="top">2</td><td bgcolor="#eaeaea" valign="top">3</td><td bgcolor="#eaeaea" valign="top">4</td><td bgcolor="#eaeaea" valign="top">5</td><td bgcolor="#eaeaea" valign="top">6</td><td bgcolor="#eaeaea" valign="top">7</td><td bgcolor="#eaeaea" valign="top">8</td><td bgcolor="#eaeaea" valign="top">9</td><td bgcolor="#eaeaea" valign="top">10</td><td bgcolor="#eaeaea" valign="top">11</td><td bgcolor="#eaeaea" valign="top">12</td><td bgcolor="#eaeaea" valign="top">13</td><td bgcolor="#eaeaea" valign="top">14</td><td bgcolor="#eaeaea" valign="top">15</td><td bgcolor="#eaeaea" valign="top">16</td><td bgcolor="#eaeaea" valign="top">17</td><td bgcolor="#eaeaea" valign="top">18</td><td bgcolor="#eaeaea" valign="top">19</td><td bgcolor="#eaeaea" valign="top">20</td></tr><tr><th bgcolor="#d8d8d8">p<sub>0</sub></th><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td></tr><tr><th bgcolor="#d8d8d8">p<sub>1</sub></th><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">Г</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td></tr><tr><th bgcolor="#d8d8d8">p<sub>2</sub></th><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td></tr><tr><th bgcolor="#d8d8d8">p<sub>3</sub></th><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top">И</td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td><td bgcolor="#eaeaea" valign="top"></td></tr></table></div><div  class="lecture_mark" id="mark_317"></div><p  id="id_318">В рассмотренном выше примере <span class="keyword">приоритеты</span> процессов с течением времени не изменялись. Такие <span class="keyword">приоритеты</span> принято называть статическими. Механизмы статической <span class="keyword">приоритетности</span> легко реализовать, и они сопряжены с относительно небольшими издержками на выбор наиболее <span class="keyword">приоритетного</span> процесса. Однако статические <span class="keyword">приоритеты</span> не реагируют на изменения ситуации в вычислительной системе, которые могут сделать желательной корректировку порядка исполнения процессов. Более гибкими являются динамические <span class="keyword">приоритеты процессов</span>, изменяющие свои значения по ходу исполнения процессов. Начальное значение динамического <span class="keyword">приоритета</span>, присвоенное процессу, действует в течение лишь короткого периода времени, после чего ему назначается новое, более подходящее значение. Изменение динамического <span class="keyword">приоритета процесса</span> является единственной операцией над процессами, которую мы до сих пор не рассмотрели. Как правило, изменение <span class="keyword">приоритета процессов</span> проводится согласованно с совершением каких-либо других операций: при рождении нового процесса, при 
разблокировке или блокировании процесса, по истечении определенного <span class="keyword">кванта времени</span> или по завершении процесса. Примерами алгоритмов с динамическими <span class="keyword">приоритетами</span> являются <span class="keyword">алгоритм SJF</span> и алгоритм <span class="keyword">гарантированного планирования</span>. Схемы с динамической приоритетностью гораздо сложнее в реализации и связаны с большими издержками по сравнению со статическими схемами. Однако их использование предполагает, что эти издержки оправдываются улучшением работы системы.</p><div  class="lecture_mark" id="mark_318"></div><p  id="id_319">Главная проблема <span class="keyword">приоритетного планирования</span> заключается в том, что при ненадлежащем выборе механизма назначения и изменения <span class="keyword">приоритетов</span> низкоприоритетные процессы могут не запускаться неопределенно долгое время. Обычно случается одно из двух. Или они все же дожидаются своей очереди на исполнение (в девять часов утра в воскресенье, когда все приличные программисты ложатся спать). Или вычислительную систему приходится выключать, и они теряются (при остановке IBM 7094 в Массачусетском технологическом институте в 1973 году были найдены процессы, запущенные в 1967 году и ни разу с тех пор не исполнявшиеся). Решение этой проблемы может быть достигнуто с помощью увеличения со временем значения <span class="keyword">приоритета процесса</span>, находящегося в состоянии готовность. Пусть изначально процессам присваиваются <span class="keyword">приоритеты</span> от <span class="texample">128</span> до <span class="texample">255</span>. Каждый раз по истечении определенного промежутка времени значения <span class="keyword">приоритетов</span> готовых процессов уменьшаются на <span class="texample">1</span>. Процессу, побывавшему в состоянии исполнение,
 присваивается первоначальное значение <span class="keyword">приоритета</span>. Даже такая грубая схема гарантирует, что любому процессу в разумные сроки будет предоставлено право на исполнение.</p><div  class="lecture_mark" id="mark_319"></div><h4 >Многоуровневые очереди (Multilevel Queue) </h4><p  id="id_323"><a name="keyword-context.18"></a>Для систем, в которых процессы могут быть легко рассортированы по разным группам, был разработан другой класс алгоритмов <span class="keyword">планирования</span>. Для каждой группы процессов создается своя очередь процессов, находящихся в состоянии готовность (см. <a href="">рис. 3.5</a>). Этим очередям приписываются фиксированные <span class="keyword">приоритеты</span>. Например, <span class="keyword">приоритет</span> очереди системных процессов устанавливается выше, чем <span class="keyword">приоритет</span> очередей пользовательских процессов. А <span class="keyword">приоритет</span> очереди процессов, запущенных студентами, ниже, чем для очереди процессов, запущенных преподавателями. Это значит, что ни один пользовательский процесс не будет выбран для исполнения, пока есть хоть один готовый системный процесс, и ни один студенческий процесс не получит в свое распоряжение процессор, если есть процессы преподавателей, готовые к исполнению. Внутри этих очередей для <span class="keyword">планирования</span> могут применяться самые разные алгоритмы.<span class="keyword"></span> Так, например, для больших счетных процессов, не требующих взаимодействия с пользователем (фоновых процессов), 
может использоваться <span class="keyword">алгоритм FCFS</span>, а для интерактивных процессов – <span class="keyword">алгоритм RR</span>. Подобный подход, получивший название <span class="keyword_def">многоуровневых очередей</span>, повышает гибкость <span class="keyword">планирования</span>: для процессов с различными характеристиками применяется наиболее подходящий им алгоритм.</p><div  class="lecture_mark" id="mark_323"></div><p  align="left" id="id_324"><a name="image.3.5"></a><div><img src="3. Планирование процессов_files/50000000.gif" alt="Несколько очередей планирования" width="284" height="229"></div><br><b>Рис. 3.5.</b> 
        Несколько очередей планирования</p><div  class="lecture_mark" id="mark_324"></div><h4 >Многоуровневые очереди с обратной связью (Multilevel Feedback Queue) </h4><p  id="id_325">Дальнейшим развитием алгоритма <span class="keyword">многоуровневых очередей</span> является добавление к нему механизма обратной связи. Здесь процесс не постоянно приписан к определенной очереди, а может мигрировать из одной очереди в другую в зависимости от своего поведения. </p><div  class="lecture_mark" id="mark_325"></div><p  id="id_326">Для простоты рассмотрим ситуацию, когда процессы в состоянии готовность организованы в <span class="texample">4</span> очереди, как на <a href="">рисунке 3.6</a>. <span class="keyword">Планирование процессов</span> между очередями осуществляется на основе <span class="keyword">вытесняющего</span> приоритетного механизма. Чем выше на рисунке располагается очередь, тем выше ее <span class="keyword">приоритет</span>. Процессы в очереди <span class="texample">1</span> не могут исполняться, если в очереди <span class="texample">0</span> есть хотя бы один процесс. Процессы в очереди <span class="texample">2</span> не будут выбраны для выполнения, пока есть хоть один процесс в очередях <span class="texample">0</span> и <span class="texample">1</span>. И наконец, процесс в очереди <span class="texample">3</span> может получить процессор в свое распоряжение только тогда, когда очереди <span class="texample">0</span>, <span class="texample">1</span> и <span class="texample">2</span> пусты. Если при работе процесса появляется другой процесс в какой-либо более <span class="keyword">приоритетной</span> очереди, исполняющийся процесс вытесняется новым. <span class="keyword">Планирование процессов</span> внутри очередей <span class="texample">0</span>–<span class="texample">2</span> осуществляется с использованием <span class="keyword">алгоритма RR</span>, <span class="keyword">планирование</span> 
процессов в очереди <span class="texample">3</span> основывается на <span class="keyword">алгоритме FCFS</span>.</p><div  class="lecture_mark" id="mark_326"></div><p  align="left" id="id_340"><a name="image.3.6"></a><div><img src="3. Планирование процессов_files/60000000.gif" alt="Схема миграции процессов в многоуровневых очередях планирования  с обратной связью. Вытеснение процессов более приоритетными процессами  и завершение процессов на схеме не показано" width="420" height="417"></div><br><b>Рис. 3.6.</b> 
        Схема миграции процессов в многоуровневых очередях планирования  с обратной связью. Вытеснение процессов более приоритетными процессами  и завершение процессов на схеме не показано</p><div  class="lecture_mark" id="mark_340"></div><p  id="id_341">Родившийся процесс поступает в очередь <span class="texample">0</span>. При выборе на исполнение он получает в свое распоряжение <span class="keyword">квант времени</span> размером <span class="texample">8</span> единиц. Если продолжительность его <span class="texample">CPU burst</span> меньше этого <span class="keyword">кванта времени</span>, процесс остается в очереди <span class="texample">0</span>. В противном случае он переходит в очередь <span class="texample">1</span>. Для процессов из очереди <span class="texample">1 </span><span class="keyword">квант времени</span> имеет величину <span class="texample">16</span>. Если процесс не укладывается в это время, он переходит в очередь <span class="texample">2</span>. Если укладывается – остается в очереди <span class="texample">1</span>. В очереди <span class="texample">2</span> величина <span class="keyword">кванта времени</span> составляет <span class="texample">32</span> единицы. Если для непрерывной работы процесса и этого мало, процесс поступает в очередь <span class="texample">3</span>, для которой квантование времени не применяется и, при отсутствии готовых процессов в других очередях, может исполняться до окончания своего <span class="texample">CPU burst</span>. Чем больше значение продолжительности <span class="texample">CPU burst</span>, тем в менее <span class="keyword">приоритетную</span> очередь попадает процесс, но
 тем на большее процессорное время он может рассчитывать. Таким образом, через некоторое время все процессы, требующие малого времени работы процессора, окажутся размещенными в высокоприоритетных очередях, а все процессы, требующие большого счета и с низкими запросами к времени отклика, – в низкоприоритетных.</p><div  class="lecture_mark" id="mark_341"></div><p  id="id_356">Миграция процессов в обратном направлении может осуществляться по различным принципам. Например, после завершения ожидания ввода с клавиатуры процессы из очередей <span class="texample">1</span>, <span class="texample">2</span> и <span class="texample">3</span> могут помещаться в очередь <span class="texample">0</span>, после завершения дисковых операций ввода-вывода процессы из очередей <span class="texample">2</span> и <span class="texample">3</span> могут помещаться в очередь <span class="texample">1</span>, а после завершения ожидания всех других событий – из очереди <span class="texample">3</span> в очередь <span class="texample">2</span>. Перемещение процессов из очередей с низкими <span class="keyword">приоритетами</span> в очереди с высокими <span class="keyword">приоритетами</span> позволяет более полно учитывать изменение поведения процессов с течением времени.</p><div  class="lecture_mark" id="mark_356"></div><p  id="id_366"><span class="keyword">Многоуровневые очереди с обратной связью</span> представляют собой наиболее общий подход к <span class="keyword">планированию процессов</span> из числа подходов, рассмотренных нами. Они наиболее трудны в реализации, но в то же время обладают наибольшей гибкостью. Понятно, что существует много других разновидностей такого способа <span class="keyword">планирования</span>, помимо варианта, приведенного выше. Для полного описания их конкретного воплощения необходимо указать:</p><div  class="lecture_mark" id="mark_366"></div><ul  id="id_367"><li>Количество очередей для процессов, находящихся в состоянии готовность.</li><li>Алгоритм <span class="keyword">планирования</span>, действующий между очередями.</li><li>Алгоритмы <span class="keyword">планирования</span>, действующие внутри очередей.</li><li>Правила помещения родившегося процесса в одну из очередей.</li><li>Правила перевода процессов из одной очереди в другую.</li></ul><div  class="lecture_mark" id="mark_367"></div><p  id="id_373">Изменяя какой-либо из перечисленных пунктов, мы можем существенно менять поведение вычислительной системы.</p><div  class="lecture_mark" id="mark_373"></div><p  id="id_374">На этом мы прекращаем рассмотрение различных алгоритмов <span class="keyword">планирования процессов</span>, ибо, как было сказано: "Нельзя объять необъятное".</p><div  class="lecture_mark" id="mark_374"></div><h3 >Заключение</h3><p  id="id_375">Одним из наиболее ограниченных ресурсов вычислительной системы является процессорное время. Для его распределения между многочисленными процессами в системе приходится применять процедуру <span class="keyword">планирования процессов</span>. По степени длительности влияния <span class="keyword">планирования</span> на поведение вычислительной системы различают <span class="keyword">краткосрочное</span>, <span class="keyword">среднесрочное</span> и <span class="keyword">долгосрочное планирование</span> процессов. Конкретные алгоритмы <span class="keyword">планирования процессов</span> зависят от поставленных целей, класса решаемых задач и опираются на статические и динамические <span class="keyword">параметры</span> процессов и компьютерных систем. Различают <span class="keyword">вытесняющий</span> и <span class="keyword">невытесняющий</span> режимы <span class="keyword">планирования</span>. При <span class="keyword">невытесняющем планировании</span> исполняющийся процесс уступает процессор другому процессу только по собственному желанию, при <span class="keyword">вытесняющем планировании</span> исполняющийся процесс может быть вытеснен из состояния исполнения помимо своей воли.</p><div  class="lecture_mark" id="mark_375"></div><p  id="id_376">Простейшим алгоритмом <span class="keyword">планирования</span> является <span class="keyword">невытесняющий </span><span class="keyword">алгоритм FCFS</span>, который, однако, может существенно задерживать короткие процессы, не вовремя перешедшие в состояние готовность. В системах разделения времени широкое распространение получила <span class="keyword">вытесняющая</span> версия этого алгоритма – <span class="keyword">RR</span>. </p><div  class="lecture_mark" id="mark_376"></div><p  id="id_377">Среди всех <span class="keyword">невытесняющих</span> алгоритмов оптимальным с точки зрения среднего времени ожидания процессов является <span class="keyword">алгоритм SJF</span>. Существует и <span class="keyword">вытесняющий</span> вариант этого алгоритма. В интерактивных системах часто используется алгоритм <span class="keyword">гарантированного планирования</span>, обеспечивающий пользователям равные части процессорного времени. </p><div  class="lecture_mark" id="mark_377"></div><p  id="id_378"><span class="keyword">Алгоритм SJF</span> и алгоритм <span class="keyword">гарантированного планирования</span> являются частными случаями <span class="keyword">планирования</span> с использованием <span class="keyword">приоритетов</span>. В более общих методах <span class="keyword">приоритетного планирования</span> применяются <span class="keyword">многоуровневые очереди</span> процессов, готовых к исполнению, и <span class="keyword">многоуровневые очереди с обратной связью</span>. Будучи наиболее сложными в реализации, эти способы <span class="keyword">планирования</span> обеспечивают гибкое поведение вычислительных систем и их адаптивность к решению задач разных классов.</p><div  class="lecture_mark" id="mark_378"></div><table  border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td height="4"><img src="3. Планирование процессов_files/empty000.gif" width="1" height="4"></td></tr><tr><td class="orang"><img src="3. Планирование процессов_files/empty000.gif" width="1" height="1" border="0"></td></tr><tr><td height="8"><img src="3. Планирование процессов_files/empty000.gif" width="1" height="8"></td></tr></table>


         
        <a  name="footnote.1"></a><span  class="objectName"><sup>1)</sup></span>
         
        Надо отметить, что аббревиатура <span  class="keyword">FCFS</span> используется для этого алгоритма <span  class="keyword">планирования</span> вместо стандартной аббревиатуры FIFO для механизмов подобного типа для того, чтобы подчеркнуть, что организация готовых процессов в очередь FIFO возможна и при других алгоритмах <span  class="keyword">планирования</span> (например, для Round Robin – см. раздел "Round Robin (<span  class="keyword">RR</span>)").


	</td>
	</tr>
	<tr><td height="8"><img src="3. Планирование процессов_files/empty000.gif" width="1" height="8"></td></tr>
	</table>
	<!-- /content -->

</td>
<td><img src="3. Планирование процессов_files/empty000.gif" width="8" height="1"></td>
</tr>
</table>
<!-- /bottom -->
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td class="orang" height="1"><img src="3. Планирование процессов_files/empty000.gif" width="1" height="1"></td></tr>
<td class="ltxt" align=center>&copy; INTUIT.ru, 2003-2008. Все права защищены.</td>
</tr>
</table>
<!-- /bottom -->

<script src="3. Планирование процессов_files/urchin00.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-3475067-1";
urchinTracker();
</script></body>
</html>


<!-- This document saved from http://www.intuit.ru/department/os/osintro/3/osintro_3.html -->
