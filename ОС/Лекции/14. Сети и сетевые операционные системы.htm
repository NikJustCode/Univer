<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>INTUIT.ru::Интернет-Университет Информационных Технологий</title>
<link href="14. Сети и сетевые операционные системы_files/printabl.css" type="text/css" rel="stylesheet">
</head>
<body leftmargin="6" topmargin="6" marginheight="6" marginwidth="6">


<div align="left">
<span style="color: #000000; font-weight: bold;">
&nbsp;&nbsp;
<span style="font-size:12pt;">Интернет-Университет Информационных Технологий</span>
</span>
</div>

&nbsp;&nbsp;
<span align="rright" style="color: #330066; text-decoration:underline;">http://www.INTUIT.ru</span>


<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td height="8" colspan=3><img src="14. Сети и сетевые операционные системы_files/empty000.gif" width="1" height="8"></td></tr>
<tr><td class="orang" height="1" colspan=3><img src="14. Сети и сетевые операционные системы_files/empty000.gif" width="1" height="1"></td></tr>
<tr><td height="8" colspan=3><img src="14. Сети и сетевые операционные системы_files/empty000.gif" width="1" height="8"></td></tr>
<tr valign="top">
<td><img src="14. Сети и сетевые операционные системы_files/empty000.gif" width="8" height="1"></td>
<td>
	<!-- content -->
	<table border="0" cellpadding="0" cellspacing="0" width="100%">
	<tr><td class="head">Основы операционных систем</td></tr>
<tr><td height="4"><img src="14. Сети и сетевые операционные системы_files/empty000.gif" width="1" height="4"></td></tr>
	<tr><td class="orang" height="1"><img src="14. Сети и сетевые операционные системы_files/empty000.gif" width="1" height="1"></td></tr>
	<tr><td height="8"><img src="14. Сети и сетевые операционные системы_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td><span class="headsub">


14. Лекция:

 Сети и сетевые операционные системы : версия для печати и PDA</span>

<br>
<span class="rtxt">В лекции рассматриваются особенности взаимодействия процессов, выполняющихся на разных операционных системах, и вытекающие из этих особенностей функции сетевых частей операционных систем.
</span>

</td></tr>

	<tr><td height="8"><img src="14. Сети и сетевые операционные системы_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td class="orang" height="1"><img src="14. Сети и сетевые операционные системы_files/empty000.gif" width="1" height="1"></td></tr>
	<tr><td height="8"><img src="14. Сети и сетевые операционные системы_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td>


<h3 ></h3><p  id="id_1">До сих пор в лекциях данного курса мы ограничивались рамками классических операционных систем, т. е. операционных систем, функционирующих на автономных однопроцессорных вычислительных машинах, которые к середине 80-х годов прошлого века составляли основу мирового парка вычислительной техники. Подчиняясь критериям повышения эффективности и удобства использования, вычислительные системы с этого времени, о чем мы уже упоминали в самой первой лекции, начинают бурно развиваться в двух направлениях: создание многопроцессорных компьютеров и объединение автономных систем в <span class="keyword">вычислительные сети</span>.</p><div  class="lecture_mark" id="mark_1"></div><p  id="id_2">Появление многопроцессорных компьютеров не оказывает существенного влияния на работу операционных систем. В многопроцессорной вычислительной системе изменяется содержание состояния <b>исполнение</b>. В этом состоянии может находиться не один процесс, а несколько – по числу процессоров. Соответственно изменяются и алгоритмы планирования. Наличие нескольких исполняющихся процессов требует более аккуратной реализации взаимоисключений при работе ядра. Но все эти изменения не являются изменениями идеологическими, не носят принципиального характера. Принципиальные изменения в многопроцессорных вычислительных комплексах затрагивают алгоритмический уровень, требуя разработки алгоритмов распараллеливания решения задач. Поскольку с точки зрения нашего курса многопроцессорные системы не внесли в развитие операционных систем что-либо принципиально новое, мы их рассматривать далее не будем.</p><div  class="lecture_mark" id="mark_2"></div><p  id="id_3">По-другому обстоит дело с вычислительными сетями.</p><div  class="lecture_mark" id="mark_3"></div><h3 >Для чего компьютеры объединяют в сети </h3><p  id="id_4">Для чего вообще потребовалось объединять компьютеры в сети? Что привело к появлению сетей? </p><div  class="lecture_mark" id="mark_4"></div><ul  id="id_5"><li>Одной из главных причин стала необходимость совместного использования ресурсов (как физических, так и информационных). Если в организации имеется несколько компьютеров и эпизодически возникает потребность в печати какого-нибудь текста, то не имеет смысла покупать принтер для каждого компьютера. Гораздо выгоднее иметь один сетевой принтер для всех вычислительных машин. Аналогичная ситуация может возникать и с файлами данных. Зачем держать одинаковые файлы данных на всех компьютерах, поддерживая их когерентность, если можно хранить файл на одной машине, обеспечив к нему сетевой доступ со всех остальных?</li><li>Второй причиной следует считать возможность ускорения вычислений. Здесь сетевые объединения машин успешно конкурируют с многопроцессорными вычислительными комплексами. Многопроцессорные системы, не затрагивая по существу строение операционных систем, требуют достаточно серьезных изменений на уровне hardware, что очень сильно повышает их стоимость. Во многих случаях можно добиться требуемой скорости вычислений параллельного алгоритма, используя не несколько процессоров внутри одного вычислительного комплекса, а несколько отдельных компьютеров, объединенных в сеть. Такие сетевые вычислительные кластеры часто имеют преимущество перед многопроцессорными комплексами в соотношении эффективность/стоимость.</li><li>Следующая причина связана с повышением надежности работы вычислительной техники. В системах, где отказ может вызвать катастрофические последствия (атомная энергетика, космонавтика, авиация и т. д.), несколько вычислительных комплексов устанавливаются в связи, дублируя друг друга. При выходе из строя основного комплекса его работу немедленно продолжает дублирующий. </li><li>Наконец, последней по времени появления причиной (но для многих основной по важности) стала возможность применения <span class="keyword">вычислительных сетей</span> для общения пользователей. Электронные письма практически заменили письма обычные, а использование вычислительной техники для организации электронных или телефонных разговоров уверенно вытесняет обычную телефонную связь. </li></ul><div  class="lecture_mark" id="mark_5"></div><h3 >Сетевые и распределенные операционные системы </h3><p  id="id_10">В первой лекции мы говорили, что существует два основных подхода к организации операционных систем для вычислительных комплексов, связанных в сеть, – это <span class="keyword">сетевые</span> и <span class="keyword">распределенные операционные системы</span>. Необходимо отметить, что терминология в этой области еще не устоялась. В одних работах все операционные системы, обеспечивающие функционирование компьютеров в сети, называются распределенными, а в других, наоборот, сетевыми. Мы придерживаемся той точки зрения, что <span class="keyword">сетевые</span> и распределенные системы являются принципиально различными. </p><div  class="lecture_mark" id="mark_10"></div><p  id="id_11">В <span class="keyword">сетевых операционных системах</span> для того, чтобы задействовать ресурсы другого сетевого компьютера, пользователи должны знать о его наличии и уметь это сделать. Каждая машина в сети работает под управлением своей локальной операционной системы, отличающейся от операционной системы автономного компьютера наличием дополнительных сетевых средств (программной поддержкой для сетевых интерфейсных устройств и доступа к удаленным ресурсам), но эти дополнения существенно не меняют структуру операционной системы. </p><div  class="lecture_mark" id="mark_11"></div><p  id="id_12">Распределенная система, напротив, внешне выглядит как обычная автономная система. Пользователь не знает и не должен знать, где его файлы хранятся, на локальной или удаленной машине, и где его программы выполняются. Он может вообще не знать, подключен ли его компьютер к сети. Внутреннее строение <span class="keyword">распределенной операционной системы</span> имеет существенные отличия от автономных систем. </p><div  class="lecture_mark" id="mark_12"></div><p  id="id_13">Изучение строения <span class="keyword">распределенных операционных систем</span> не входит в задачи нашего курса. Этому вопросу посвящены другие учебные курсы – Advanced operating systems, как называют их в англоязычных странах, или "Современные операционные системы", как принято называть их в России. </p><div  class="lecture_mark" id="mark_13"></div><p  id="id_14">В этой лекции мы затронем вопросы, связанные с <span class="keyword">сетевыми операционными системами</span>, а именно – какие изменения необходимо внести в классическую операционную систему для объединения компьютеров в сеть.</p><div  class="lecture_mark" id="mark_14"></div><h3 >Взаимодействие удаленных процессов как основа работы вычислительных сетей </h3><p  id="id_15">Все перечисленные выше цели объединения компьютеров в <span class="keyword">вычислительные сети</span> не могут быть достигнуты без организации взаимодействия процессов на различных вычислительных системах. Будь то доступ к разделяемым ресурсам или общение пользователей через сеть – в основе всего этого лежит <span class="keyword">взаимодействие удаленных процессов</span>, т. е. процессов, которые находятся под управлением физически разных операционных систем. Поэтому мы в своей работе сосредоточимся именно на вопросах кооперации таких процессов, в первую очередь выделив ее отличия от кооперации процессов в одной автономной вычислительной системе (кооперации <span class="keyword">локальных процессов</span>), о которой мы говорили в лекциях 4, 5 и 6.</p><div  class="lecture_mark" id="mark_15"></div><ol  id="id_16"><li>Изучая взаимодействие <span class="keyword">локальных процессов</span>, мы разделили средства обмена информацией по объему передаваемых между ними данных и возможности влияния на поведение другого процесса на три категории: сигнальные, канальные и разделяемая память. На самом деле во всей этой систематизации присутствовала некоторая доля лукавства. Мы фактически классифицировали средства связи по виду интерфейса обращения к ним, в то время как реальной физической основой для всех средств связи в том или ином виде являлось разделение памяти. Семафоры представляют собой просто целочисленные переменные, лежащие в разделяемой памяти, к которым посредством системных вызовов, определяющих состав и содержание допустимых операций над ними, могут обращаться различные процессы. Очереди сообщений и pip'ы базируются на буферах ядра операционной системы, которые опять-таки с помощью системных вызовов доступны различным процессам. Иного способа реально передать информацию от процесса к процессу в автономной вычислительной системе просто не существует. 	<span class="keyword">Взаимодействие удаленных процессов</span> принципиально отличается от ранее рассмотренных случаев. Общей памяти у различных компьютеров физически нет. <span class="keyword">Удаленные процессы</span> могут обмениваться информацией, только передавая друг другу пакеты данных определенного формата (в виде последовательностей электрических или электромагнитных сигналов, включая световые) через некоторый физический канал связи или несколько таких каналов, соединяющих компьютеры. Поэтому в основе всех средств <span class="keyword">взаимодействия удаленных процессов</span> лежит передача структурированных пакетов информации или сообщений.</li><li>При взаимодействии <span class="keyword">локальных процессов</span> и процесс–отправитель информации, и процесс-получатель функционируют под управлением одной и той же операционной системы. Эта же операционная система поддерживает и функционирование промежуточных накопителей данных при использовании непрямой адресации. Для организации взаимодействия процессы пользуются одними и теми же системными вызовами, присущими данной операционной системе, с одинаковыми интерфейсами. Более того, в автономной операционной системе передача информации от одного процесса к другому, независимо от используемого способа адресации, как правило (за исключением микроядерных операционных систем), происходит напрямую – без участия других процессов-посредников. Но даже и при наличии процессов-посредников все участники передачи информации находятся под управлением одной и той же операционной системы. 
	При организации сети, конечно, можно обеспечить прямую связь между всеми вычислительными комплексами, соединив каждый из них со всеми остальными посредством прямых физических линий связи или подключив все комплексы к общей шине (по примеру шин данных и адреса в компьютере). Однако такая сетевая топология не всегда возможна по ряду физических и финансовых причин. Поэтому во многих случаях информация между <span class="keyword">удаленными процессами</span> в сети передается не напрямую, а через ряд процессов-посредников, "обитающих" на вычислительных комплексах, не являющихся компьютерами отправителя и получателя и работающих под управлением собственных операционных систем. Однако и при отсутствии процессов-посредников удаленные процесс-отправитель и процесс-получатель функционируют под управлением различных операционных систем, часто имеющих принципиально разное строение.</li><li>Вопросы надежности средств связи и способы ее реализации, рассмотренные нами в лекции 4, носили для случая <span class="keyword">локальных процессов</span> скорее теоретический характер. Мы выяснили, что физической основой "общения" процессов на автономной вычислительной машине является разделяемая память. Поэтому для <span class="keyword">локальных процессов</span> надежность передачи информации определяется надежностью ее передачи по шине данных и хранения в памяти машины, а также корректностью работы операционной системы. Для хороших вычислительных комплексов и операционных систем мы могли забыть про возможную ненадежность средств связи. 
	Для <span class="keyword">удаленных процессов</span> вопросы, связанные с надежностью передачи данных, становятся куда более значимыми. Протяженные сетевые линии связи подвержены разнообразным физическим воздействиям, приводящим к искажению передаваемых по ним физических сигналов (помехи в эфире) или к полному отказу линий (мыши съели кабель). Даже при отсутствии внешних помех передаваемый сигнал затухает по мере удаления от точки отправления, приближаясь по интенсивности к внутренним шумам линий связи. Промежуточные вычислительные комплексы сети, участвующие в доставке информации, не застрахованы от повреждений или внезапной перезагрузки операционной системы. Поэтому <span class="keyword">вычислительные сети</span> должны организовываться исходя из предпосылок ненадежности доставки физических пакетов информации.</li><li>При организации взаимодействия <span class="keyword">локальных процессов</span> каждый процесс (в случае прямой адресации) и каждый промежуточный объект для накопления данных (в случае непрямой адресации) должны были иметь уникальные идентификаторы – адреса – в рамках одной операционной системы. При организации <span class="keyword">взаимодействия удаленных процессов</span> участники этого взаимодействия должны иметь уникальные адреса уже в рамках всей сети.</li><li>Физическая линия связи, соединяющая несколько вычислительных комплексов, является разделяемым ресурсом для всех процессов комплексов, которые хотят ее использовать. Если два процесса попытаются одновременно передать пакеты информации по одной и той же линии, то в результате интерференции физических сигналов, представляющих эти пакеты, произойдет взаимное искажение передаваемых данных. Для того чтобы избежать возникновения такой ситуации (race condition!) и обеспечить эффективную совместную работу вычислительных систем, должны выполняться условия взаимоисключения, прогресса и ограниченного ожидания при использовании общей линии связи, но уже не на уровне отдельных процессов операционных систем, а на уровне различных вычислительных комплексов в целом.</li></ol><div  class="lecture_mark" id="mark_16"></div><p  id="id_22">Давайте теперь, абстрагировавшись от <span class="keyword">физического уровня</span> организации связи и не обращая внимания на то, какие именно физические средства – оптическое волокно, коаксиальный кабель, спутниковая связь и т. д. – лежат в основе объединения компьютеров в сеть, обсудим влияние перечисленных отличий на логические принципы организации <span class="keyword">взаимодействия удаленных процессов</span>. </p><div  class="lecture_mark" id="mark_22"></div><h3 >Основные вопросы логической организации 
передачи информации между удаленными 
процессами </h3><p  id="id_23">К числу наиболее фундаментальных вопросов, связанных с логической организацией <span class="keyword">взаимодействия удаленных процессов</span>, можно отнести следующие: </p><div  class="lecture_mark" id="mark_23"></div><ol  id="id_24"><li>Как нужно соединять между собой различные вычислительные системы физическими линиями связи для организации <span class="keyword">взаимодействия удаленных процессов</span>? Какими критериями при этом следует пользоваться?</li><li>Как избежать возникновения race condition при передаче информации различными вычислительными системами после их подключения к общей линии связи? Какие алгоритмы могут при этом применяться?</li><li>Какие виды интерфейсов могут быть предоставлены пользователю операционными системами для передачи информации по сети? Какие существуют модели <span class="keyword">взаимодействия удаленных процессов</span>? Как процессы, работающие под управлением различных по своему строению операционных систем, могут общаться друг с другом?</li><li>Какие существуют подходы к организации адресации <span class="keyword">удаленных процессов</span>? Насколько они эффективны? </li><li>Как организуется доставка информации от компьютера-отправителя к компьютеру-получателю через компьютеры-посредники? Как выбирается маршрут для передачи данных в случае разветвленной сетевой структуры, когда существует не один вариант следования пакетов данных через компьютеры-посредники? </li></ol><div  class="lecture_mark" id="mark_24"></div><p  id="id_30">Разумеется, степень важности этих вопросов во многом зависит от того, с какой точки зрения мы рассматриваем <span class="keyword">взаимодействие удаленных процессов</span>. Системного программиста, в первую очередь, интересуют интерфейсы, предоставляемые операционными системами. Сетевого администратора больше будут занимать вопросы адресации процессов и выбора маршрута доставки данных. Проектировщика сетей в организации – способы соединения компьютеров и обеспечения корректного использования разделяемых сетевых ресурсов. Мы изучаем особенности строения и функционирования частей операционных систем, ответственных за <span class="keyword">взаимодействие удаленных процессов</span>, а поэтому рассматриваемый перечень вопросов существенно сокращается.</p><div  class="lecture_mark" id="mark_30"></div><p  id="id_31">Выбор способа соединения участников сетевого взаимодействия физическими линиями связи (количество и тип прокладываемых коммуникаций, какие именно устройства и как они будут соединять,т. е. топология сети) определяется проектировщиками сетей исходя из имеющихся средств, требуемой производительности и надежности взаимодействия. Все это не имеет отношения к функционированию операционных систем, является внешним по отношению к ним и в нашем курсе рассматриваться не будет. </p><div  class="lecture_mark" id="mark_31"></div><p  id="id_32">В современных сетевых вычислительных комплексах решение вопросов организации взаимоисключений при использовании общей линии связи, как правило, также находится вне компетенции операционных систем и вынесено на <span class="keyword">физический уровень</span> организации взаимодействия. Ответственность за корректное использование коммуникаций возлагается на сетевые адаптеры, поэтому подобные проблемы мы тоже рассматривать не будем. </p><div  class="lecture_mark" id="mark_32"></div><p  id="id_33">Из приведенного перечня мы с вами подробнее остановимся на решении вопросов, приведенных в пунктах 3–5.</p><div  class="lecture_mark" id="mark_33"></div><h3 >Понятие протокола</h3><p  id="id_34">Для описания происходящего в автономной операционной системе в лекции 2 было введено основополагающее понятие "процесс", на котором, по сути дела, базируется весь наш курс. Для того чтобы описать <span class="keyword">взаимодействие удаленных процессов</span> и понять, какие функции и как должны выполнять дополнительные части <span class="keyword">сетевых операционных систем</span>, отвечающих за такое взаимодействие, нам понадобится не менее фундаментальное понятие – <span class="keyword">протокол</span>.</p><div  class="lecture_mark" id="mark_34"></div><p  id="id_35">"Общение" <span class="keyword">локальных процессов</span> напоминает общение людей, проживающих в одном городе. Если взаимодействующие процессы находятся под управлением различных операционных систем, то эта ситуация подобна общению людей, проживающих в разных городах и, возможно, в разных странах. </p><div  class="lecture_mark" id="mark_35"></div><p  id="id_36">Каким образом два человека, находящиеся в разных городах, а тем более странах, могут обмениваться информацией? Для этого им обычно приходится прибегать к услугам соответствующих служб связи. При этом между службами связи различных городов (государств) должны быть заключены определенные соглашения, позволяющие корректно организовывать такой обмен. Если речь идет, например, о почтовых отправлениях, то в первую очередь необходимо договориться о том, что может представлять собой почтовое отправление, какой вид оно может иметь. Некоторые племена индейцев для передачи информации пользовались узелковыми письмами – поясами, к которым крепились веревочки с различным числом и формой узелков. Если бы такое письмо попало в современный почтовый ящик, то, пожалуй, ни одно отделение связи не догадалось бы, что это – письмо, и пояс был бы выброшен как ненужный хлам. Помимо формы представления информации необходима договоренность о том, какой служебной информацией должно снабжаться почтовое отправление (адрес получателя, срочность доставки, способ пересылки: поездом, авиацией, с помощью курьера и т. п.) и в каком формате она должна быть представлена. Адреса, например, в России и в США принято записывать по-разному. В России мы начинаем адрес со страны, далее указывается город, улица и квартира. В США все наоборот: сначала указывается квартира, затем улица и т. д. Конечно, даже при неправильной записи адреса письмо, скорее всего, дойдет до получателя, но можно себе представить растерянность почтальона, пытающегося разгадать, что это за страна или город – "кв.162"? Как видим, доставка почтового отправления из одного города (страны) в другой требует целого ряда соглашений между почтовыми ведомствами этих городов (стран).</p><div  class="lecture_mark" id="mark_36"></div><p  id="id_37">Аналогичная ситуация возникает и при общении <span class="keyword">удаленных процессов</span>, работающих под управлением разных операционных систем. Здесь процессы играют роль людей, проживающих в разных городах, а сетевые части операционных систем – роль соответствующих служб связи. Для того чтобы <span class="keyword">удаленные процессы</span> могли обмениваться данными, необходимо, чтобы сетевые части операционных систем руководствовались определенными соглашениями, или, как принято говорить, поддерживали определенные <span class="keyword">протоколы</span>. Термин <span class="keyword">"протокол"</span> уже встречался нам в лекции 13, посвященной организации ввода-вывода в операционных системах, при обсуждении понятия "шина". Мы говорили, что понятие шины подразумевает не только набор проводников, но и набор жестко заданных <span class="keyword">протоколов</span>, определяющий перечень сообщений, который может быть передан с помощью электрических сигналов по этим проводникам, т. е. в <span class="keyword">"протокол"</span> мы вкладывали практически тот же смысл. В следующем разделе 
мы попытаемся дать более формализованное определение этого термина.</p><div  class="lecture_mark" id="mark_37"></div><p  id="id_38">Необходимо отметить, что и <span class="keyword">локальные процессы</span> при общении также должны руководствоваться определенными соглашениями или поддерживать определенные <span class="keyword">протоколы</span>. Только в автономных операционных системах они несколько завуалированы. В роли таких <span class="keyword">протоколов</span> выступают специальная последовательность системных вызовов при организации взаимодействия процессов и соглашения о параметрах системных вызовов.</p><div  class="lecture_mark" id="mark_38"></div><p  id="id_39">Различные способы решения проблем 3–5, поднятых в предыдущем разделе, по существу, представляют собой различные соглашения, которых должны придерживаться сетевые части операционных систем, т. е. различные <span class="keyword">сетевые протоколы</span>. Именно наличие <span class="keyword">сетевых протоколов</span> позволяет организовать <span class="keyword">взаимодействие удаленных процессов</span>.</p><div  class="lecture_mark" id="mark_39"></div><p  id="id_40">При рассмотрении перечисленных выше проблем необходимо учитывать, с какими сетями мы имеем дело.</p><div  class="lecture_mark" id="mark_40"></div><p  id="id_41">В литературе принято говорить о <b>локальных</b>   <span class="keyword">вычислительных сетях</span>   <b>(LAN – Local Area Network)</b> и <b>глобальных</b>   <span class="keyword">вычислительных сетях</span>   <b>(WAN – Wide Area Network)</b>. Строгого определения этим понятиям обычно не дается, а принадлежность сети к тому или иному типу часто определяется взаимным расположением вычислительных комплексов, объединенных в сеть. Так, например, в большинстве работ к локальным сетям относят сети, состоящие из компьютеров одной организации, размещенные в пределах одного или нескольких зданий, а к глобальным сетям – сети, охватывающие все компьютеры в нескольких городах и более. Зачастую вводится дополнительный термин для описания сетей промежуточного масштаба – <b>муниципальных</b> или <b>городских</b>   <span class="keyword">вычислительных сетей</span>   <b>(MAN – Metropolitan Area Network)</b> – сетей, объединяющих компьютеры различных организаций в пределах одного города или одного городского района. Таким образом, упрощенно можно рассматривать глобальные сети как сети, состоящие из локальных и муниципальных сетей. А муниципальные сети, в свою очередь, могут состоять из нескольких локальных сетей. На самом деле деление сетей на локальные, глобальные и муниципальные обычно связано не столько с местоположением и принадлежностью вычислительных систем, соединенных сетью, сколько с различными подходами, применяемыми для решения поставленных вопросов в рамках той или иной сети, – с различными используемыми <span class="keyword">протоколами</span>.</p><div  class="lecture_mark" id="mark_41"></div><h3 >Многоуровневая модель построения сетевых 
вычислительных систем</h3><p  id="id_42">Даже беглого взгляда на перечень проблем, связанных с логической организацией <span class="keyword">взаимодействия удаленных процессов</span>, достаточно, чтобы понять, что построение сетевых средств связи – задача более сложная, чем реализация локальных средств связи. Поэтому обычно задачу создания таких средств решают по частям, применяя уже неоднократно упоминавшийся нами "слоеный", или многоуровневый, подход.</p><div  class="lecture_mark" id="mark_42"></div><p  id="id_43">Как уже отмечалось при обсуждении "слоеного" строения операционных систем на первой лекции, при таком подходе уровень N системы предоставляет сервисы уровню N+1, пользуясь в свою очередь только сервисами уровня N-1. Следовательно, каждый уровень может взаимодействовать непосредственно только со своими соседями, руководствуясь четко закрепленными соглашениями – вертикальными <span class="keyword">протоколами</span>, которые принято называть интерфейсами.</p><div  class="lecture_mark" id="mark_43"></div><p  id="id_44">Самым нижним уровнем в слоеных сетевых вычислительных системах является уровень, на котором реализуется реальная физическая связь между двумя узлами сети. Из предыдущего раздела следует, что для обеспечения обмена физическими сигналами между двумя различными вычислительными системами необходимо, чтобы эти системы поддерживали определенный <span class="keyword">протокол</span> физического взаимодействия – горизонтальный <span class="keyword">протокол</span>.</p><div  class="lecture_mark" id="mark_44"></div><p  id="id_45">На самом верхнем уровне находятся пользовательские процессы, которые инициируют обмен данными. Количество и функции промежуточных уровней варьируются от одной системы к другой. Вернемся к нашей аналогии с пересылкой почтовых отправлений между людьми, проживающими в разных городах, правда, с порядком их пересылки несколько отличным от привычного житейского порядка. Рассмотрим в качестве пользовательских процессов руководителей различных организаций, желающих обменяться письмами. Руководитель (пользовательский процесс) готовит текст письма (данные) для пересылки в другую организацию. Затем он отдает его своему секретарю (совершает системный вызов – обращение к нижележащему уровню), сообщая, кому и куда должно быть направлено письмо. Секретарь снимает с него копию и выясняет адрес организации. Далее идет обращение к нижестоящему уровню, допустим, письмо направляется в канцелярию. Здесь оно регистрируется (ему присваивается порядковый номер), один экземпляр запечатывается в конверт, на котором указывается, 
кому и куда адресовано письмо, впечатывается адрес отправителя. Копия остается в канцелярии, а конверт отправляется на почту (переход на следующий уровень). На почте наклеиваются марки и делаются другие служебные пометки, определяется способ доставки корреспонденции и т. д. Наконец, поездом, самолетом или курьером (<span class="keyword">физический уровень</span>!) письмо следует в другой город, в котором все уровни проходятся в обратном порядке. Пользовательский уровень (руководитель) после подготовки исходных данных и инициации процесса взаимодействия далее судьбой почтового отправления не занимается. Все остальное (включая, быть может, проверку его доставки и посылку копии в случае утери) выполняют нижележащие уровни. </p><div  class="lecture_mark" id="mark_45"></div><p  id="id_46">Заметим, что на каждом уровне взаимодействия в городе отправителя исходные данные (текст письма) обрастают дополнительной служебной информацией. Соответствующие уровни почтовой службы в городе получателя должны уметь понимать эту служебную информацию. Таким образом, для одинаковых уровней в различных городах необходимо следование специальным соглашениям – поддержка определенных горизонтальных <span class="keyword">протоколов</span>.</p><div  class="lecture_mark" id="mark_46"></div><p  id="id_47">Точно так же в сетевых вычислительных системах все их одинаковые уровни, лежащие выше <span class="keyword">физического</span>, виртуально обмениваются данными посредством горизонтальных <span class="keyword">протоколов</span>. Наличие такой виртуальной связи означает, что уровень N компьютера 2 должен получить ту же самую информацию, которая была отправлена уровнем N компьютера 1. Хотя в реальности эта информация должна была сначала дойти сверху вниз до уровня 1 компьютера 1, затем передана уровню 1 компьютера 2 и только после этого доставлена снизу вверх уровню N этого компьютера.</p><div  class="lecture_mark" id="mark_47"></div><p  id="id_48"><a name="keyword-context.1"></a>Формальный перечень правил, определяющих последовательность и формат сообщений, которыми обмениваются сетевые компоненты различных вычислительных систем, лежащие на одном уровне, мы и будем называть <span class="keyword_def">сетевым протоколом</span>. </p><div  class="lecture_mark" id="mark_48"></div><p  id="id_49">Всю совокупность вертикальных и горизонтальных <span class="keyword">протоколов</span> (интерфейсов и <span class="keyword">сетевых протоколов</span>) в сетевых системах, построенных по "слоеному" принципу, достаточную для организации <span class="keyword">взаимодействия удаленных процессов</span>, принято называть <b>семейством</b>   <span class="keyword">протоколов</span> или <b>стеком</b>   <span class="keyword">протоколов</span>. Сети, построенные на основе разных стеков <span class="keyword">протоколов</span>, могут быть объединены между собой с использованием вычислительных устройств, осуществляющих трансляцию из одного стека <span class="keyword">протоколов</span> в другой, причем на различных уровнях слоеной модели</p><div  class="lecture_mark" id="mark_49"></div><p  id="id_50"><a name="keyword-context.2"></a>Эталоном многоуровневой схемы построения сетевых средств связи считается семиуровневая модель открытого взаимодействия систем (Open System Interconnection – OSI), предложенная Международной организацией Стандартов (International Standard Organization – ISO) и получившая сокращенное наименование <span class="keyword_def">OSI/ISO</span> (см. <a href="">рис. 14.1</a>). </p><div  class="lecture_mark" id="mark_50"></div><p  id="id_51">Давайте очень кратко опишем, какие функции выполняют различные уровни модели <span class="keyword">OSI/ISO</span> [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#23">Олифер, 2001</a>]:</p><div  class="lecture_mark" id="mark_51"></div><ul  id="id_52"><li><a name="keyword-context.3"></a>Уровень 1 – <span class="keyword_def">физический</span>. Этот уровень связан с работой hardware. На нем определяются физические аспекты передачи информации по линиям связи, такие как: напряжения, частоты, природа передающей среды, способ передачи двоичной информации по физическому носителю, вплоть до размеров и формы используемых разъемов. В компьютерах за поддержку <span class="keyword">физического уровня</span> обычно отвечает сетевой адаптер.</li><li><a name="keyword-context.4"></a>Уровень 2 – <span class="keyword_def">канальный</span>. Этот уровень отвечает за передачу данных по <span class="keyword">физическому уровню</span> без искажений между непосредственно связанными узлами сети. На нем формируются физические пакеты данных для реальной доставки по <span class="keyword">физическому уровню</span>. <span class="keyword">Протоколы</span>   <span class="keyword">канального уровня</span> реализуются совместно сетевыми адаптерами и их драйверами (понятие драйвера рассматривалось в лекции 13).</li><li><a name="keyword-context.5"></a>Уровень 3 – <span class="keyword_def">сетевой</span>. <span class="keyword">Сетевой уровень</span> несет ответственность за доставку информации от узла-отправителя к узлу-получателю. На этом уровне частично решаются вопросы адресации, осуществляется выбор маршрутов следования пакетов данных, решаются вопросы стыковки сетей, а также управление скоростью передачи информации для предотвращения перегрузок в сети. </li><li><a name="keyword-context.6"></a>Уровень 4 – <span class="keyword_def">транспортный</span>. Регламентирует передачу данных между <span class="keyword">удаленными процессами</span>. Обеспечивает доставку информации вышележащим уровнем с необходимой степенью надежности, компенсируя, быть может, ненадежность нижележащих уровней, связанную с искажением и потерей данных или доставкой пакетов в неправильном порядке. Наряду с <span class="keyword">сетевым уровнем</span> может управлять скоростью передачи данных и частично решать проблемы адресации.
<p align="left" id="id_57"><a name="image.14.1"></a><div><img src="14. Сети и сетевые операционные системы_files/14-10000.gif" alt="Семиуровневая эталонная модель OSI/ISO" width="551" height="505"></div><br><b>Рис. 14.1.</b> 
        Семиуровневая эталонная модель OSI/ISO</p><div class="lecture_mark" id="mark_57"></div></li><li><a name="keyword-context.7"></a>Уровень 5 – <span class="keyword_def">сеансовый</span>. Координирует взаимодействие связывающихся процессов. Основная задача – предоставление средств синхронизации взаимодействующих процессов. Такие средства синхронизации позволяют создавать контрольные точки при передаче больших объемов информации. В случае сбоя в работе сети передачу данных можно возобновить с последней контрольной точки, а не начинать заново.</li><li><a name="keyword-context.8"></a>Уровень 6 – <span class="keyword_def">уровень представления данных</span>. Отвечает за форму представления данных, перекодирует текстовую и графическую информацию из одного формата в другой, обеспечивает ее сжатие и распаковку, шифрование и декодирование. </li><li><a name="keyword-context.9"></a>Уровень 7 – <span class="keyword_def">прикладной</span>. Служит для организации интерфейса между пользователем и сетью. На этом уровне реализуются такие сервисы, как удаленная передача данных, удаленный терминальный доступ, почтовая служба и работа во Всемирной паутине (Web-браузеры). </li></ul><div  class="lecture_mark" id="mark_52"></div><p  id="id_61">Надо отметить, что к приведенной эталонной модели большинство практиков относится без излишнего пиетета. Эта модель не предвосхитила появления различных семейств <span class="keyword">протоколов</span>, таких как, например, семейство <span class="keyword">протоколов</span> TCP/IP, а наоборот, была создана под их влиянием. Ее не следует рассматривать как готовый оптимальный чертеж для создания любого сетевого средства связи. Наличие некоторой функции на определенном уровне не гарантирует, что это ее наилучшее место, некоторые функции (например, коррекция ошибок) дублируются на нескольких уровнях, да и само деление на 7 уровней носит отчасти произвольный характер. Хотя в конце концов были созданы работающие реализации этой модели, но наиболее распространенные семейства <span class="keyword">протоколов</span> лишь до некоторой степени согласуются с ней. Как отмечено в книге [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#30">Таненбаум, 2002</a>], она больше подходит для реализации телефонных, а не <span class="keyword">вычислительных сетей</span>. Ценность предложенной эталонной модели заключается в том, что она показывает направление, в котором должны двигаться разработчики 
новых <span class="keyword">вычислительных сетей</span>.</p><div  class="lecture_mark" id="mark_61"></div><p  id="id_62">Проблемы 3–5, перечисленные в разделе "Основные вопросы логической организации передачи информации" между <span class="keyword">удаленными процессами</span>, относятся в основном к <span class="keyword">сетевому</span> и <span class="keyword">транспортному уровням</span> эталонной модели и, соответственно, решаются на уровне сетевых и транспортных <span class="keyword">протоколов</span>. Давайте приступим, наконец, к их рассмотрению.</p><div  class="lecture_mark" id="mark_62"></div><h3 >Проблемы адресации в сети </h3><p  id="id_63">Любой пакет информации, передаваемый по сети, должен быть снабжен адресом получателя. Если взаимодействие подразумевает двустороннее общение, то в пакет следует также включить и адрес отправителя. В лекции 4 мы описали один из <span class="keyword">протоколов</span> организации надежной связи с использованием контрольных сумм, нумерации пакетов и подтверждения получения неискаженного пакета в правильном порядке. Для отправки подтверждений обратный адрес также следует включать в пересылаемый пакет. Таким образом, практически каждый сетевой пакет информации должен быть снабжен адресом получателя и адресом отправителя. Как могут выглядеть такие адреса?</p><div  class="lecture_mark" id="mark_63"></div><p  id="id_64">Несколько раньше, обсуждая отличия <span class="keyword">взаимодействия удаленных процессов</span> от взаимодействия <span class="keyword">локальных процессов</span>, мы говорили, что удаленные адресаты должны обладать уникальными адресами уже не в пределах одного компьютера, а в рамках всей сети. Существует два подхода к наделению объектов такими сетевыми адресами: одноуровневый и двухуровневый. </p><div  class="lecture_mark" id="mark_64"></div><h4 >Одноуровневые адреса</h4><p  id="id_65">В небольших компьютерных сетях можно построить одноуровневую систему адресации. При таком подходе каждый процесс, желающий стать участником удаленного взаимодействия (при прямой адресации), и каждый объект, для такого взаимодействия предназначенный (при непрямой адресации), получают по мере необходимости собственные адреса (символьные или числовые), а сами вычислительные комплексы, объединенные в сеть, никаких самостоятельных адресов не имеют. Подобный метод требует довольно сложного <span class="keyword">протокола</span> обеспечения уникальности адресов. Вычислительный комплекс, на котором запускается взаимодействующий процесс, должен запросить все компьютеры сети о возможности присвоения процессу некоторого адреса. Только после получения от них согласия процессу может быть назначен адрес. Поскольку процесс, посылающий данные другому процессу, не может знать, на каком компоненте сети находится процесс-адресат, передаваемая информация должна быть направлена всем компонентам сети (так называемое <b>широковещательное сообщение – broadcast message</b>), проанализирована ими и либо отброшена (если процесса-адресата на данном компьютере нет), либо доставлена по назначению. Так как все данные постоянно передаются от одного комплекса ко всем остальным, такую одноуровневую схему обычно применяют только в локальных сетях с прямой физической связью всех компьютеров между собой (например, в сети NetBIOS на базе Ethernet), но она является существенно менее эффективной, чем двухуровневая схема адресации. </p><div  class="lecture_mark" id="mark_65"></div><h4 >Двухуровневые адреса</h4><p  id="id_66">При двухуровневой адресации полный сетевой адрес процесса или промежуточного объекта для хранения данных складывается из двух частей – адреса вычислительного комплекса, на котором находится процесс или объект в сети (<span class="keyword">удаленного адреса</span>), и адреса самого процесса или объекта на этом вычислительном комплексе (<span class="keyword">локального адреса</span>). Уникальность полного адреса будет обеспечиваться уникальностью <span class="keyword">удаленного адреса</span> для каждого компьютера в сети и уникальностью <span class="keyword">локальных адресов</span> объектов на компьютере. Давайте подробнее рассмотрим проблемы, возникающие для каждого из компонентов полного адреса. </p><div  class="lecture_mark" id="mark_66"></div><h4 >Удаленная адресация и разрешение адресов</h4><p  id="id_67">Инициатором связи процессов друг с другом всегда является человек, будь то программист или обычный пользователь. Как мы неоднократно отмечали в лекциях, человеку свойственно думать словами, он легче воспринимает символьную информацию. Поэтому очевидно, что каждая машина в сети получает символьное, часто даже содержательное имя. Компьютер не разбирается в смысловом содержании символов, ему проще оперировать числами, желательно одного и того же формата, которые помещаются, например, в 4 байта или в 16 байт. Поэтому каждый компьютер в сети для удобства работы вычислительных систем получает числовой адрес. Возникает <a name="keyword-context.10"></a>проблема отображения пространства символьных имен (или адресов) вычислительных комплексов в пространство их числовых адресов.<span class="keyword"></span> Эта проблема получила наименование <span class="keyword_def">проблемы разрешения адресов</span>. </p><div  class="lecture_mark" id="mark_67"></div><p  id="id_68">С подобными задачами мы уже сталкивались, обсуждая организацию памяти в вычислительных системах (отображение имен переменных в их адреса в процессе компиляции и редактирования связей) и организацию файловых систем (отображение имен файлов в их расположении на диске). Посмотрим, как она может быть решена в сетевом варианте.</p><div  class="lecture_mark" id="mark_68"></div><p  id="id_69">Первый способ решения заключается в том, что на каждом сетевом компьютере создается файл, содержащий имена всех машин, доступных по сети, и их числовые эквиваленты. Обращаясь к этому файлу, операционная система легко может перевести символьный <span class="keyword">удаленный адрес</span> в числовую форму. Такой подход использовался на заре эпохи глобальных сетей и применяется в изолированных локальных сетях в настоящее время. Действительно, легко поддерживать файл соответствий в корректном виде, внося в него необходимые изменения, когда общее число сетевых машин не превышает нескольких десятков. Как правило, изменения вносятся на некотором выделенном административном вычислительном комплексе, откуда затем обновленный файл рассылается по всем компонентам сети. </p><div  class="lecture_mark" id="mark_69"></div><p  id="id_70">В современной сетевой паутине этот подход является неприемлемым. Дело даже не в размерах подобного файла, а в частоте требуемых обновлений и в огромном количестве рассылок, что может полностью подорвать производительность сети. Проблема состоит в том, что добавление или удаление компонента сети требует внесения изменений в файлы на всех сетевых машинах. Второй метод разрешения адресов заключается в частичном распределении информации о соответствии символьных и числовых адресов по многим комплексам сети, так что каждый из этих комплексов содержит лишь часть полных данных. Он же определяет и правила построения символических имен компьютеров. </p><div  class="lecture_mark" id="mark_70"></div><p  id="id_71">Один из таких способов, используемый в Internet, получил английское наименование <span class="keyword">Domain Name Service</span> или сокращенно <span class="keyword">DNS</span>. Эта аббревиатура широко используется и в русскоязычной литературе. Давайте рассмотрим данный метод подробнее. </p><div  class="lecture_mark" id="mark_71"></div><p  id="id_72">Организуем логически все компьютеры сети в некоторую древовидную структуру, напоминающую структуру директорий файловых систем, в которых отсутствует возможность организации жестких и мягких связей и нет пустых директорий. Будем рассматривать все компьютеры, входящие во Всемирную сеть, как область самого низкого ранга (аналог корневой директории в файловой системе) – ранга 0. Разобьем все множество компьютеров области на какое-то количество подобластей (domains). При этом некоторые подобласти будут состоять из одного компьютера (аналоги регулярных файлов в файловых системах), а некоторые – более чем из одного компьютера (аналоги директорий в файловых системах). Каждую подобласть будем рассматривать как область более высокого ранга. Присвоим подобластям собственные имена таким образом, чтобы в рамках разбиваемой области все они были уникальны. Повторим такое разбиение рекурсивно для каждой области более высокого ранга, которая состоит более чем из одного компьютера, несколько раз, пока при последнем разбиении в каждой подобласти не окажется ровно по одному компьютеру. Глубина рекурсии для различных областей одного ранга может быть разной, но обычно в целом ограничиваются 3 – 5 разбиениями, начиная от ранга 0.</p><div  class="lecture_mark" id="mark_72"></div><p  id="id_73">В результате мы получим дерево, неименованной вершиной которого является область, объединяющая все компьютеры, входящие во Всемирную сеть, именованными терминальными узлами – отдельные компьютеры (точнее – подобласти, состоящие из отдельных компьютеров), а именованными нетерминальными узлами – области различных рангов. Используем полученную структуру для построения имен компьютеров, подобно тому как мы поступали при построении полных имен файлов в структуре директорий файловой системы. Только теперь, двигаясь от корневой вершины к терминальному узлу – отдельному компьютеру, будем вести запись имен подобластей справа налево и отделять имена друг от друга с помощью символа ".".</p><div  class="lecture_mark" id="mark_73"></div><p  id="id_74">Допустим, некоторая подобласть, состоящая из одного компьютера, получила имя <span class="texample">serv</span>, она входит в подобласть, объединяющую все компьютеры некоторой лаборатории, с именем <span class="texample">crec</span>. Та, в свою очередь, входит в подобласть всех компьютеров Московского физико-технического института с именем <span class="texample">mipt</span>, которая включается в область ранга 1 всех компьютеров России с именем <span class="texample">ru</span>. Тогда имя рассматриваемого компьютера во Всемирной сети будет <span class="texample">serv.crec.mipt.ru</span>. Аналогичным образом можно именовать и подобласти, состоящие более чем из одного компьютера.</p><div  class="lecture_mark" id="mark_74"></div><p  id="id_80">В каждой полученной именованной области, состоящей более чем из одного узла, выберем один из компьютеров и назначим его ответственным за эту область – сервером <span class="keyword">DNS</span>. Сервер <span class="keyword">DNS</span> знает числовые адреса серверов <span class="keyword">DNS</span> для подобластей, входящих в его зону ответственности, или числовые адреса отдельных компьютеров, если такая подобласть включает в себя только один компьютер. Кроме того, он также знает числовой адрес сервера <span class="keyword">DNS</span>, в зону ответственности которого входит рассматриваемая область (если это не область ранга 1), или числовые адреса всех серверов <span class="keyword">DNS</span> ранга 1 (в противном случае). Отдельные компьютеры всегда знают числовые адреса серверов <span class="keyword">DNS</span>, которые непосредственно за них отвечают.</p><div  class="lecture_mark" id="mark_80"></div><p  id="id_81">Рассмотрим теперь, как процесс на компьютере <span class="texample">serv.crec.mipt.ru</span> может узнать числовой адрес компьютера <span class="texample">ssp.brown.edu</span>. Для этого он обращается к своему <span class="keyword">DNS</span>-серверу, отвечающему за область <span class="texample">crec.mipt.ru</span>, и передает ему нужный адрес в символьном виде. Если этот <span class="keyword">DNS</span>-сервер не может сразу представить необходимый числовой адрес, он передает запрос <span class="keyword">DNS</span>-серверу, отвечающему за область <span class="texample">mipt.ru</span>. Если и тот не в силах самостоятельно справиться с проблемой, он перенаправляет запрос серверу <span class="keyword">DNS</span>, отвечающему за область 1-го ранга ru. Этот сервер может обратиться к серверу <span class="keyword">DNS</span>, обслуживающему область 1-го ранга <span class="texample">edu</span>, который, наконец, затребует информацию от сервера 
<span class="keyword">DNS</span> области <span class="texample">brown.edu</span>, где должен быть нужный числовой адрес. Полученный числовой адрес по всей цепи серверов <span class="keyword">DNS</span> в обратном порядке будет передан процессу, направившему запрос (см. <a href="">рис. 14.2</a>). </p><div  class="lecture_mark" id="mark_81"></div><p  align="left" id="id_88"><a name="image.14.2"></a><div><img src="14. Сети и сетевые операционные системы_files/14-20000.gif" alt="Пример разрешения имен с использованием DNS-серверов" width="551" height="302"></div><br><b>Рис. 14.2.</b> 
        Пример разрешения имен с использованием DNS-серверов</p><div  class="lecture_mark" id="mark_88"></div><p  id="id_89">В действительности, каждый сервер <span class="keyword">DNS</span> имеет достаточно большой кэш, содержащий адреса серверов <span class="keyword">DNS</span> для всех последних запросов. Поэтому реальная схема обычно существенно проще, из приведенной цепочки общения <span class="keyword">DNS</span>-серверов выпадают многие звенья за счет обращения напрямую.</p><div  class="lecture_mark" id="mark_89"></div><p  id="id_90">Рассмотренный способ разрешения адресов позволяет легко добавлять компьютеры в сеть и исключать их из сети, так как для этого необходимо внести изменения только на <span class="keyword">DNS</span>-сервере соответствующей области. </p><div  class="lecture_mark" id="mark_90"></div><p  id="id_91">Если <span class="keyword">DNS</span>-сервер, отвечающий за какую-либо область, выйдет из строя, то может оказаться невозможным разрешение адресов для всех компьютеров этой области. Поэтому обычно назначается не один сервер <span class="keyword">DNS</span>, а два – основной и запасной. В случае выхода из строя основного сервера его функции немедленно начинает выполнять запасной.</p><div  class="lecture_mark" id="mark_91"></div><p  id="id_92">В реальных сетевых вычислительных системах обычно используется комбинация рассмотренных подходов. Для компьютеров, с которыми чаще всего приходится устанавливать связь, в специальном файле хранится таблица соответствий символьных и числовых адресов. Все остальные адреса разрешаются с использованием служб, аналогичных службе <span class="keyword">DNS</span>. Способ построения <span class="keyword">удаленных адресов</span> и методы разрешения адресов обычно определяются <span class="keyword">протоколами</span>   <span class="keyword">сетевого уровня</span> эталонной модели.</p><div  class="lecture_mark" id="mark_92"></div><p  id="id_93">Мы разобрались с проблемой <span class="keyword">удаленных адресов</span> и знаем, как получить числовой <span class="keyword">удаленный адрес</span> нужного нам компьютера. Давайте рассмотрим теперь проблему <span class="keyword">адресов локальных</span>: как нам задать адрес процесса или объекта для хранения данных на удаленном компьютере, который в конечном итоге и должен получить переданную информацию.</p><div  class="lecture_mark" id="mark_93"></div><h4 >Локальная адресация. Понятие порта </h4><p  id="id_94">Во второй лекции мы говорили, что каждый процесс, существующий в данный момент в вычислительной системе, уже имеет собственный уникальный номер – PID. Но этот номер неудобно использовать в качестве <span class="keyword">локального адреса процесса</span> при организации удаленной связи. Номер, который получает процесс при рождении, определяется моментом его запуска, предысторией работы вычислительного комплекса и является в значительной степени случайным числом, изменяющимся от запуска к запуску. Представьте себе, что адресат, с которым вы часто переписываетесь, постоянно переезжает с место на место, меняя адреса, так что, посылая очередное письмо, вы не можете с уверенностью сказать, где он сейчас проживает, и поймете все неудобство использования идентификатора процесса в качестве его <span class="keyword">локального адреса</span>. Все сказанное выше справедливо и для идентификаторов промежуточных объектов, использующихся при локальном взаимодействии процессов в 
схемах с непрямой адресацией.</p><div  class="lecture_mark" id="mark_94"></div><p  id="id_95">Для <span class="keyword">локальной адресации процессов</span> и промежуточных объектов при удаленной связи обычно организуется новое специальное адресное пространство, например представляющее собой ограниченный набор положительных целочисленных значений или множество символических имен, аналогичных полным именам файлов в файловых системах. Каждый процесс, желающий принять участие в сетевом взаимодействии, после рождения закрепляет за собой один или несколько адресов в этом адресном пространстве. Каждому промежуточному объекту при его создании присваивается свой адрес из этого адресного пространства. При этом удаленные пользователи могут заранее договориться о том, какие именно адреса будут зарезервированы для данного процесса, независимо от времени его старта, или для данного объекта, независимо от момента его создания. Подобные адреса получили название портов, по аналогии с портами ввода-вывода.</p><div  class="lecture_mark" id="mark_95"></div><p  id="id_96">Необходимо отметить, что в системе может существовать несколько таких адресных пространств для различных способов связи. При получении данных от <span class="keyword">удаленного процесса</span> операционная система смотрит, на какой порт и для какого способа связи они были отправлены, определяет процесс, который заявил этот порт в качестве своего адреса, или объект, которому присвоен данный адрес, и доставляет полученную информацию адресату. Виды адресного пространства портов (т. е. способы построения <span class="keyword">локальных адресов</span>) определяются, как правило, <span class="keyword">протоколами</span>   <span class="keyword">транспортного уровня</span> эталонной модели.</p><div  class="lecture_mark" id="mark_96"></div><h4 >Полные адреса. Понятие сокета (socket) </h4><p  id="id_97">Таким образом, <a name="keyword-context.11"></a>полный адрес <span class="keyword">удаленного процесса</span> или промежуточного объекта для конкретного способа связи с точки зрения операционных систем определяется парой адресов: &lt;числовой адрес компьютера в сети, порт&gt;. Подобная пара получила наименование <span class="keyword_def">socket</span> (в переводе – "гнездо" или, как стали писать в последнее время, <span class="keyword">сокет</span>), а сам способ их использования – <b>организация связи с помощью</b>   <span class="keyword">сокетов</span>. В случае непрямой адресации с использованием промежуточных объектов сами эти объекты также принято называть <span class="keyword">сокетами</span>. Поскольку разные <span class="keyword">протоколы</span>   <span class="keyword">транспортного уровня</span> требуют разных адресных пространств портов, то для каждой пары надо указывать, какой транспортный <span class="keyword">протокол</span> 
она использует, – говорят о разных типах <span class="keyword">сокетов</span>.</p><div  class="lecture_mark" id="mark_97"></div><p  id="id_98">В современных сетевых системах числовой адрес обычно получает не сам вычислительный комплекс, а его сетевой адаптер, с помощью которого комплекс подключается к линии связи. При наличии нескольких сетевых адаптеров для разных линий связи один и тот же вычислительный комплекс может иметь несколько числовых адресов. В таких системах полные адреса удаленного адресата (процесса или промежуточного объекта) задаются парами &lt;числовой адрес сетевого адаптера, порт&gt; и требуют доставки информации через указанный сетевой адаптер.</p><div  class="lecture_mark" id="mark_98"></div><h3 >Проблемы маршрутизации в сетях </h3><p  id="id_99">При наличии прямой линии связи между двумя компьютерами обычно не возникает вопросов о том, каким именно путем должна быть доставлена информация. Но, как уже упоминалось, одно из отличий <span class="keyword">взаимодействия удаленных процессов</span> от взаимодействия процессов локальных состоит в использовании в большинстве случаев процессов-посредников, расположенных на вычислительных комплексах, не являющихся комплексами отправителя и получателя. В сложных топологических схемах организации сетей информация между двумя компьютерами может передаваться по различным путям. Возникает вопрос: как организовать работу операционных систем на комплексах -участниках связи (это могут быть конечные или промежуточные комплексы) для определения маршрута передачи данных? По какой из нескольких линий связи (или через какой сетевой адаптер) нужно отправить пакет информации? Какие <span class="keyword">протоколы</span> маршрутизации возможны? Существует два принципиально разных подхода
 к решению этой проблемы: <span class="keyword">маршрутизация от источника передачи данных</span> и <span class="keyword">одношаговая маршрутизация</span>.</p><div  class="lecture_mark" id="mark_99"></div><ul  id="id_100"><li><span class="keyword">Маршрутизация от источника передачи данных</span>. <a name="keyword-context.12"></a>При <span class="keyword_def">маршрутизации от источника данных</span> полный маршрут передачи пакета по сети формируется на компьютере-отправителе в виде последовательности числовых адресов сетевых адаптеров, через которые должен пройти пакет, чтобы добраться до компьютера-получателя, и целиком включается в состав этого пакета. В этом случае промежуточные компоненты сети при определении дальнейшего направления движения пакета не принимают самостоятельно никаких решений, а следуют указаниям, содержащимся в пакете. </li><li><span class="keyword">Одношаговая маршрутизация</span>. <a name="keyword-context.13"></a>При <span class="keyword_def">одношаговой маршрутизации</span> каждый компонент сети, принимающий участие в передаче информации, самостоятельно определяет, какому следующему компоненту, находящемуся в зоне прямого доступа, она должна быть отправлена. Решение принимается на основании анализа содержащегося в пакете адреса получателя. Полный маршрут передачи данных складывается из одношаговых решений, принятых компонентами сети. </li></ul><div  class="lecture_mark" id="mark_100"></div><p  id="id_103"><span class="keyword">Маршрутизация от источника передачи данных</span> легко реализуется на промежуточных компонентах сети, но требует полного знания маршрутов на конечных компонентах. Она достаточно редко используется в современных сетевых системах, и далее мы ее рассматривать не будем.</p><div  class="lecture_mark" id="mark_103"></div><p  id="id_104">Для работы <span class="keyword">алгоритмов</span>   <span class="keyword">одношаговой маршрутизации</span>, которые являются основой соответствующих <span class="keyword">протоколов</span>, на каждом компоненте сети, имеющем возможность передавать информацию более чем одному компоненту, обычно строится специальная таблица маршрутов (см. <a href="">рис. 14.3</a>). В простейшем случае каждая запись такой таблицы содержит: адрес вычислительного комплекса получателя; адрес компонента сети, напрямую подсоединенного к данному, которому следует отправить пакет, предназначенный для этого получателя; указание о том, по какой линии связи (через какой сетевой адаптер) должен быть отправлен пакет. Поскольку получателей в сети существует огромное количество, для сокращения числа записей в <span class="keyword">таблице маршрутизации</span> обычно прибегают к двум специальным приемам. </p><div  class="lecture_mark" id="mark_104"></div><p  id="id_105">Во-первых, числовые адреса топологически близко расположенных комплексов (например, комплексов, принадлежащих одной локальной <span class="keyword">вычислительной сети</span>) стараются выбирать из последовательного диапазона адресов. В этом случае запись в <span class="keyword">таблице маршрутизации</span> может содержать не адрес конкретного получателя, а диапазон адресов для некоторой сети (номер сети). </p><div  class="lecture_mark" id="mark_105"></div><p  id="id_106">Во-вторых, если для очень многих получателей в качестве очередного узла маршрута используется один и тот же компонент сети, а остальные маршруты выбираются для ограниченного числа получателей, то в таблицу явно заносятся только записи для этого небольшого количества получателей, а для маршрута, ведущего к большей части всей сети, делается одна запись – маршрутизация по умолчанию (default). Пример простой <span class="keyword">таблицы маршрутизации</span> для некоторого комплекса некой абстрактной сети приведен ниже:</p><div  class="lecture_mark" id="mark_106"></div><p  align="left" id="id_107"><a name="image.14.3"></a><div><img src="14. Сети и сетевые операционные системы_files/14-30000.gif" alt="Простая таблица маршрутизации" width="550" height="160"></div><br><b>Рис. 14.3.</b> 
        Простая таблица маршрутизации</p><div  class="lecture_mark" id="mark_107"></div><p  id="id_108">По способам формирования и использования <span class="keyword">таблиц маршрутизации</span>   <span class="keyword">алгоритмы</span>   <span class="keyword">одношаговой маршрутизации</span> можно разделить на три класса: </p><div  class="lecture_mark" id="mark_108"></div><ul  id="id_109"><li><span class="keyword">алгоритмы</span>   <span class="keyword">фиксированной маршрутизации</span>;</li><li><span class="keyword">алгоритмы</span>   <span class="keyword">простой маршрутизации</span>;</li><li><span class="keyword">алгоритмы</span>   <span class="keyword">динамической маршрутизации</span>.</li></ul><div  class="lecture_mark" id="mark_109"></div><p  id="id_113"><a name="keyword-context.14"></a>При <span class="keyword_def">фиксированной маршрутизации</span> таблица, как правило, создается в процессе загрузки операционной системы. Все записи в ней являются статическими. Линия связи, которая будет использоваться для доставки информации от данного узла к некоторому узлу A в сети, выбирается раз и навсегда. Обычно линии выбирают так, чтобы минимизировать полное время доставки данных. Преимуществом этой стратегии является простота реализации. Основной же недостаток заключается в том, что при отказе выбранной линии связи данные не будут доставлены, даже если существует другой физический путь для их передачи. </p><div  class="lecture_mark" id="mark_113"></div><p  id="id_114"><a name="keyword-context.15"></a>В <span class="keyword">алгоритмах</span>   <span class="keyword_def">простой маршрутизации</span> таблица либо не используется совсем, либо строится на основе анализа адресов отправителей приходящих пакетов информации. Различают несколько видов <span class="keyword">простой маршрутизации</span> – <b>случайную</b>, <b>лавинную</b> и <b>маршрутизацию по прецедентам</b>. При случайной маршрутизации прибывший пакет отсылается в первом попавшемся направлении, кроме исходного. При лавинной маршрутизации один и тот же пакет рассылается по всем направлениям, кроме исходного. Случайная и лавинная маршрутизации, естественно, не используют таблиц маршрутов. При маршрутизации по прецедентам <span class="keyword">таблица маршрутизации</span> строится по предыдущему опыту, исходя из анализа адресов отправителей приходящих пакетов. Если прибывший пакет адресован компоненту сети, от которого когда-либо приходили данные, то соответствующая запись об этом содержится в таблице маршрутов, и для дальнейшей передачи пакета выбирается линия связи, указанная в таблице. Если такой записи нет, то пакет может быть отослан случайным или лавинным способом. <span class="keyword">Алгоритмы</span>   <span class="keyword">простой маршрутизации</span> действительно просты в реализации, но отнюдь не гарантируют доставку пакета указанному адресату за приемлемое время и по рациональному маршруту без перегрузки сети. </p><div  class="lecture_mark" id="mark_114"></div><p  id="id_115">Наиболее гибкими являются <span class="keyword">алгоритмы</span>   <span class="keyword">динамической</span> или <b>адаптивной маршрутизации</b>, которые умеют обновлять содержимое таблиц маршрутов на основе обработки специальных сообщений, приходящих от других компонентов сети, занимающихся маршрутизацией, удовлетворяющих определенному <span class="keyword">протоколу</span>. Такие <span class="keyword">алгоритмы</span> принято делить на два подкласса: <span class="keyword">алгоритмы дистанционно-векторные</span> и <span class="keyword">алгоритмы состояния связей</span>. </p><div  class="lecture_mark" id="mark_115"></div><p  id="id_116"><a name="keyword-context.16"></a>При <span class="keyword_def">дистанционно-векторной маршрутизации</span> компоненты операционных систем на соседних вычислительных комплексах сети, занимающиеся выбором маршрута (их принято называть <span class="keyword">маршрутизатор</span> или <b>router</b>), периодически обмениваются векторами, которые представляют собой информацию о расстояниях от данного компонента до всех известных ему адресатов в сети. Под расстоянием обычно понимается количество переходов между компонентами сети (<b>hops</b>), которые необходимо сделать, чтобы достичь адресата, хотя возможно существование и других метрик, включающих скорость и/или стоимость передачи пакета по линии связи. Каждый такой вектор формируется на основании таблицы маршрутов. Пришедшие от других комплексов векторы модернизируются с учетом расстояния, которое они прошли при последней передаче. Затем в <span class="keyword">таблицу маршрутизации</span> вносятся изменения, так чтобы в ней содержались только маршруты с кратчайшими расстояниями. При достаточно длительной работе каждый <span class="keyword">маршрутизатор</span> будет иметь <span class="keyword">таблицу маршрутизации</span> с оптимальными маршрутами ко всем потенциальным адресатам.</p><div  class="lecture_mark" id="mark_116"></div><p  id="id_117">Векторно-дистанционные <span class="keyword">протоколы</span> обеспечивают достаточно разумную маршрутизацию пакетов, но не способны предотвратить возможность возникновения маршрутных петель при сбоях в работе сети. Поэтому векторно-дистанционная маршрутизация может быть эффективна только в относительно небольших сетях. Для больших сетей применяются <span class="keyword">алгоритмы состояния связей</span>, на каждом <span class="keyword">маршрутизаторе</span> строящие графы сети, в качестве узлов которого выступают ее компоненты, а в качестве ребер, обладающих стоимостью, существующие между ними линии связи. <span class="keyword">Маршрутизаторы</span> периодически обмениваются графами и вносят в них изменения. Выбор маршрута связан с поиском оптимального по стоимости пути по такому графу. </p><div  class="lecture_mark" id="mark_117"></div><p  id="id_118">Подробное описание <span class="keyword">протоколов</span>   <span class="keyword">динамической маршрутизации</span> можно найти в [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#24">Олифер, 2002</a>], [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#31">Таненбаум, 2003</a>].</p><div  class="lecture_mark" id="mark_118"></div><p  id="id_119">Обычно <span class="keyword">вычислительные сети</span> используют смесь различных стратегий маршрутизации. Для одних адресов назначения может использоваться <span class="keyword">фиксированная маршрутизация</span>, для других – <span class="keyword">простая</span>, для третьих – <span class="keyword">динамическая</span>. В локальных <span class="keyword">вычислительных сетях</span> обычно используются <span class="keyword">алгоритмы</span>   <span class="keyword">фиксированной маршрутизации</span>, в отличие от глобальных <span class="keyword">вычислительных сетей</span>, в которых в основном применяют <span class="keyword">алгоритмы</span> адаптивной маршрутизации. <span class="keyword">Протоколы</span> маршрутизации относятся к <span class="keyword">сетевому уровню</span> эталонной модели.</p><div  class="lecture_mark" id="mark_119"></div><h3 >Связь с установлением логического соединения
 и передача данных с помощью сообщений </h3><p  id="id_120">Рассказывая об отличиях взаимодействия <span class="keyword">локальных</span> и <span class="keyword">удаленных процессов</span>, мы упомянули, что в основе всех средств связи на автономном компьютере так или иначе лежит механизм совместного использования памяти, в то время как в основе всех средств связи между <span class="keyword">удаленными процессами</span> лежит передача сообщений. Неудивительно, что количество категорий средств удаленной связи сокращается до одной – канальных средств связи. Обеспечивать интерфейс для сигнальных средств связи и разделяемой памяти, базируясь на передаче пакетов данных, становится слишком сложно и дорого. </p><div  class="lecture_mark" id="mark_120"></div><p  id="id_121">Рассматривая канальные средства связи для <span class="keyword">локальных процессов</span> в лекции 4, мы говорили о существовании двух моделей передачи данных по каналам связи (теперь мы можем говорить о двух принципиально разных видах <span class="keyword">протоколов</span> организации канальной связи): поток ввода-вывода и сообщения. Для общения <span class="keyword">удаленных процессов</span> применяются обе модели, однако теперь уже более простой моделью становится передача информации с помощью сообщений. Реализация различных моделей происходит на основе <span class="keyword">протоколов</span>   <span class="keyword">транспортного уровня</span>   <span class="keyword">OSI/ISO</span>.</p><div  class="lecture_mark" id="mark_121"></div><p  id="id_122"><a name="keyword-context.17"></a>Транспортные <span class="keyword">протоколы</span> связи <span class="keyword">удаленных процессов</span>, которые предназначены для обмена сообщениями, получили наименование <span class="keyword">протоколов</span>   <b>без установления логического соединения (connectionless)</b> или <span class="keyword">протоколов</span>   <b>обмена</b>   <span class="keyword">датаграммами</span>, поскольку само сообщение здесь принято называть <span class="keyword_def">датаграммой</span> (<b>datagramm</b>) или <b>дейтаграммой</b>. Каждое сообщение адресуется и посылается процессом индивидуально. С точки зрения операционных систем все <span class="keyword">датаграммы</span> – это независимые единицы, не имеющие ничего общего с другими <span class="keyword">датаграммами</span>, которыми обмениваются эти же процессы.</p><div  class="lecture_mark" id="mark_122"></div><p  id="id_123">Необходимо отметить, что с точки зрения процессов, обменивающихся информацией, <span class="keyword">датаграммы</span>, конечно, могут быть связаны по содержанию друг с другом, но ответственность за установление и поддержание этой семантической связи лежит не на сетевых частях операционных систем, а на самих пользовательских взаимодействующих процессах (вышележащие уровни эталонной модели). </p><div  class="lecture_mark" id="mark_123"></div><p  id="id_124">По-другому обстоит дело с транспортными <span class="keyword">протоколами</span>, которые поддерживают потоковую модель. Они получили наименование <span class="keyword">протоколов</span>, <b>требующих установления логического соединения (connection-oriented)</b>. И в их основе лежит передача данных с помощью пакетов информации. Но операционные системы сами нарезают эти пакеты из передаваемого потока данных, организовывают правильную последовательность их получения и снова объединяют полученные пакеты в поток, так что с точки зрения взаимодействующих процессов после установления логического соединения они имеют дело с потоковым средством связи, напоминающим pipe или FIFO. Эти <span class="keyword">протоколы</span> должны обеспечивать надежную связь.</p><div  class="lecture_mark" id="mark_124"></div><h3 >Синхронизация удаленных процессов </h3><p  id="id_125">Мы рассмотрели основные принципы логической организации сетевых средств связи, внешние по отношению к взаимодействующим процессам. Однако, как отмечалось в лекции 5, для корректной работы таких процессов необходимо обеспечить определенную их синхронизацию, которая устранила бы возникновение race condition на соответствующих критических участках. Вопросы синхронизации <span class="keyword">удаленных процессов</span> обычно рассматриваются в курсах, посвященных <span class="keyword">распределенным операционным системам</span>. Интересующиеся этими вопросами могут обратиться к книгам [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#8">Silberschatz, 2002</a>], [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#32">Таненбаум II, 2003</a>].</p><div  class="lecture_mark" id="mark_125"></div><h3 >Заключение</h3><p  id="id_126">Основными причинами объединения компьютеров в <span class="keyword">вычислительные сети</span> являются потребности в разделении ресурсов, ускорении вычислений, повышении надежности и облегчении общения пользователей.</p><div  class="lecture_mark" id="mark_126"></div><p  id="id_127">Вычислительные комплексы в сети могут находиться под управлением сетевых или распределенных вычислительных систем. Основой для объединения компьютеров в сеть служит <span class="keyword">взаимодействие удаленных процессов</span>. При рассмотрении вопросов организации <span class="keyword">взаимодействия удаленных процессов</span> нужно принимать во внимание основные отличия их кооперации от кооперации <span class="keyword">локальных процессов</span>. </p><div  class="lecture_mark" id="mark_127"></div><p  id="id_128">Базой для взаимодействия <span class="keyword">локальных процессов</span> служит организация общей памяти, в то время как для <span class="keyword">удаленных процессов</span> – это обмен физическими пакетами данных. </p><div  class="lecture_mark" id="mark_128"></div><p  id="id_129">Организация <span class="keyword">взаимодействия удаленных процессов</span> требует от сетевых частей операционных систем поддержки определенных <span class="keyword">протоколов</span>. Сетевые средства связи обычно строятся по "слоеному" принципу. Формальный перечень правил, определяющих последовательность и формат сообщений, которыми обмениваются сетевые компоненты различных вычислительных систем, лежащие на одном уровне, называется <span class="keyword">сетевым протоколом</span>. Каждый уровень слоеной системы может взаимодействовать непосредственно только со своими вертикальными соседями, руководствуясь четко закрепленными соглашениями – вертикальными <span class="keyword">протоколами</span> или интерфейсами. Вся совокупность интерфейсов и <span class="keyword">сетевых протоколов</span> в сетевых системах, построенных по слоеному принципу, достаточная для организации <span class="keyword">взаимодействия удаленных процессов</span>, образует <b>семейство</b>   <span class="keyword">протоколов</span> или <b>стек</b>   <span class="keyword">протоколов</span>.</p><div  class="lecture_mark" id="mark_129"></div><p  id="id_130"><span class="keyword">Удаленные процессы</span>, в отличие от локальных, при взаимодействии обычно требуют двухуровневой адресации при своем общении. Полный адрес процесса состоит из двух частей: <span class="keyword">удаленной</span> и <span class="keyword">локальной</span>. </p><div  class="lecture_mark" id="mark_130"></div><p  id="id_131">Для удаленной адресации используются символьные и числовые имена узлов сети. Перевод имен из одной формы в другую (разрешение имен) может осуществляться с помощью централизованно обновляемых таблиц соответствия полностью на каждом узле или с использованием выделения зон ответственности специальных серверов. Для <span class="keyword">локальной адресации процессов</span> применяются порты. Упорядоченная пара из адреса узла в сети и порта получила название <span class="keyword">socket</span>.</p><div  class="lecture_mark" id="mark_131"></div><p  id="id_132">Для доставки сообщения от одного узла к другому могут использоваться различные <span class="keyword">протоколы</span> маршрутизации.</p><div  class="lecture_mark" id="mark_132"></div><p  id="id_133">С точки зрения пользовательских процессов обмен информацией может осуществляться в виде <span class="keyword">датаграмм</span> или потока данных.</p><div  class="lecture_mark" id="mark_133"></div>


	</td>
	</tr>
	<tr><td height="8"><img src="14. Сети и сетевые операционные системы_files/empty000.gif" width="1" height="8"></td></tr>
	</table>
	<!-- /content -->

</td>
<td><img src="14. Сети и сетевые операционные системы_files/empty000.gif" width="8" height="1"></td>
</tr>
</table>
<!-- /bottom -->
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td class="orang" height="1"><img src="14. Сети и сетевые операционные системы_files/empty000.gif" width="1" height="1"></td></tr>
<td class="ltxt" align=center>&copy; INTUIT.ru, 2003-2008. Все права защищены.</td>
</tr>
</table>
<!-- /bottom -->

<script src="14. Сети и сетевые операционные системы_files/urchin00.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-3475067-1";
urchinTracker();
</script></body>
</html>


<!-- This document saved from http://www.intuit.ru/department/os/osintro/14/osintro_14.html -->
