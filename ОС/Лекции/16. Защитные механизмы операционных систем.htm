<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>INTUIT.ru::Интернет-Университет Информационных Технологий</title>
<link href="16. Защитные механизмы операционных систем_files/printabl.css" type="text/css" rel="stylesheet">
</head>
<body leftmargin="6" topmargin="6" marginheight="6" marginwidth="6">


<div align="left">
<span style="color: #000000; font-weight: bold;">
&nbsp;&nbsp;
<span style="font-size:12pt;">Интернет-Университет Информационных Технологий</span>
</span>
</div>

&nbsp;&nbsp;
<span align="rright" style="color: #330066; text-decoration:underline;">http://www.INTUIT.ru</span>


<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td height="8" colspan=3><img src="16. Защитные механизмы операционных систем_files/empty000.gif" width="1" height="8"></td></tr>
<tr><td class="orang" height="1" colspan=3><img src="16. Защитные механизмы операционных систем_files/empty000.gif" width="1" height="1"></td></tr>
<tr><td height="8" colspan=3><img src="16. Защитные механизмы операционных систем_files/empty000.gif" width="1" height="8"></td></tr>
<tr valign="top">
<td><img src="16. Защитные механизмы операционных систем_files/empty000.gif" width="8" height="1"></td>
<td>
	<!-- content -->
	<table border="0" cellpadding="0" cellspacing="0" width="100%">
	<tr><td class="head">Основы операционных систем</td></tr>
<tr><td height="4"><img src="16. Защитные механизмы операционных систем_files/empty000.gif" width="1" height="4"></td></tr>
	<tr><td class="orang" height="1"><img src="16. Защитные механизмы операционных систем_files/empty000.gif" width="1" height="1"></td></tr>
	<tr><td height="8"><img src="16. Защитные механизмы операционных систем_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td><span class="headsub">


16. Лекция:

 Защитные механизмы операционных систем: версия для печати и PDA</span>

<br>
<span class="rtxt">Решение вопросов безопасности операционных систем обусловлено их архитектурными особенностями и связано с правильной организацией идентификации и аутентификации, авторизации и аудита.
</span>

</td></tr>

	<tr><td height="8"><img src="16. Защитные механизмы операционных систем_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td class="orang" height="1"><img src="16. Защитные механизмы операционных систем_files/empty000.gif" width="1" height="1"></td></tr>
	<tr><td height="8"><img src="16. Защитные механизмы операционных систем_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td>


<h3 ></h3><p  id="id_1">Перейдем к описанию системы защиты операционных систем. Ее основными задачами являются <span class="keyword">идентификация</span>, <span class="keyword">аутентификация</span>, разграничение доступа пользователей к ресурсам, протоколирование и <span class="keyword">аудит</span> самой системы. Более подробную информацию об этом можно найти в [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#16">Дейтел, 1987</a>], [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#29">Столлингс, 2001</a>], [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#30">Таненбаум, 2002</a>] и ряде других источников.</p><div  class="lecture_mark" id="mark_1"></div><h3 >Идентификация и аутентификация </h3><p  id="id_2">Для начала рассмотрим проблему контроля доступа в систему. Наиболее распространенным способом контроля доступа является процедура регистрации. Обычно каждый пользователь в системе имеет уникальный идентификатор. Идентификаторы пользователей применяются с той же целью, что и идентификаторы любых других объектов, файлов, процессов. <span class="keyword">Идентификация</span> заключается в сообщении пользователем своего идентификатора. Для того чтобы установить, что пользователь именно тот, за кого себя выдает, то есть что именно ему принадлежит введенный идентификатор, в информационных системах предусмотрена процедура <span class="keyword">аутентификации</span> (authentication, опознавание, в переводе с латинского означает "установление подлинности"), задача которой - предотвращение доступа к системе нежелательных лиц.</p><div  class="lecture_mark" id="mark_2"></div><p  id="id_3">Обычно <span class="keyword">аутентификация</span> базируется на одном или более из трех пунктов:</p><div  class="lecture_mark" id="mark_3"></div><ul  id="id_4"><li>то, чем пользователь владеет (ключ или магнитная карта);</li><li>то, что пользователь знает (пароль);</li><li>атрибуты пользователя (отпечатки пальцев, подпись, голос).</li></ul><div  class="lecture_mark" id="mark_4"></div><h4 >Пароли, уязвимость паролей</h4><p  id="id_8">Наиболее простой подход к <span class="keyword">аутентификации</span> - применение пользовательского пароля.</p><div  class="lecture_mark" id="mark_8"></div><p  id="id_9">Когда пользователь идентифицирует себя при помощи уникального идентификатора или имени, у него запрашивается пароль. Если пароль, сообщенный пользователем, совпадает с паролем, хранящимся в системе, система предполагает, что пользователь легитимен. Пароли часто используются для защиты объектов в компьютерной системе в отсутствие более сложных схем защиты.</p><div  class="lecture_mark" id="mark_9"></div><p  id="id_10">Недостатки паролей связаны с тем, что трудно сохранить баланс между удобством пароля для пользователя и его надежностью. Пароли могут быть угаданы, случайно показаны или нелегально переданы авторизованным пользователем неавторизованному.</p><div  class="lecture_mark" id="mark_10"></div><p  id="id_11">Есть два общих способа угадать пароль. Один связан со сбором информации о пользователе. Люди обычно используют в качестве паролей очевидную информацию (скажем, имена животных или номерные знаки автомобилей). Для иллюстрации важности разумной политики назначения идентификаторов и паролей можно привести данные исследований, проведенных в AT&amp;T, показывающие, что из 500 попыток несанкционированного доступа около 300 составляют попытки угадывания паролей или беспарольного входа по пользовательским именам guest, demo и т. д.</p><div  class="lecture_mark" id="mark_11"></div><p  id="id_12">Другой способ - попытаться перебрать все наиболее вероятные комбинации букв, чисел и знаков пунктуации (атака по словарю). Например, четыре десятичные цифры дают только 10 000 вариантов, более длинные пароли, введенные с учетом регистра символов и пунктуации, не столь уязвимы, но тем не менее таким способом удается разгадать до 25% паролей. Чтобы заставить пользователя выбрать трудноугадываемый пароль, во многих системах внедрена реактивная проверка паролей, которая при помощи собственной программы-взломщика паролей может оценить качество пароля, введенного пользователем.</p><div  class="lecture_mark" id="mark_12"></div><p  id="id_13">Несмотря на все это, пароли распространены, поскольку они удобны и легко реализуемы.</p><div  class="lecture_mark" id="mark_13"></div><h5 >Шифрование пароля</h5><p  id="id_14">Для хранения секретного списка паролей на диске во многих ОС используется криптография. Система задействует одностороннюю функцию, которую просто вычислить, но для которой чрезвычайно трудно (разработчики надеются, что невозможно) подобрать обратную функцию.</p><div  class="lecture_mark" id="mark_14"></div><p  id="id_15">Например, в ряде версий Unix в качестве односторонней функции используется модифицированный вариант алгоритма DES. Введенный пароль длиной до 8 знаков преобразуется в 56-битовое значение, которое служит входным параметром для процедуры crypt(), основанной на этом алгоритме. Результат шифрования зависит не только от введенного пароля, но и от случайной последовательности битов, называемой привязкой (переменная salt). Это сделано для того, чтобы решить проблему совпадающих паролей. Очевидно, что саму привязку после шифрования необходимо сохранять, иначе процесс не удастся повторить. Модифицированный алгоритм DES выполняется, имея входное значение в виде 64-битового блока нулей, с использованием пароля в качестве ключа, а на каждой следующей итерации входным параметром служит результат предыдущей итерации. Всего процедура повторяется 25 раз. Полученное 64-битовое значение преобразуется в 11 символов и хранится рядом с открытой переменной salt.</p><div  class="lecture_mark" id="mark_15"></div><p  id="id_16">В ОС Windows NT преобразование исходного пароля также осуществляется многократным применением алгоритма DES и алгоритма MD4.</p><div  class="lecture_mark" id="mark_16"></div><p  id="id_17">Хранятся только кодированные пароли. В процессе <span class="keyword">аутентификации</span> представленный пользователем пароль кодируется и сравнивается с хранящимися на диске. Таким образом, файл паролей нет необходимости держать в секрете.</p><div  class="lecture_mark" id="mark_17"></div><p  id="id_18">При удаленном доступе к ОС нежелательна передача пароля по сети в открытом виде. Одним из типовых решений является использование криптографических протоколов. В качестве примера можно рассмотреть протокол опознавания с подтверждением установления связи путем вызова - CHAP (Challenge Handshake Authentication Protocol).</p><div  class="lecture_mark" id="mark_18"></div><p  id="id_19">Опознавание достигается за счет проверки того, что у пользователя, осуществляющего доступ к серверу, имеется секретный пароль, который уже известен серверу.</p><div  class="lecture_mark" id="mark_19"></div><p  id="id_20">Пользователь инициирует диалог, передавая серверу свой идентификатор. В ответ сервер посылает пользователю запрос (вызов), состоящий из идентифицирующего кода, случайного числа и имени узла сервера или имени пользователя. При этом пользовательское оборудование в результате запроса пароля пользователя отвечает следующим ответом, зашифрованным с помощью алгоритма одностороннего хеширования, наиболее распространенным видом которого является MD5. После получения ответа сервер при помощи той же функции с теми же аргументами шифрует собственную версию пароля пользователя. В случае совпадения результатов вход в систему разрешается. Существенно, что незашифрованный пароль при этом по каналу связи не посылается.</p><div  class="lecture_mark" id="mark_20"></div><p  id="id_21">В микротелефонных трубках используется аналогичный метод.</p><div  class="lecture_mark" id="mark_21"></div><p  id="id_22">В системах, работающих с большим количеством пользователей, когда хранение всех паролей затруднительно, применяются для опознавания сертификаты, выданные доверенной стороной (см., например, [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#29">Столлингс, 2001</a>]).</p><div  class="lecture_mark" id="mark_22"></div><h3 >Авторизация. Разграничение доступа к объектам ОС</h3><p  id="id_23">После успешной регистрации система должна осуществлять авторизацию (authorization) - предоставление субъекту прав на доступ к объекту. Средства авторизации контролируют доступ легальных пользователей к ресурсам системы, предоставляя каждому из них именно те права, которые были определены администратором, а также осуществляют контроль возможности выполнения пользователем различных системных функций. Система контроля базируется на общей модели, называемой <span class="keyword">матрицей доступа</span>. Рассмотрим ее более подробно.</p><div  class="lecture_mark" id="mark_23"></div><p  id="id_24">Как уже говорилось в предыдущей лекции, компьютерная система может быть смоделирована как набор субъектов (процессы, пользователи) и объектов. Под объектами мы понимаем как ресурсы оборудования (процессор, сегменты памяти, принтер, диски и ленты), так и программные ресурсы (файлы, программы, семафоры), то есть все то, доступ к чему контролируется. Каждый объект имеет уникальное имя, отличающее его от других объектов в системе, и каждый из них может быть доступен через хорошо определенные и значимые операции.</p><div  class="lecture_mark" id="mark_24"></div><p  id="id_25">Операции зависят от объектов. Hапример, процессор может только выполнять команды, сегменты памяти могут быть записаны и прочитаны, считыватель магнитных карт может только читать, а файлы данных могут быть записаны, прочитаны, переименованы и т. д.</p><div  class="lecture_mark" id="mark_25"></div><p  id="id_26">Желательно добиться того, чтобы процесс осуществлял авторизованный доступ только к тем ресурсам, которые ему нужны для выполнения его задачи. Это требование минимума привилегий, уже упомянутое в предыдущей лекции, полезно с точки зрения ограничения количества повреждений, которые процесс может нанести системе. Hапример, когда процесс P вызывает процедуру А, ей должен быть разрешен доступ только к переменным и формальным параметрам, переданным ей, она не должна иметь возможность влиять на другие переменные процесса. Аналогично компилятор не должен оказывать влияния на произвольные файлы, а только на их хорошо определенное подмножество (исходные файлы, листинги и др.), имеющее отношение к компиляции. С другой стороны, компилятор может иметь личные файлы, используемые для оптимизационных целей, к которым процесс Р не имеет доступа.</p><div  class="lecture_mark" id="mark_26"></div><p  id="id_27">Различают <span class="keyword">дискреционный</span> (избирательный) способ управления доступом и <span class="keyword">полномочный</span> (мандатный). </p><div  class="lecture_mark" id="mark_27"></div><p  id="id_28">При <span class="keyword">дискреционном доступе</span>, подробно рассмотренном ниже, определенные операции над конкретным ресурсом запрещаются или разрешаются субъектам или группам субъектов. С концептуальной точки зрения текущее состояние прав доступа при дискреционном управлении описывается матрицей, в строках которой перечислены субъекты, в столбцах - объекты, а в ячейках - операции, которые субъект может выполнить над объектом.</p><div  class="lecture_mark" id="mark_28"></div><p  id="id_29"><a name="keyword-context.1"></a><span class="keyword_def">Полномочный</span> подход заключается в том, что все объекты могут иметь уровни секретности, а все субъекты делятся на группы, образующие иерархию в соответствии с уровнем допуска к информации. Иногда это называют моделью многоуровневой безопасности, которая должна обеспечивать выполнение следующих правил.</p><div  class="lecture_mark" id="mark_29"></div><ul  id="id_30"><li>Простое свойство секретности. Субъект может читать информацию только из объекта, уровень секретности которого не выше уровня секретности субъекта. Генерал читает документы лейтенанта, но не наоборот.</li><li>*-свойство. Субъект может записывать информацию в объекты только своего уровня или более высоких уровней секретности. Генерал не может случайно разгласить нижним чинам секретную информацию.</li></ul><div  class="lecture_mark" id="mark_30"></div><p  id="id_33">Некоторые авторы утверждают [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#30">Таненбаум, 2002</a>], что последнее требование называют *-свойством, потому что в оригинальном докладе не смогли придумать для него подходящего названия. В итоге во все последующие документы и монографии оно вошло как *-свойство.</p><div  class="lecture_mark" id="mark_33"></div><p  id="id_34">Отметим, что данная модель разработана для хранения секретов, но не гарантирует целостности данных. Например, здесь лейтенант имеет право писать в файлы генерала. Более подробно о реализации подобных формальных моделей рассказано в [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#29">Столлингс, 2002</a>], [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#30">Таненбаум, 2002</a>].</p><div  class="lecture_mark" id="mark_34"></div><p  id="id_35">Большинство операционных систем реализуют именно <span class="keyword">дискреционное управление доступом</span>. Главное его достоинство - гибкость, основные недостатки - рассредоточенность управления и сложность централизованного контроля.</p><div  class="lecture_mark" id="mark_35"></div><h4 >Домены безопасности</h4><p  id="id_36">Чтобы рассмотреть схему <span class="keyword">дискреционного доступа</span> более детально, введем концепцию <span class="keyword">домена безопасности</span> (protection domain). Каждый домен определяет набор объектов и типов операций, которые могут производиться над каждым объектом. Возможность выполнять операции над объектом есть права доступа, каждое из которых есть упорядоченная пара <span class="texample">&lt;object-name, rights-set&gt;</span>. Домен, таким образом, есть набор прав доступа. Hапример, если домен D имеет права доступа <span class="texample">&lt;file F, {read, write}&gt;</span>, это означает, что процесс, выполняемый в домене D, может читать или писать в файл F, но не может выполнять других операций над этим объектом. Пример доменов можно увидеть на <a href="">рис.16.1</a>.</p><div  class="lecture_mark" id="mark_36"></div><p  align="left" id="id_39"><a name="image.16.1"></a><div><img src="16. Защитные механизмы операционных систем_files/16-10000.gif" alt="Специфицирование прав доступа к ресурсам" width="348" height="166"></div><br><b>Рис. 16.1.</b> 
        Специфицирование прав доступа к ресурсам</p><div  class="lecture_mark" id="mark_39"></div><p  id="id_40">Связь конкретных субъектов, функционирующих в операционных системах, может быть организована следующим образом.</p><div  class="lecture_mark" id="mark_40"></div><ul  id="id_41"><li>Каждый пользователь может быть доменом. В этом случае набор объектов, к которым может быть организован доступ, зависит от <span class="keyword">идентификации</span> пользователя.</li><li>Каждый процесс может быть доменом. В этом случае набор доступных объектов определяется <span class="keyword">идентификацией</span> процесса.</li><li>Каждая процедура может быть доменом. В этом случае набор доступных объектов соответствует локальным переменным, определенным внутри процедуры. Заметим, что когда процедура выполнена, происходит смена домена.</li></ul><div  class="lecture_mark" id="mark_41"></div><p  id="id_45">Рассмотрим стандартную двухрежимную модель выполнения ОС. Когда процесс выполняется в режиме системы (kernel mode), он может выполнять привилегированные инструкции и иметь полный контроль над компьютерной системой. С другой стороны, если процесс выполняется в пользовательском режиме, он может вызывать только непривилегированные инструкции. Следовательно, он может выполняться только внутри предопределенного пространства памяти. Наличие этих двух режимов позволяет защитить ОС (kernel domain) от пользовательских процессов (выполняющихся в user domain). В мультипрограммных системах двух доменов недостаточно, так как появляется необходимость защиты пользователей друг от друга. Поэтому требуется более тщательно разработанная схема.</p><div  class="lecture_mark" id="mark_45"></div><p  id="id_46">В ОС Unix домен связан с пользователем. Каждый пользователь обычно работает со своим набором объектов.</p><div  class="lecture_mark" id="mark_46"></div><h4 >Матрица доступа</h4><p  id="id_47"><a name="keyword-context.2"></a>Модель безопасности, специфицированная в предыдущем разделе (см. <a href="http://www.intuit.ru/department/os/osintro/16/2.html#image.16.1">рис. 16.1</a>), имеет вид матрицы, которая называется <span class="keyword_def">матрицей доступа</span>. Какова может быть эффективная реализация <span class="keyword">матрицы доступа</span>? В общем случае она будет разреженной, то есть большинство ее клеток будут пустыми. Хотя существуют структуры данных для представления разреженной матрицы, они не слишком полезны для приложений, использующих возможности защиты. Поэтому на практике <span class="keyword">матрица доступа</span> применяется редко. Эту матрицу можно разложить по столбцам, в результате чего получаются <b>списки прав доступа</b> (access control list - ACL). В результате разложения по строкам получаются <span class="keyword">мандаты</span> возможностей (capability list или capability tickets).</p><div  class="lecture_mark" id="mark_47"></div><h5 >Список прав доступа. Access control list</h5><p  id="id_48">Каждая колонка в матрице может быть реализована как список доступа для одного объекта. Очевидно, что пустые клетки могут не учитываться. В результате для каждого объекта имеем список упорядоченных пар <span class="texample">&lt;domain, rights-set&gt;</span>, который определяет все домены с непустыми наборами прав для данного объекта.</p><div  class="lecture_mark" id="mark_48"></div><p  id="id_50">Элементами списка могут быть процессы, пользователи или группы пользователей. При реализации широко применяется предоставление доступа по умолчанию для пользователей, права которых не указаны. Например, в Unix все субъекты-пользователи разделены на три группы (владелец, группа и остальные), и для членов каждой группы контролируются операции чтения, записи и исполнения (rwx). В итоге имеем ACL - 9-битный код, который является атрибутом разнообразных объектов Unix.</p><div  class="lecture_mark" id="mark_50"></div><h5 >Мандаты возможностей. Capability list</h5><p  id="id_51">Как отмечалось выше, <a name="keyword-context.3"></a><a name="keyword-context.4"></a>если <span class="keyword">матрицу доступа</span> хранить по строкам, то есть если каждый субъект хранит список объектов и для каждого объекта - список допустимых операций, то такой способ хранения называется <span class="keyword_def">"мандаты"</span> или <span class="keyword_def">"перечни возможностей"</span> (capability list). Каждый пользователь обладает несколькими <span class="keyword">мандатами</span> и может иметь право передавать их другим. <span class="keyword">Мандаты</span> могут быть рассеяны по системе и вследствие этого представлять большую угрозу для безопасности, чем списки контроля доступа. Их хранение должно быть тщательно продумано.</p><div  class="lecture_mark" id="mark_51"></div><p  id="id_52">Примерами систем, использующих <span class="keyword">перечни возможностей</span>, являются Hydra, Cambridge CAP System [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#35">Denning, 1996</a>].</p><div  class="lecture_mark" id="mark_52"></div><h5 >Другие способы контроля доступа</h5><p  id="id_53">Иногда применяется <b>комбинированный способ</b>. Например, в том же Unix на этапе открытия файла происходит анализ ACL (операция open). В случае благоприятного исхода файл заносится в список открытых процессом файлов, и при последующих операциях чтения и записи проверки прав доступа не происходит. Список открытых файлов можно рассматривать как <span class="keyword">перечень возможностей</span>.</p><div  class="lecture_mark" id="mark_53"></div><p  id="id_54">Существует также схема <b>lock-key</b>, которая является компромиссом между списками прав доступа и <span class="keyword">перечнями возможностей</span>. В этой схеме каждый объект имеет список уникальных битовых шаблонов (patterns), называемых locks. Аналогично каждый домен имеет список уникальных битовых шаблонов, называемых ключами (keys). Процесс, выполняющийся в домене, может получить доступ к объекту, только если домен имеет ключ, который соответствует одному из шаблонов объекта.</p><div  class="lecture_mark" id="mark_54"></div><p  id="id_55">Как и в случае <span class="keyword">мандатов</span>, список ключей для домена должен управляться ОС. Пользователям не разрешается проверять или модифицировать списки ключей (или шаблонов) непосредственно. Более подробно данная схема изложена в [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#8">Silberschatz, 2002</a>].</p><div  class="lecture_mark" id="mark_55"></div><h5 >Смена домена</h5><p  id="id_56">В большинстве ОС для определения домена применяются идентификаторы пользователей. Обычно переключение между доменами происходит, когда меняется пользователь. Но почти все системы нуждаются в дополнительных механизмах смены домена, которые используются, когда некая привилегированная возможность необходима большому количеству пользователей. Hапример, может понадобиться разрешить пользователям иметь доступ к сети, не заставляя их писать собственные сетевые программы. В таких случаях для процессов ОС Unix предусмотрена установка бита <b>set-uid</b>. В результате установки этого бита в сетевой программе она получает привилегии ее создателя (а не пользователя), заставляя домен меняться на время ее выполнения. Таким образом, рядовой пользователь может получить нужные привилегии для доступа к сети.</p><div  class="lecture_mark" id="mark_56"></div><h4 >Недопустимость повторного использования объектов</h4><p  id="id_57">Контроль <span class="keyword">повторного использования объекта</span> предназначен для предотвращения попыток незаконного получения конфиденциальной информации, остатки которой могли сохраниться в некоторых объектах, ранее использовавшихся и освобожденных другим пользователем. Безопасность повторного применения должна гарантироваться для областей оперативной памяти (в частности, для буферов с образами экрана, расшифрованными паролями и т. п.), для дисковых блоков и магнитных носителей в целом. Очистка должна производиться путем записи маскирующей информации в объект при его освобождении (перераспределении). Hапример, для дисков на практике применяется способ двойной перезаписи освободившихся после удаления файлов блоков случайной битовой последовательностью.</p><div  class="lecture_mark" id="mark_57"></div><h3 >Выявление вторжений. Аудит системы защиты</h3><p  id="id_58">Даже самая лучшая система защиты рано или поздно будет взломана. Обнаружение попыток вторжения является важнейшей задачей системы защиты, поскольку ее решение позволяет минимизировать ущерб от взлома и собирать информацию о методах вторжения. Как правило, поведение взломщика отличается от поведения легального пользователя. Иногда эти различия можно выразить количественно, например подсчитывая число некорректных вводов пароля во время регистрации.</p><div  class="lecture_mark" id="mark_58"></div><p  id="id_59">Основным инструментом выявления вторжений является запись данных <span class="keyword">аудита</span>. Отдельные действия пользователей протоколируются, а полученный протокол используется для выявления вторжений.</p><div  class="lecture_mark" id="mark_59"></div><p  id="id_60"><a name="keyword-context.5"></a><span class="keyword_def">Аудит</span>, таким образом, заключается в регистрации специальных данных о различных типах событий, происходящих в системе и так или иначе влияющих на состояние безопасности компьютерной системы. К числу таких событий обычно причисляют следующие:</p><div  class="lecture_mark" id="mark_60"></div><ul  id="id_61"><li>вход или выход из системы;</li><li>операции с файлами (открыть, закрыть, переименовать, удалить);</li><li>обращение к удаленной системе;</li><li>смена привилегий или иных атрибутов безопасности (режима доступа, уровня благонадежности пользователя и т. п.).</li></ul><div  class="lecture_mark" id="mark_61"></div><p  id="id_66">Если фиксировать все события, объем регистрационной информации, скорее всего, будет расти слишком быстро, а ее эффективный анализ станет невозможным. Следует предусматривать наличие средств выборочного протоколирования как в отношении пользователей, когда слежение осуществляется только за подозрительными личностями, так и в отношении событий. Слежка важна в первую очередь как профилактическое средство. Можно надеяться, что многие воздержатся от нарушений безопасности, зная, что их действия фиксируются.</p><div  class="lecture_mark" id="mark_66"></div><p  id="id_67">Помимо протоколирования, можно периодически <b>сканировать</b> систему на наличие слабых мест в системе безопасности. Такое сканирование может проверить разнообразные аспекты системы:</p><div  class="lecture_mark" id="mark_67"></div><ul  id="id_68"><li>короткие или легкие пароли;</li><li>неавторизованные set-uid программы, если система поддерживает этот механизм;</li><li>неавторизованные программы в системных директориях;</li><li>долго выполняющиеся программы;</li><li>нелогичная защита как пользовательских, так и системных директорий и файлов. Примером нелогичной защиты может быть файл, который запрещено читать его автору, но в который разрешено записывать информацию постороннему пользователю;</li><li>потенциально опасные списки поиска файлов, которые могут привести к запуску "троянского коня";</li><li>изменения в системных программах, обнаруженные при помощи контрольных сумм.</li></ul><div  class="lecture_mark" id="mark_68"></div><p  id="id_76">Любая проблема, обнаруженная сканером безопасности, может быть как ликвидирована автоматически, так и передана для решения менеджеру системы.</p><div  class="lecture_mark" id="mark_76"></div><h3 >Анализ некоторых популярных ОС с точки зрения их защищенности</h3><p  id="id_77">Итак, ОС должна способствовать реализации мер безопасности или непосредственно поддерживать их. Примерами подобных решений в рамках аппаратуры и операционной системы могут быть:</p><div  class="lecture_mark" id="mark_77"></div><ul  id="id_78"><li>разделение команд по уровням привилегированности;</li><li>сегментация адресного пространства процессов и организация защиты сегментов;</li><li>защита различных процессов от взаимного влияния за счет выделения каждому своего виртуального пространства;</li><li>особая защита ядра ОС;</li><li>контроль <span class="keyword">повторного использования объекта</span>;</li><li>наличие средств управления доступом;</li><li>структурированность системы, явное выделение надежной вычислительной базы (совокупности защищенных компонентов), обеспечение компактности этой базы;</li><li>следование принципу минимизации привилегий - каждому компоненту дается ровно столько привилегий, сколько необходимо для выполнения им своих функций.</li></ul><div  class="lecture_mark" id="mark_78"></div><p  id="id_87">Большое значение имеет структура файловой системы. Hапример, в ОС с дискреционным контролем доступа каждый файл должен храниться вместе с дискреционным списком прав доступа к нему, а, например, при копировании файла все атрибуты, в том числе и ACL, должны быть автоматически скопированы вместе с телом файла.</p><div  class="lecture_mark" id="mark_87"></div><p  id="id_88">В принципе, меры безопасности не обязательно должны быть заранее встроены в ОС - достаточно принципиальной возможности дополнительной установки защитных продуктов. Так, сугубо ненадежная система MS-DOS может быть усовершенствована за счет средств проверки паролей доступа к компьютеру и/или жесткому диску, за счет борьбы с вирусами путем отслеживания попыток записи в загрузочный сектор CMOS-средствами и т. п. Тем не менее по-настоящему надежная система должна изначально проектироваться с акцентом на механизмы безопасности.</p><div  class="lecture_mark" id="mark_88"></div><h4 >MS-DOS</h4><p  id="id_89">ОС MS-DOS функционирует в реальном режиме (real-mode) процессора i80x86. В ней невозможно выполнение требования, касающегося изоляции программных модулей (отсутствует аппаратная защита памяти). Уязвимым местом для защиты является также файловая система FAT, не предполагающая у файлов наличия атрибутов, связанных с разграничением доступа к ним. Таким образом, MS-DOS находится на самом нижнем уровне в иерархии защищенных ОС.</p><div  class="lecture_mark" id="mark_89"></div><h4 >NetWare, IntranetWare</h4><p  id="id_90">Замечание об отсутствии изоляции модулей друг от друга справедливо и в отношении рабочей станции NetWare. Однако NetWare - <b>сетевая</b> ОС, поэтому к ней возможно применение и иных критериев. Это на данный момент единственная сетевая ОС, сертифицированная по классу C2 (следующей, по-видимому, будет Windows 2000). При этом важно изолировать наиболее уязвимый участок системы безопасности NetWare - консоль сервера, и тогда следование определенной практике поможет увеличить степень защищенности данной сетевой операционной системы. Возможность создания безопасных систем обусловлена тем, что число работающих приложений <b>фиксировано</b> и пользователь не имеет возможности запуска своих приложений.</p><div  class="lecture_mark" id="mark_90"></div><h4 >OS/2</h4><p  id="id_91">OS/2 работает в защищенном режиме (protected-mode) процессора i80x86. Изоляция программных модулей реализуется при помощи встроенных в этот процессор механизмов защиты памяти. Поэтому она свободна от указанного выше коренного недостатка систем типа MS-DOS. Но OS/2 была спроектирована и разработана без учета требований по защите от несанкционированного доступа. Это сказывается прежде всего на файловой системе. В файловых системах OS/2 HPFS (high performance file system) и FAT нет места ACL. Кроме того, пользовательские программы имеют возможность запрета прерываний. Следовательно, сертификация OS/2 на соответствие какому-то классу защиты не представляется возможной.</p><div  class="lecture_mark" id="mark_91"></div><p  id="id_92"><b>Считается</b>, что такие операционные системы, как MS-DOS, Mac OS, Windows, OS/2, имеют уровень защищенности D (по оранжевой книге). Но, если быть точным, нельзя считать эти ОС даже системами уровня безопасности D, ведь они никогда не представлялись на тестирование.</p><div  class="lecture_mark" id="mark_92"></div><h4 >Unix</h4><p  id="id_93">Рост популярности Unix и все большая осведомленность о проблемах безопасности привели к осознанию необходимости достичь приемлемого уровня безопасности ОС, сохранив при этом мобильность, гибкость и открытость программных продуктов. В Unix есть несколько уязвимых с точки зрения безопасности мест, хорошо известных опытным пользователям, вытекающих из самой природы Unix (см., например, раздел "Типичные объекты атаки хакеров" в книге [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#17">Дунаев, 1996</a>]). Однако хорошее системное администрирование может ограничить эту уязвимость.</p><div  class="lecture_mark" id="mark_93"></div><p  id="id_94">Относительно защищенности Unix сведения противоречивы. В Unix изначально были заложены <span class="keyword">идентификация</span> пользователей и разграничение доступа. Как оказалось, средства защиты данных в Unix могут быть доработаны, и сегодня можно утверждать, что многие клоны Unix по всем параметрам соответствуют классу безопасности C2.</p><div  class="lecture_mark" id="mark_94"></div><p  id="id_95">Обычно, говоря о защищенности Unix, рассматривают защищенность автоматизированных систем, одним из компонентов которых является Unix-сервер. Безопасность такой системы увязывается с защитой глобальных и локальных сетей, безопасностью удаленных сервисов типа telnet и rlogin/rsh и <span class="keyword">аутентификацией</span> в сетевой конфигурации, безопасностью X Window-приложений. Hа системном уровне важно наличие средств <span class="keyword">идентификации</span> и <span class="keyword">аудита</span>.</p><div  class="lecture_mark" id="mark_95"></div><p  id="id_96">В Unix существует список именованных пользователей, в соответствии с которым может быть построена система разграничения доступа.</p><div  class="lecture_mark" id="mark_96"></div><p  id="id_97">В ОС Unix считается, что информация, нуждающаяся в защите, находится главным образом в файлах.</p><div  class="lecture_mark" id="mark_97"></div><p  id="id_98">По отношению к конкретному файлу все пользователи делятся на три категории:</p><div  class="lecture_mark" id="mark_98"></div><ul  id="id_99"><li>владелец файла;</li><li>члены группы владельца;</li><li>прочие пользователи.</li></ul><div  class="lecture_mark" id="mark_99"></div><p  id="id_103">Для каждой из этих категорий режим доступа определяет права на операции с файлом, а именно:</p><div  class="lecture_mark" id="mark_103"></div><ul  id="id_104"><li>право на чтение;</li><li>право на запись;</li><li>право на выполнение (для каталогов - право на поиск).</li></ul><div  class="lecture_mark" id="mark_104"></div><p  id="id_108">В итоге девяти (3х3) битов защиты оказывается достаточно, чтобы специфицировать ACL каждого файла.</p><div  class="lecture_mark" id="mark_108"></div><p  id="id_109">Аналогичным образом защищены и другие объекты ОС Unix, например семафоры, сегменты разделяемой памяти и т. п.</p><div  class="lecture_mark" id="mark_109"></div><p  id="id_110">Указанных видов прав достаточно, чтобы определить допустимость любой операции с файлами. Например, для удаления файла необходимо иметь право на запись в соответствующий каталог. Как уже говорилось, права доступа к файлу проверяются только на этапе открытия. При последующих операциях чтения и записи проверка не выполняется. В результате, если режим доступа к файлу меняется после того, как файл был открыт, это не сказывается на процессах, уже открывших этот файл. Данное обстоятельство является уязвимым с точки зрения безопасности местом.</p><div  class="lecture_mark" id="mark_110"></div><p  id="id_111">Наличие всего трех видов субъектов доступа: владелец, группа, все остальные - затрудняет задание прав "с точностью до пользователя", особенно в случае больших конфигураций. В популярной разновидности Unix - Solaris имеется возможность использовать списки управления доступом (ACL), позволяющие индивидуально устанавливать права доступа отдельных пользователей или групп.</p><div  class="lecture_mark" id="mark_111"></div><p  id="id_112">Среди всех пользователей особое положение занимает пользователь root, обладающий максимальными привилегиями. Обычные правила разграничения доступа к нему не применяются - ему доступна вся информация на компьютере.</p><div  class="lecture_mark" id="mark_112"></div><p  id="id_113">В Unix имеются инструменты системного <span class="keyword">аудита</span> - хронологическая запись событий, имеющих отношение к безопасности. К таким событиям обычно относят: обращения программ к отдельным серверам; события, связанные с входом/выходом в систему и другие. Обычно регистрационные действия выполняются специализированным syslog-демоном, который проводит запись событий в регистрационный журнал в соответствии с текущей конфигурацией. Syslog-демон стартует в процессе загрузки системы.</p><div  class="lecture_mark" id="mark_113"></div><p  id="id_114">Таким образом, безопасность ОС Unix может быть доведена до соответствия классу C2. Однако разработка на ее основе автоматизированных систем более высокого класса защищенности может быть сопряжена с большими трудозатратами.</p><div  class="lecture_mark" id="mark_114"></div><h4 >Windows NT/2000/XP</h4><p  id="id_115">С момента выхода версии 3.1 осенью 1993 года в Windows NT гарантировалось соответствие уровню безопасности C2. В настоящее время (точнее, в 1999 г.) сертифицирована версия NT 4 с Service Pack 6a с использованием файловой системы NTFS в автономной и сетевой конфигурации. Следует помнить, что этот уровень безопасности не подразумевает защиту информации, передаваемой по сети, и не гарантирует защищенности от физического доступа.</p><div  class="lecture_mark" id="mark_115"></div><p  id="id_116">Компоненты защиты NT частично встроены в ядро, а частично реализуются подсистемой защиты. Подсистема защиты контролирует доступ и учетную информацию. Кроме того, Windows NT имеет встроенные средства, такие как поддержка резервных копий данных и управление источниками бесперебойного питания, которые не требуются "Оранжевой книгой", но в целом повышают общий уровень безопасности.</p><div  class="lecture_mark" id="mark_116"></div><p  id="id_117">ОС Windows 2000 сертифицирована по стандарту Common Criteria. В дальнейшем линейку продуктов Windows NT/2000/XP, изготовленных по технологии NT, будем называть просто Windows NT.</p><div  class="lecture_mark" id="mark_117"></div><p  id="id_118">Ключевая цель системы защиты Windows NT - следить за тем, кто и к каким объектам осуществляет доступ. Система защиты хранит информацию, относящуюся к безопасности для каждого пользователя, группы пользователей и объекта. Единообразие контроля доступа к различным объектам (процессам, файлам, семафорам и др.) обеспечивается тем, что с каждым процессом связан маркер доступа, а с каждым объектом - дескриптор защиты. Маркер доступа в качестве параметра имеет идентификатор пользователя, а дескриптор защиты - списки прав доступа. ОС может контролировать попытки доступа, которые производятся процессами прямо или косвенно инициированными пользователем.</p><div  class="lecture_mark" id="mark_118"></div><p  id="id_119">Windows NT отслеживает и контролирует доступ как к объектам, которые пользователь может видеть посредством интерфейса (такие, как файлы и принтеры), так и к объектам, которые пользователь не может видеть (например, процессы и именованные каналы). Любопытно, что, помимо разрешающих записей, списки прав доступа содержат и запрещающие записи, чтобы пользователь, которому доступ к какому-либо объекту запрещен, не смог получить его как член какой-либо группы, которой этот доступ предоставлен.</p><div  class="lecture_mark" id="mark_119"></div><p  id="id_120">Система защиты ОС Windows NT состоит из следующих компонентов:</p><div  class="lecture_mark" id="mark_120"></div><ul  id="id_121"><li>Процедуры регистрации (Logon Processes), которые обрабатывают запросы пользователей на вход в систему. Они включают в себя начальную интерактивную процедуру, отображающую начальный диалог с пользователем на экране и удаленные процедуры входа, которые позволяют удаленным пользователям получить доступ с рабочей станции сети к серверным процессам Windows NT.</li><li>Подсистемы локальной авторизации (Local Security Authority, LSA), которая гарантирует, что пользователь имеет разрешение на доступ в систему. Этот компонент - центральный для системы защиты Windows NT. Он порождает маркеры доступа, управляет локальной политикой безопасности и предоставляет интерактивным пользователям аутентификационные услуги. LSA также контролирует политику <span class="keyword">аудита</span> и ведет журнал, в котором сохраняются сообщения, порождаемые диспетчером доступа.</li><li>Менеджера учета (Security Account Manager, SAM), который управляет базой данных учета пользователей. Эта база данных содержит информацию обо всех пользователях и группах пользователей. SAM предоставляет услуги по легализации пользователей, применяющиеся в LSA.</li><li>Диспетчера доступа (Security Reference Monitor, SRM), который проверяет, имеет ли пользователь право на доступ к объекту и на выполнение тех действий, которые он пытается совершить. Этот компонент обеспечивает легализацию доступа и политику <span class="keyword">аудита</span>, определяемые LSA. Он предоставляет услуги для программ супервизорного и пользовательского режимов, для того чтобы гарантировать, что пользователи и процессы, осуществляющие попытки доступа к объекту, имеют необходимые права. Данный компонент также порождает сообщения службы <span class="keyword">аудита</span>, когда это необходимо.</li></ul><div  class="lecture_mark" id="mark_121"></div><p  id="id_126">Microsoft Windows NT - относительно новая ОС, которая была спроектирована для поддержки разнообразных защитных механизмов, от минимальных до C2, и безопасность которой наиболее продумана. Дефолтный уровень называется минимальным, но он легко может быть доведен системным администратором до желаемого уровня.</p><div  class="lecture_mark" id="mark_126"></div><h3 >Заключение</h3><p  id="id_127">Решение вопросов безопасности операционных систем обусловлено их архитектурными особенностями и связано с правильной организацией <span class="keyword">идентификации</span> и <span class="keyword">аутентификации</span>, авторизации и <span class="keyword">аудита</span>.</p><div  class="lecture_mark" id="mark_127"></div><p  id="id_128">Наиболее простой подход к <span class="keyword">аутентификации</span> - применение пользовательского пароля. Пароли уязвимы, значительная часть попыток несанкционированного доступа в систему связана с компрометацией паролей.</p><div  class="lecture_mark" id="mark_128"></div><p  id="id_129">Авторизация связана со специфицированием совокупности аппаратных и программных объектов, нуждающихся в защите. Для защиты объекта устанавливаются права доступа к нему. Набор прав доступа определяет <span class="keyword">домен безопасности</span>. Формальное описание модели защиты осуществляется с помощью <span class="keyword">матрицы доступа</span>, которая может храниться в виде списков прав доступа или <span class="keyword">перечней возможностей</span>.</p><div  class="lecture_mark" id="mark_129"></div><p  id="id_130"><span class="keyword">Аудит</span> системы заключается в регистрации специальных данных о различных событиях, происходящих в системе и так или иначе влияющих на состояние безопасности компьютерной системы. </p><div  class="lecture_mark" id="mark_130"></div><p  id="id_131">Среди современных ОС вопросы безопасности лучше всего продуманы в ОС Windows NT.</p><div  class="lecture_mark" id="mark_131"></div>


	</td>
	</tr>
	<tr><td height="8"><img src="16. Защитные механизмы операционных систем_files/empty000.gif" width="1" height="8"></td></tr>
	</table>
	<!-- /content -->

</td>
<td><img src="16. Защитные механизмы операционных систем_files/empty000.gif" width="8" height="1"></td>
</tr>
</table>
<!-- /bottom -->
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td class="orang" height="1"><img src="16. Защитные механизмы операционных систем_files/empty000.gif" width="1" height="1"></td></tr>
<td class="ltxt" align=center>&copy; INTUIT.ru, 2003-2008. Все права защищены.</td>
</tr>
</table>
<!-- /bottom -->

<script src="16. Защитные механизмы операционных систем_files/urchin00.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-3475067-1";
urchinTracker();
</script></body>
</html>


<!-- This document saved from http://www.intuit.ru/department/os/osintro/16/osintro_16.html -->
