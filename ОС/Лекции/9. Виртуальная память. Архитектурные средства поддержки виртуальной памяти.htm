<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>INTUIT.ru::Интернет-Университет Информационных Технологий</title>
<link href="9. Виртуальная память. Архитектурные средства поддержки виртуальной памяти_files/printabl.css" type="text/css" rel="stylesheet">
</head>
<body leftmargin="6" topmargin="6" marginheight="6" marginwidth="6">


<div align="left">
<span style="color: #000000; font-weight: bold;">
&nbsp;&nbsp;
<span style="font-size:12pt;">Интернет-Университет Информационных Технологий</span>
</span>
</div>

&nbsp;&nbsp;
<span align="rright" style="color: #330066; text-decoration:underline;">http://www.INTUIT.ru</span>


<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td height="8" colspan=3><img src="9. Виртуальная память. Архитектурные средства поддержки виртуальной памяти_files/empty000.gif" width="1" height="8"></td></tr>
<tr><td class="orang" height="1" colspan=3><img src="9. Виртуальная память. Архитектурные средства поддержки виртуальной памяти_files/empty000.gif" width="1" height="1"></td></tr>
<tr><td height="8" colspan=3><img src="9. Виртуальная память. Архитектурные средства поддержки виртуальной памяти_files/empty000.gif" width="1" height="8"></td></tr>
<tr valign="top">
<td><img src="9. Виртуальная память. Архитектурные средства поддержки виртуальной памяти_files/empty000.gif" width="8" height="1"></td>
<td>
	<!-- content -->
	<table border="0" cellpadding="0" cellspacing="0" width="100%">
	<tr><td class="head">Основы операционных систем</td></tr>
<tr><td height="4"><img src="9. Виртуальная память. Архитектурные средства поддержки виртуальной памяти_files/empty000.gif" width="1" height="4"></td></tr>
	<tr><td class="orang" height="1"><img src="9. Виртуальная память. Архитектурные средства поддержки виртуальной памяти_files/empty000.gif" width="1" height="1"></td></tr>
	<tr><td height="8"><img src="9. Виртуальная память. Архитектурные средства поддержки виртуальной памяти_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td><span class="headsub">


9. Лекция:

 Виртуальная память. Архитектурные средства поддержки виртуальной памяти: версия для печати и PDA</span>

<br>
<span class="rtxt">Рассмотрены аппаратные особенности поддержки виртуальной памяти. Разбиение адресного пространства процесса на части и динамическая трансляция адреса позволили выполнять процесс даже в отсутствие некоторых его компонентов в оперативной памяти. Следствием такой стратегии является возможность выполнения больших программ, размер которых может превышать размер оперативной памяти. 
</span>

</td></tr>

	<tr><td height="8"><img src="9. Виртуальная память. Архитектурные средства поддержки виртуальной памяти_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td class="orang" height="1"><img src="9. Виртуальная память. Архитектурные средства поддержки виртуальной памяти_files/empty000.gif" width="1" height="1"></td></tr>
	<tr><td height="8"><img src="9. Виртуальная память. Архитектурные средства поддержки виртуальной памяти_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td>


<h3 ></h3><p  id="id_1">В этой и следующей лекциях речь пойдет о наиболее распространенной в настоящее время схеме управления памятью, известной как <span class="keyword">виртуальная память</span>, в рамках которой осуществляется сложная связь между аппаратным и программным обеспечением. Вначале будут рассмотрены аппаратные аспекты <span class="keyword">виртуальной памяти</span>, а затем вопросы, возникающие при ее программной реализации.</p><div  class="lecture_mark" id="mark_1"></div><h3 >Понятие виртуальной памяти</h3><p  id="id_2">Разработчикам программного обеспечения часто приходится решать проблему размещения в памяти больших программ, размер которых превышает объем доступной оперативной памяти. Один из вариантов решения данной проблемы – организация структур с перекрытием – рассмотрен в предыдущей лекции. При этом предполагалось активное участие программиста в процессе формирования перекрывающихся частей программы. Развитие архитектуры компьютеров и расширение возможностей операционной системы по управлению памятью позволило переложить решение этой задачи на компьютер. Одним из главных достижений стало появление <span class="keyword">виртуальной памяти</span> (virtual memory). Впервые она была реализована в 1959 г. на компьютере "Атлас", разработанном в Манчестерском университете. </p><div  class="lecture_mark" id="mark_2"></div><p  id="id_3"><a name="keyword-context.1"></a>Суть концепции <span class="keyword_def">виртуальной памяти</span> заключается в следующем. Информация, с которой работает активный процесс, должна располагаться в оперативной памяти. В схемах <span class="keyword">виртуальной памяти</span> у процесса создается иллюзия того, что вся необходимая ему информация имеется в основной памяти. Для этого, во-первых, занимаемая процессом память разбивается на несколько частей, например страниц. Во-вторых, логический адрес (логическая страница), к которому обращается процесс, динамически транслируется в физический адрес (физическую страницу). И, наконец, в тех случаях, когда страница, к которой обращается процесс, не находится в физической памяти, нужно организовать ее подкачку с диска. Для контроля наличия страницы в памяти вводится специальный <span class="keyword">бит присутствия</span>, входящий в состав атрибутов страницы в <span class="keyword">таблице страниц</span>.</p><div  class="lecture_mark" id="mark_3"></div><p  id="id_4">Таким образом, в наличии всех компонентов процесса в основной памяти необходимости нет. Важным следствием такой организации является то, что размер памяти, занимаемой процессом, может быть больше, чем размер оперативной памяти. Принцип локальности обеспечивает этой схеме нужную эффективность. </p><div  class="lecture_mark" id="mark_4"></div><p  id="id_5">Возможность выполнения программы, находящейся в памяти лишь частично, имеет ряд вполне очевидных преимуществ.</p><div  class="lecture_mark" id="mark_5"></div><ul  id="id_6"><li>Программа не ограничена объемом физической памяти. Упрощается разработка программ, поскольку можно задействовать большие виртуальные пространства, не заботясь о размере используемой памяти.</li><li>Поскольку появляется возможность частичного помещения программы (процесса) в память и гибкого перераспределения памяти между программами, можно разместить в памяти больше программ, что увеличивает загрузку процессора и пропускную способность системы. </li><li>Объем ввода-вывода для выгрузки части программы на диск может быть меньше, чем в варианте классического свопинга, в итоге каждая программа будет работать быстрее.</li></ul><div  class="lecture_mark" id="mark_6"></div><p  id="id_10">Таким образом, возможность обеспечения (при поддержке операционной системы) для программы "видимости" практически неограниченной (характерный размер для 32-разрядных архитектур 2<sup>32</sup> = 4 Гбайт) адресуемой пользовательской памяти (логическое адресное пространство) при наличии основной памяти существенно меньших размеров (физическое адресное пространство) – очень важный аспект. </p><div  class="lecture_mark" id="mark_10"></div><p  id="id_11">Но введение <span class="keyword">виртуальной памяти</span> позволяет решать другую, не менее важную задачу – обеспечение контроля доступа к отдельным сегментам памяти и, в частности, защиту пользовательских программ друг от друга и защиту ОС от пользовательских программ. Каждый процесс работает со своими <span class="keyword">виртуальными адресами</span>, трансляцию которых в физические выполняет аппаратура компьютера. Таким образом, пользовательский процесс лишен возможности напрямую обратиться к страницам основной памяти, занятым информацией, относящейся к другим процессам.</p><div  class="lecture_mark" id="mark_11"></div><p  id="id_12">Например, 16-разрядный компьютер PDP-11/70 с 64 Кбайт логической памяти мог иметь до 2 Мбайт оперативной памяти. Операционная система этого компьютера тем не менее поддерживала <span class="keyword">виртуальную память</span>, которая обеспечивала защиту и перераспределение основной памяти между пользовательскими процессами. </p><div  class="lecture_mark" id="mark_12"></div><p  id="id_13">Напомним, что в системах с <span class="keyword">виртуальной памятью</span> те адреса, которые генерирует программа (логические адреса), называются виртуальными, и они формируют виртуальное адресное пространство. <a name="keyword-context.2"></a>Термин "<span class="keyword_def">виртуальная память</span>" означает, что программист имеет дело с памятью, отличной от реальной, размер которой потенциально больше, чем размер оперативной памяти.</p><div  class="lecture_mark" id="mark_13"></div><p  id="id_14">Хотя известны и чисто программные реализации <span class="keyword">виртуальной памяти</span>, это направление получило наиболее широкое развитие после соответствующей аппаратной поддержки. </p><div  class="lecture_mark" id="mark_14"></div><p  id="id_15">Следует отметить, что оборудование компьютера принимает участие в трансляции адреса практически во всех схемах управления памятью. Но в случае <span class="keyword">виртуальной памяти</span> это становится более сложным вследствие разрывности отображения и многомерности логического адресного пространства. Может быть, наиболее существенным вкладом аппаратуры в реализацию описываемой схемы является автоматическая генерация исключительных ситуаций при отсутствии в памяти нужных страниц (page fault).</p><div  class="lecture_mark" id="mark_15"></div><p  id="id_16">Любая из трех ранее рассмотренных схем управления памятью – <span class="keyword">страничной</span>, сегментной и <span class="keyword">сегментно-страничной</span> – пригодна для организации <span class="keyword">виртуальной памяти</span>. Чаще всего используется cегментно-страничная модель, которая является синтезом <span class="keyword">страничной модели</span> и идеи сегментации. Причем для тех архитектур, в которых сегменты не поддерживаются аппаратно, их реализация – задача архитектурно-независимого компонента менеджера памяти. </p><div  class="lecture_mark" id="mark_16"></div><p  id="id_17">Сегментная организация в чистом виде встречается редко.</p><div  class="lecture_mark" id="mark_17"></div><h3 >Архитектурные средства поддержки виртуальной памяти</h3><p  id="id_18">Очевидно, что невозможно создать полностью машинно-независимый компонент управления <span class="keyword">виртуальной памятью</span>. С другой стороны, имеются существенные части программного обеспечения, связанного с управлением <span class="keyword">виртуальной памятью</span>, для которых детали аппаратной реализации совершенно не важны. Одним из достижений современных ОС является грамотное и эффективное разделение средств управления <span class="keyword">виртуальной памятью</span> на аппаратно-независимую и аппаратно-зависимую части. Коротко рассмотрим, что и каким образом входит в аппаратно-зависимую часть подсистемы управления <span class="keyword">виртуальной памятью</span>. Компоненты аппаратно-независимой подсистемы будут рассмотрены в следующей лекции.</p><div  class="lecture_mark" id="mark_18"></div><p  id="id_19">В самом распространенном случае необходимо отобразить большое виртуальное адресное пространство в физическое адресное пространство существенно меньшего размера. Пользовательский процесс или ОС должны иметь возможность осуществить запись по <span class="keyword">виртуальному адресу</span>, а задача ОС – сделать так, чтобы записанная информация оказалась в физической памяти (впоследствии при нехватке оперативной памяти она может быть вытеснена во внешнюю память). В случае <span class="keyword">виртуальной памяти</span> система отображения адресных пространств помимо трансляции адресов должна предусматривать ведение таблиц, показывающих, какие области <span class="keyword">виртуальной памяти</span> в данный момент находятся в физической памяти и где именно размещаются. </p><div  class="lecture_mark" id="mark_19"></div><h4 >Страничная виртуальная память</h4><p  id="id_20"><a name="keyword-context.3"></a>Как и в случае простой <span class="keyword_def">страничной организации</span>, страничная <span class="keyword">виртуальная память</span> и физическая память представляются состоящими из наборов блоков или страниц одинакового размера. <span class="keyword">Виртуальные адреса</span> делятся на страницы (page), соответствующие единицы в физической памяти образуют страничные кадры (page frames), а в целом система поддержки страничной <span class="keyword">виртуальной памяти</span> называется пейджингом (paging). Передача информации между памятью и диском всегда осуществляется целыми страницами. </p><div  class="lecture_mark" id="mark_20"></div><p  id="id_21">После разбиения менеджером памяти виртуального адресного пространства на страницы <span class="keyword">виртуальный адрес</span> преобразуется в упорядоченную пару <span class="texample">(p,d)</span>, где <span class="texample">p</span> – номер страницы в <span class="keyword">виртуальной памяти</span>, а <span class="texample">d</span> – смещение в рамках страницы <span class="texample">p</span>, внутри которой размещается адресуемый элемент. Процесс может выполняться, если его текущая страница находится в оперативной памяти. Если текущей страницы в главной памяти нет, она должна быть переписана (подкачана) из внешней памяти. Поступившую страницу можно поместить в любой свободный страничный кадр. </p><div  class="lecture_mark" id="mark_21"></div><p  id="id_26">Поскольку число виртуальных страниц велико, <span class="keyword">таблица страниц</span> принимает специфический вид (см. раздел "Структура <span class="keyword">таблицы страниц</span>"), структура записей становится более сложной, среди атрибутов страницы появляются <span class="keyword">биты присутствия</span>, <span class="keyword">модификации</span> и другие управляющие биты.</p><div  class="lecture_mark" id="mark_26"></div><p  id="id_27">При отсутствии страницы в памяти в процессе выполнения команды возникает исключительная ситуация, называемая страничное нарушение (page fault) или страничный отказ. Обработка страничного нарушения заключается в том, что выполнение команды прерывается, затребованная страница подкачивается из конкретного места вторичной памяти в свободный страничный кадр физической памяти и попытка выполнения команды повторяется. При отсутствии свободных страничных кадров на диск выгружается редко используемая страница. Проблемы замещения страниц и обработки страничных нарушений рассматриваются в следующей лекции.</p><div  class="lecture_mark" id="mark_27"></div><p  id="id_28">Для управления физической памятью ОС поддерживает структуру таблицы кадров. Она имеет одну запись на каждый физический кадр, показывающую его состояние. </p><div  class="lecture_mark" id="mark_28"></div><p  id="id_29">В большинстве современных компьютеров со <span class="keyword">страничной организацией</span> в основной памяти хранится лишь часть <span class="keyword">таблицы страниц</span>, а быстрота доступа к элементам таблицы текущей <span class="keyword">виртуальной памяти</span> достигается, как будет показано ниже, за счет использования сверхбыстродействующей памяти, размещенной в кэше процессора.</p><div  class="lecture_mark" id="mark_29"></div><h4 >Сегментно-страничная организации виртуальной памяти</h4><p  id="id_30">Как и в случае простой сегментации, в схемах <span class="keyword">виртуальной памяти</span> сегмент – это линейная последовательность адресов, начинающаяся с <span class="texample">0</span>. При организации <span class="keyword">виртуальной памяти</span> размер сегмента может быть велик, например, может превышать размер оперативной памяти. Повторяя все ранее приведенные рассуждения о размещении в памяти больших программ, приходим к разбиению сегментов на страницы и необходимости поддержки своей <span class="keyword">таблицы страниц</span> для каждого сегмента.</p><div  class="lecture_mark" id="mark_30"></div><p  id="id_32">На практике, однако, появления в системе большого количества <span class="keyword">таблиц страниц</span> стараются избежать, организуя неперекрывающиеся сегменты в одном виртуальном пространстве, для описания которого хватает одной <span class="keyword">таблицы страниц</span>. Таким образом, одна <span class="keyword">таблица страниц</span> отводится для всего процесса. Например, в популярных ОС Linux и Windows 2000 все сегменты процесса, а также область памяти ядра ограничены виртуальным адресным пространством объемом 4 Гбайт. При этом ядро ОС располагается по фиксированным <span class="keyword">виртуальным адресам</span> вне зависимости от выполняемого процесса.</p><div  class="lecture_mark" id="mark_32"></div><h4 >Структура таблицы страниц</h4><p  id="id_33">Организация <span class="keyword">таблицы страниц</span> – один из ключевых элементов отображения адресов в <span class="keyword">страничной</span> и <span class="keyword">сегментно-страничной</span> схемах. Рассмотрим структуру <span class="keyword">таблицы страниц</span> для случая <span class="keyword">страничной организации</span> более подробно.</p><div  class="lecture_mark" id="mark_33"></div><p  id="id_34">Итак, <span class="keyword">виртуальный адрес</span> состоит из виртуального номера страницы и смещения. Номер записи в <span class="keyword">таблице страниц</span> соответствует номеру виртуальной страницы. Размер записи колеблется от системы к системе, но чаще всего он составляет 32 бита. Из этой записи в <span class="keyword">таблице страниц</span> находится номер кадра для данной виртуальной страницы, затем прибавляется смещение и формируется физический адрес. Помимо этого запись в <span class="keyword">таблице страниц</span> содержит информацию об атрибутах страницы. Это <span class="keyword">биты присутствия</span> и защиты (например, <span class="texample">0</span> – read/write, <span class="texample">1</span> – read only...). <a name="keyword-context.4"></a><a name="keyword-context.5"></a>Также могут быть указаны: <span class="keyword_def">бит модификации</span>, который устанавливается, если содержимое страницы модифицировано, и позволяет контролировать необходимость перезаписи страницы на диск; <span class="keyword_def">бит ссылки</span>, который помогает выделить малоиспользуемые страницы; бит, разрешающий кэширование, и другие управляющие биты. Заметим, что адреса страниц на диске не являются частью <span class="keyword">таблицы страниц</span>.</p><div  class="lecture_mark" id="mark_34"></div><p  id="id_37">Основную проблему для эффективной реализации <span class="keyword">таблицы страниц</span> создают большие размеры виртуальных адресных пространств современных компьютеров, которые обычно определяются разрядностью архитектуры процессора. Самыми распространенными на сегодня являются 32-разрядные процессоры, позволяющие создавать виртуальные адресные пространства размером 4 Гбайт (для 64-разрядных компьютеров эта величина равна 2<sup>64</sup> байт). Кроме того, существует проблема скорости отображения, которая решается за счет использования так называемой <span class="keyword">ассоциативной памяти</span> (см. следующий раздел).</p><div  class="lecture_mark" id="mark_37"></div><p  id="id_38">Подсчитаем примерный размер <span class="keyword">таблицы страниц</span>. В 32-битном адресном пространстве при размере страницы 4 Кбайт (Intel) получаем <span class="texample">2<sup>32</sup>/2<sup>12</sup>=2<sup>20</sup></span>, то есть приблизительно миллион страниц, а в 64-битном и того более. Таким образом, таблица должна иметь примерно миллион строк (entry), причем запись в строке состоит из нескольких байтов. Заметим, что каждый процесс нуждается в своей <span class="keyword">таблице страниц</span> (а в случае <span class="keyword">сегментно-страничной</span> схемы желательно иметь по одной <span class="keyword">таблице страниц</span> на каждый сегмент). </p><div  class="lecture_mark" id="mark_38"></div><p  id="id_40">Понятно, что количество памяти, отводимое <span class="keyword">таблицам страниц</span>, не может быть так велико. Для того чтобы избежать размещения в памяти огромной таблицы, ее разбивают на ряд фрагментов. В оперативной памяти хранят лишь некоторые, необходимые для конкретного момента исполнения фрагменты <span class="keyword">таблицы страниц</span>. В силу свойства локальности число таких фрагментов относительно невелико. Выполнить разбиение <span class="keyword">таблицы страниц</span> на части можно по-разному. Наиболее распространенный способ разбиения – организация так называемой <span class="keyword">многоуровневой таблицы страниц</span>. Для примера рассмотрим двухуровневую <span class="keyword">таблицу</span> с размером страниц 4 Кбайт, реализованную в 32-разрядной архитектуре Intel.</p><div  class="lecture_mark" id="mark_40"></div><p  id="id_41"><span class="keyword">Таблица</span>, состоящая из <span class="texample">2<sup>20</sup></span> строк, разбивается на <span class="texample">2<sup>10</sup></span><span class="keyword"> таблиц</span> второго уровня по <span class="texample">2<sup>10</sup></span> строк. Эти <span class="keyword">таблицы</span> второго уровня объединены в общую структуру при помощи одной <span class="keyword">таблицы</span> первого уровня, состоящей из <span class="texample">2<sup>10</sup></span> строк. 32-разрядный адрес делится на 10-разрядное поле <span class="texample">p<sub>1</sub></span>, 10-разрядное поле <span class="texample">p<sub>2</sub></span> и 12-разрядное смещение <span class="texample">d</span>. Поле <span class="texample">p<sub>1</sub></span> указывает на нужную строку в <span class="keyword">таблице</span> первого уровня, поле <span class="texample">p<sub>2</sub></span> – второго, а поле <span class="texample">d</span> локализует нужный байт внутри указанного страничного кадра (см. <a href="">рис. 9.1</a>). </p><div  class="lecture_mark" id="mark_41"></div><p  align="left" id="id_52"><a name="image.9.1"></a><div><img src="9. Виртуальная память. Архитектурные средства поддержки виртуальной памяти_files/10000000.gif" alt="Пример двухуровневой таблицы страниц" width="338" height="358"></div><br><b>Рис. 9.1.</b> 
        Пример двухуровневой таблицы страниц</p><div  class="lecture_mark" id="mark_52"></div><p  id="id_53">При помощи всего лишь одной <span class="keyword">таблицы</span> второго уровня можно охватить 4 Мбайт (4 Кбайт x 1024) оперативной памяти. Таким образом, для размещения процесса с большим объемом занимаемой памяти достаточно иметь в оперативной памяти одну <span class="keyword">таблицу</span> первого уровня и несколько <span class="keyword">таблиц</span> второго уровня. Очевидно, что суммарное количество строк в этих <span class="keyword">таблицах</span> много меньше <span class="texample">2<sup>20</sup></span>. Такой подход естественным образом обобщается на три и более уровней <span class="keyword">таблицы</span>.</p><div  class="lecture_mark" id="mark_53"></div><p  id="id_55">Наличие нескольких уровней, естественно, снижает производительность менеджера памяти. Несмотря на то что размеры <span class="keyword">таблиц</span> на каждом уровне подобраны так, чтобы <span class="keyword">таблица</span> помещалась целиком внутри одной страницы, обращение к каждому уровню – это отдельное обращение к памяти. Таким образом, трансляция адреса может потребовать нескольких обращений к памяти.</p><div  class="lecture_mark" id="mark_55"></div><p  id="id_56">Количество уровней в <span class="keyword">таблице страниц</span> зависит от конкретных особенностей архитектуры. Можно привести примеры реализации одноуровневого (DEC PDP-11), двухуровневого (Intel, DEC VAX), трехуровневого (Sun SPARC, DEC Alpha) пейджинга, а также пейджинга с заданным количеством уровней (Motorola). Функционирование RISC-процессора MIPS R2000 осуществляется вообще без <span class="keyword">таблицы страниц</span>. Здесь поиск нужной страницы, если эта страница отсутствует в <span class="keyword">ассоциативной памяти</span>, должна взять на себя ОС (так называемый zero level paging).</p><div  class="lecture_mark" id="mark_56"></div><h4 >Ассоциативная память </h4><p  id="id_57">Поиск номера кадра, соответствующего нужной странице, в <span class="keyword">многоуровневой таблице страниц</span> требует нескольких обращений к основной памяти, поэтому занимает много времени. В некоторых случаях такая задержка недопустима. Проблема ускорения поиска решается на уровне архитектуры компьютера.</p><div  class="lecture_mark" id="mark_57"></div><p  id="id_58">В соответствии со свойством локальности большинство программ в течение некоторого промежутка времени обращаются к небольшому количеству страниц, поэтому активно используется только небольшая часть <span class="keyword">таблицы страниц</span>.</p><div  class="lecture_mark" id="mark_58"></div><p  id="id_59"><a name="keyword-context.6"></a>Естественное решение проблемы ускорения – снабдить компьютер аппаратным устройством для отображения виртуальных страниц в физические без обращения к <span class="keyword">таблице страниц</span>, то есть иметь небольшую, быструю кэш-память, хранящую необходимую на данный момент часть <span class="keyword">таблицы страниц</span>. Это устройство называется <span class="keyword_def">ассоциативной памятью</span>, иногда также употребляют термин буфер поиска трансляции (translation lookaside buffer – TLB). </p><div  class="lecture_mark" id="mark_59"></div><p  id="id_60">Одна запись таблицы в <span class="keyword">ассоциативной памяти</span> (один вход) содержит информацию об одной виртуальной странице: ее атрибуты и кадр, в котором она находится. Эти поля в точности соответствуют полям в <span class="keyword">таблице страниц</span>. </p><div  class="lecture_mark" id="mark_60"></div><p  id="id_61">Так как <span class="keyword">ассоциативная память</span> содержит только некоторые из записей <span class="keyword">таблицы страниц</span>, каждая запись в TLB должна включать поле с номером виртуальной страницы. Память называется <span class="keyword">ассоциативной</span>, потому что в ней происходит одновременное сравнение номера отображаемой виртуальной страницы с соответствующим полем во всех строках этой небольшой <span class="keyword">таблицы</span>. Поэтому данный вид памяти достаточно дорого стоит. В строке, поле виртуальной страницы которой совпало с искомым значением, находится номер страничного кадра. Обычное число записей в TLB от 8 до 4096. Рост количества записей в <span class="keyword">ассоциативной памяти</span> должен осуществляться с учетом таких факторов, как размер кэша основной памяти и количества обращений к памяти при выполнении одной команды.</p><div  class="lecture_mark" id="mark_61"></div><p  id="id_62">Рассмотрим функционирование менеджера памяти при наличии <span class="keyword">ассоциативной памяти</span>. </p><div  class="lecture_mark" id="mark_62"></div><p  id="id_63">Вначале информация об отображении виртуальной страницы в физическую отыскивается в <span class="keyword">ассоциативной памяти</span>. Если нужная запись найдена – все нормально, за исключением случаев нарушения привилегий, когда запрос на обращение к памяти отклоняется.</p><div  class="lecture_mark" id="mark_63"></div><p  id="id_64">Если нужная запись в <span class="keyword">ассоциативной памяти</span> отсутствует, отображение осуществляется через <span class="keyword">таблицу страниц</span>. Происходит замена одной из записей в <span class="keyword">ассоциативной памяти</span> найденной записью из <span class="keyword">таблицы страниц</span>. Здесь мы сталкиваемся с традиционной для любого кэша проблемой замещения (а именно какую из записей в кэше необходимо изменить). Конструкция <span class="keyword">ассоциативной памяти</span> должна организовывать записи таким образом, чтобы можно было принять решение о том, какая из старых записей должна быть удалена при внесении новых. </p><div  class="lecture_mark" id="mark_64"></div><p  id="id_65">Число удачных поисков номера страницы в <span class="keyword">ассоциативной памяти</span> по отношению к общему числу поисков называется hit (совпадение) ratio (пропорция, отношение). Иногда также используется термин "процент попаданий в кэш". Таким образом, hit ratio – часть ссылок, которая может быть сделана с использованием <span class="keyword">ассоциативной памяти</span>. Обращение к одним и тем же страницам повышает hit ratio. Чем больше hit ratio, тем меньше среднее время доступа к данным, находящимся в оперативной памяти.</p><div  class="lecture_mark" id="mark_65"></div><p  id="id_66">Предположим, например, что для определения адреса в случае кэш-промаха через <span class="keyword">таблицу страниц</span> необходимо 100 нс, а для определения адреса в случае кэш-попадания через <span class="keyword">ассоциативную память</span> – <span class="texample">20 нс</span>. С 90% hit ratio среднее время определения адреса – <span class="texample">0,9x20+0,1x100 = 28 нс</span>. </p><div  class="lecture_mark" id="mark_66"></div><p  id="id_69">Вполне приемлемая производительность современных ОС доказывает эффективность использования <span class="keyword">ассоциативной памяти</span>. Высокое значение вероятности нахождения данных в <span class="keyword">ассоциативной памяти</span> связано с наличием у данных объективных свойств: пространственной и временной локальности. </p><div  class="lecture_mark" id="mark_69"></div><p  id="id_70">Необходимо обратить внимание на следующий факт. При переключении контекста процессов нужно добиться того, чтобы новый процесс "не видел" в <span class="keyword">ассоциативной памяти</span> информацию, относящуюся к предыдущему процессу, например очищать ее. Таким образом, использование <span class="keyword">ассоциативной памяти</span> увеличивает время переключения контекста.</p><div  class="lecture_mark" id="mark_70"></div><p  id="id_71">Рассмотренная двухуровневая (<span class="keyword">ассоциативная память</span> + <span class="keyword">таблица страниц</span>) схема преобразования адреса является ярким примером иерархии памяти, основанной на использовании принципа локальности, о чем говорилось во введении к предыдущей лекции.</p><div  class="lecture_mark" id="mark_71"></div><h4 >Инвертированная таблица страниц</h4><p  id="id_72">Несмотря на многоуровневую организацию, хранение нескольких <span class="keyword">таблиц страниц</span> большого размера по-прежнему представляют собой проблему. Ее значение особенно актуально для 64-разрядных архитектур, где число виртуальных страниц очень велико. Вариантом решения является применение <span class="keyword_def">инвертированной таблицы страниц</span> (inverted page table). Этот подход применяется на машинах PowerPC, некоторых рабочих станциях Hewlett-Packard, IBM RT, IBM AS/400 и ряде других. </p><div  class="lecture_mark" id="mark_72"></div><p  id="id_73"><a name="keyword-context.7"></a>В этой <span class="keyword">таблице</span> содержится по одной записи на каждый страничный кадр физической памяти. Существенно, что достаточно одной <span class="keyword">таблицы</span> для всех процессов. Таким образом, для хранения функции отображения требуется фиксированная часть основной памяти, независимо от разрядности архитектуры, размера и количества процессов. Например, для компьютера Pentium c 256 Мбайт оперативной памяти нужна <span class="keyword">таблица</span> размером 64 Кбайт строк. <span class="keyword"></span></p><div  class="lecture_mark" id="mark_73"></div><p  id="id_74">Несмотря на экономию оперативной памяти, применение <span class="keyword">инвертированной таблицы</span> имеет существенный минус – записи в ней (как и в <span class="keyword">ассоциативной памяти</span>) не отсортированы по возрастанию номеров виртуальных страниц, что усложняет трансляцию адреса. Один из способов решения данной проблемы – использование хеш-таблицы <span class="keyword">виртуальных адресов</span>. При этом часть <span class="keyword">виртуального адреса</span>, представляющая собой номер страницы, отображается в хеш-таблицу с использованием функции хеширования. Каждой странице физической памяти здесь соответствует одна запись в хеш-таблице и <span class="keyword">инвертированной таблице страниц</span>. <span class="keyword">Виртуальные адреса</span>, имеющие одно значение хеш-функции, сцепляются друг с другом. Обычно длина цепочки не превышает двух записей.</p><div  class="lecture_mark" id="mark_74"></div><h4 >Размер страницы</h4><p  id="id_75">Разработчики ОС для существующих машин редко имеют возможность влиять на размер страницы. Однако для вновь создаваемых компьютеров решение относительно оптимального размера страницы является актуальным. Как и следовало ожидать, нет одного наилучшего размера. Скорее есть набор факторов, влияющих на размер. Обычно размер страницы – это степень двойки от <span class="texample">2<sup>9</sup></span> до <span class="texample">2<sup>14</sup></span> байт.</p><div  class="lecture_mark" id="mark_75"></div><p  id="id_78">Чем больше размер страницы, тем меньше будет размер структур данных, обслуживающих преобразование адресов, но тем больше будут потери, связанные с тем, что память можно выделять только постранично.</p><div  class="lecture_mark" id="mark_78"></div><p  id="id_79">Как следует выбирать размер страницы? Во-первых, нужно учитывать размер <span class="keyword">таблицы</span> страниц, здесь желателен большой размер страницы (страниц меньше, соответственно и <span class="keyword">таблица страниц</span> меньше). С другой стороны, память лучше утилизируется с маленьким размером страницы. В среднем половина последней страницы процесса пропадает. Необходимо также учитывать объем ввода-вывода для взаимодействия с внешней памятью и другие факторы. Проблема не имеет идеального решения. Историческая тенденция состоит в увеличении размера страницы. </p><div  class="lecture_mark" id="mark_79"></div><p  id="id_80">Как правило, размер страниц задается аппаратно, например в DEC PDP-11 – 8 Кбайт, в DEC VAX – 512 байт, в других архитектурах, таких как Motorola 68030, размер страниц может быть задан программно. Учитывая все обстоятельства, в ряде архитектур возникают множественные размеры страниц, например в Pentium размер страницы колеблется от 4 Кбайт до 8 Кбайт. Тем не менее большинство коммерческих ОС ввиду сложности перехода на множественный размер страниц поддерживают только один размер страниц.</p><div  class="lecture_mark" id="mark_80"></div><h3 >Заключение</h3><p  id="id_81">В настоящей лекции рассмотрены аппаратные особенности поддержки <span class="keyword">виртуальной памяти</span>. Разбиение адресного пространства процесса на части и динамическая трансляция адреса позволили выполнять процесс даже в отсутствие некоторых его компонентов в оперативной памяти. Подкачка недостающих компонентов с диска осуществляется операционной системой в тот момент, когда в них возникает необходимость. Следствием такой стратегии является возможность выполнения больших программ, размер которых может превышать размер оперативной памяти. Чтобы обеспечить данной схеме нужную производительность, отображение адресов осуществляется аппаратно при помощи <span class="keyword">многоуровневой таблицы страниц</span> и <span class="keyword">ассоциативной памяти</span>.</p><div  class="lecture_mark" id="mark_81"></div>


	</td>
	</tr>
	<tr><td height="8"><img src="9. Виртуальная память. Архитектурные средства поддержки виртуальной памяти_files/empty000.gif" width="1" height="8"></td></tr>
	</table>
	<!-- /content -->

</td>
<td><img src="9. Виртуальная память. Архитектурные средства поддержки виртуальной памяти_files/empty000.gif" width="8" height="1"></td>
</tr>
</table>
<!-- /bottom -->
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td class="orang" height="1"><img src="9. Виртуальная память. Архитектурные средства поддержки виртуальной памяти_files/empty000.gif" width="1" height="1"></td></tr>
<td class="ltxt" align=center>&copy; INTUIT.ru, 2003-2008. Все права защищены.</td>
</tr>
</table>
<!-- /bottom -->

<script src="9. Виртуальная память. Архитектурные средства поддержки виртуальной памяти_files/urchin00.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-3475067-1";
urchinTracker();
</script></body>
</html>


<!-- This document saved from http://www.intuit.ru/department/os/osintro/9/osintro_9.html -->
