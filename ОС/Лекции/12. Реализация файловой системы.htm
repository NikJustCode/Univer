<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>INTUIT.ru::Интернет-Университет Информационных Технологий</title>
<link href="12. Реализация файловой системы_files/printabl.css" type="text/css" rel="stylesheet">
</head>
<body leftmargin="6" topmargin="6" marginheight="6" marginwidth="6">


<div align="left">
<span style="color: #000000; font-weight: bold;">
&nbsp;&nbsp;
<span style="font-size:12pt;">Интернет-Университет Информационных Технологий</span>
</span>
</div>

&nbsp;&nbsp;
<span align="rright" style="color: #330066; text-decoration:underline;">http://www.INTUIT.ru</span>


<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td height="8" colspan=3><img src="12. Реализация файловой системы_files/empty000.gif" width="1" height="8"></td></tr>
<tr><td class="orang" height="1" colspan=3><img src="12. Реализация файловой системы_files/empty000.gif" width="1" height="1"></td></tr>
<tr><td height="8" colspan=3><img src="12. Реализация файловой системы_files/empty000.gif" width="1" height="8"></td></tr>
<tr valign="top">
<td><img src="12. Реализация файловой системы_files/empty000.gif" width="8" height="1"></td>
<td>
	<!-- content -->
	<table border="0" cellpadding="0" cellspacing="0" width="100%">
	<tr><td class="head">Основы операционных систем</td></tr>
<tr><td height="4"><img src="12. Реализация файловой системы_files/empty000.gif" width="1" height="4"></td></tr>
	<tr><td class="orang" height="1"><img src="12. Реализация файловой системы_files/empty000.gif" width="1" height="1"></td></tr>
	<tr><td height="8"><img src="12. Реализация файловой системы_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td><span class="headsub">


12. Лекция:

 Реализация файловой системы: версия для печати и PDA</span>

<br>
<span class="rtxt">Реализация файловой системы связана с такими вопросами, как поддержка понятия логического блока диска, связывания имени файла и блоков его данных, проблемами разделения файлов и управления дисковым пространством.
</span>

</td></tr>

	<tr><td height="8"><img src="12. Реализация файловой системы_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td class="orang" height="1"><img src="12. Реализация файловой системы_files/empty000.gif" width="1" height="1"></td></tr>
	<tr><td height="8"><img src="12. Реализация файловой системы_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td>


<h3 ></h3><p  id="id_1">Как уже говорилось, файловая система должна организовать эффективную работу с данными, хранящимися во внешней памяти, и предоставить пользователю возможности для запоминания и выборки этих данных.</p><div  class="lecture_mark" id="mark_1"></div><p  id="id_2">Для организации хранения информации на диске пользователь вначале обычно выполняет его форматирование, выделяя на нем место для структур данных, которые описывают состояние файловой системы в целом. Затем пользователь создает нужную ему структуру каталогов (или директорий), которые, по существу, являются списками вложенных каталогов и собственно файлов. И наконец, он заполняет дисковое пространство файлами, приписывая их тому или иному каталогу. Таким образом, ОС должна предоставить в распоряжение пользователя совокупность системных вызовов, которые обеспечивают его необходимыми сервисами.</p><div  class="lecture_mark" id="mark_2"></div><p  id="id_3">Кроме того, файловые службы могут решать проблемы проверки и сохранения целостности файловой системы, проблемы повышения производительности и ряд других.</p><div  class="lecture_mark" id="mark_3"></div><h3 >Общая структура файловой системы</h3><p  id="id_4">Система хранения данных на дисках может быть структурирована следующим образом (см. <a href="">рис. 12.1</a>).</p><div  class="lecture_mark" id="mark_4"></div><p  id="id_5"><b>Нижний уровень</b> - оборудование. Это в первую очередь магнитные диски с подвижными головками - основные устройства внешней памяти, представляющие собой пакеты магнитных пластин (поверхностей), между которыми на одном рычаге двигается пакет магнитных головок. Шаг движения пакета головок является дискретным, и каждому положению пакета головок логически соответствует цилиндр магнитного диска. Цилиндры делятся на дорожки (треки), а каждая дорожка размечается на одно и то же количество блоков (секторов) таким образом, что в каждый блок можно записать по максимуму одно и то же число байтов. Следовательно, для обмена с магнитным диском на уровне аппаратуры нужно указать номер цилиндра, номер поверхности, номер блока на соответствующей дорожке и число байтов, которое нужно записать или прочитать от начала этого блока. Таким образом, диски могут быть разбиты на блоки фиксированного размера и можно непосредственно получить доступ к любому блоку (организовать прямой доступ к файлам).</p><div  class="lecture_mark" id="mark_5"></div><p  id="id_6">Непосредственно с устройствами (дисками) взаимодействует часть ОС, называемая <b>системой ввода-вывода</b> (см. лекцию 13). Система ввода-вывода предоставляет в распоряжение более высокоуровневого компонента ОС - файловой системы - используемое дисковое пространство в виде <b>непрерывной последовательности блоков фиксированного размера</b>. Система ввода-вывода имеет дело с <b>физическими</b> блоками диска, которые характеризуются адресом, например диск 2, цилиндр 75, сектор 11. Файловая система имеет дело с <b>логическими</b> блоками, каждый из которых имеет номер (от 0 или 1 до N). Размер логических блоков файла совпадает или является кратным размеру физического блока диска и может быть задан равным размеру страницы виртуальной памяти, поддерживаемой аппаратурой компьютера совместно с операционной системой.</p><div  class="lecture_mark" id="mark_6"></div><p  id="id_7">В структуре системы управления файлами можно выделить базисную подсистему, которая отвечает за выделение дискового пространства конкретным файлам, и более высокоуровневую логическую подсистему, которая использует структуру дерева директорий для предоставления модулю базисной подсистемы необходимой ей информации, исходя из символического имени файла. Она также ответственна за авторизацию доступа к файлам (см. лекции 11 и 16).</p><div  class="lecture_mark" id="mark_7"></div><p  id="id_8"><b>Стандартный запрос</b> на открытие (open) или создание (create) файла поступает от прикладной программы к логической подсистеме. Логическая подсистема, используя структуру директорий, проверяет права доступа и вызывает базовую подсистему для получения доступа к блокам файла. После этого файл считается открытым, он содержится в таблице открытых файлов, и прикладная программа получает в свое распоряжение дескриптор (или handle в системах Microsoft) этого файла. Дескриптор файла является ссылкой на файл в таблице открытых файлов и используется в запросах прикладной программы на чтение-запись из этого файла. Запись в таблице открытых файлов указывает через систему выделения блоков диска на блоки данного файла. Если к моменту открытия файл уже используется другим процессом, то есть содержится в таблице открытых файлов, то после проверки прав доступа к файлу может быть организован <span class="keyword">совместный доступ</span>. При этом новому процессу также возвращается дескриптор - 
ссылка на файл в таблице открытых файлов. Далее в 
тексте подробно проанализирована работа наиболее важных системных вызовов.</p><div  class="lecture_mark" id="mark_8"></div><p  align="left" id="id_9"><a name="image.12.1"></a><div><img src="12. Реализация файловой системы_files/12-10000.gif" alt="Блок-схема файловой системы" width="352" height="502"></div><br><b>Рис. 12.1.</b> 
        Блок-схема файловой системы</p><div  class="lecture_mark" id="mark_9"></div><h3 >Управление внешней памятью</h3><p  id="id_10">Прежде чем описывать структуру данных файловой системы на диске, необходимо рассмотреть <span class="keyword">алгоритмы выделения дискового пространства</span> и способы учета свободной и занятой дисковой памяти. Эти задачи связаны между собой.</p><div  class="lecture_mark" id="mark_10"></div><h4 >Методы выделения дискового пространства</h4><p  id="id_11">Ключевым, безусловно, является вопрос, какой тип структур используется для учета отдельных блоков файла, то есть способ связывания файлов с блоками диска. В ОС используется несколько методов выделения файлу дискового пространства. Для каждого из методов запись в директории, соответствующая символьному имени файла, содержит указатель, следуя которому можно найти все блоки данного файла.</p><div  class="lecture_mark" id="mark_11"></div><h5 >Выделение непрерывной последовательностью блоков</h5><p  id="id_12">Простейший способ - хранить каждый файл как непрерывную последовательность блоков диска. При непрерывном расположении файл характеризуется адресом и длиной (в блоках). Файл, стартующий с блока b, занимает затем блоки b+1, b+2, ... b+n-1. </p><div  class="lecture_mark" id="mark_12"></div><p  id="id_13">Эта схема имеет два преимущества. Во-первых, ее легко реализовать, так как выяснение местонахождения файла сводится к вопросу, где находится первый блок. Во-вторых, она обеспечивает хорошую производительность, так как целый файл может быть считан за одну дисковую операцию.</p><div  class="lecture_mark" id="mark_13"></div><p  id="id_14">Непрерывное выделение используется в ОС IBM/CMS, в ОС RSX-11 (для выполняемых файлов) и в ряде других.</p><div  class="lecture_mark" id="mark_14"></div><p  id="id_15">Этот способ распространен мало, и вот почему. В процессе эксплуатации диск представляет собой некоторую совокупность свободных и занятых фрагментов. Не всегда имеется подходящий по размеру свободный фрагмент для нового файла. Проблема непрерывного расположения может рассматриваться как частный случай более общей проблемы выделения блока нужного размера из списка свободных блоков. Типовыми решениями этой задачи являются стратегии первого подходящего, наиболее подходящего и наименее подходящего (сравните с проблемой выделения памяти в методе с динамическим распределением). Как и в случае выделения нужного объема оперативной памяти в схеме с динамическими разделами (см. лекцию 8), метод страдает от <b>внешней фрагментации</b>, в большей или меньшей степени, в зависимости от размера диска и среднего размера файла.</p><div  class="lecture_mark" id="mark_15"></div><p  id="id_16">Кроме того, непрерывное распределение внешней памяти неприменимо до тех пор, пока неизвестен максимальный размер файла. Иногда размер выходного файла оценить легко (при копировании). Чаще, однако, это трудно сделать, особенно в тех случаях, когда размер файла меняется. Если места не хватило, то пользовательская программа может быть приостановлена с учетом выделения дополнительного места для файла при последующем рестарте. Некоторые ОС используют модифицированный вариант непрерывного выделения - основные блоки файла + резервные блоки. Однако с выделением блоков из резерва возникают те же проблемы, так как приходится решать задачу выделения непрерывной последовательности блоков диска теперь уже из совокупности резервных блоков.</p><div  class="lecture_mark" id="mark_16"></div><p  id="id_17">Единственным приемлемым решением перечисленных проблем является периодическое уплотнение содержимого внешней памяти, или "сборка мусора", цель которой состоит в объединении свободных участков в один большой блок. Но это дорогостоящая операция, которую невозможно осуществлять слишком часто.</p><div  class="lecture_mark" id="mark_17"></div><p  id="id_18">Таким образом, когда содержимое диска постоянно изменяется, данный метод нерационален. Однако для <b>стационарных</b> файловых систем, например для файловых систем компакт-дисков, он вполне пригоден.</p><div  class="lecture_mark" id="mark_18"></div><h5 >Связный список</h5><p  id="id_19">Внешняя фрагментация - основная проблема рассмотренного выше метода - может быть устранена за счет представления файла в виде связного списка блоков диска. Запись в директории содержит указатель на первый и последний блоки файла (иногда в качестве варианта используется специальный знак конца файла - EOF). Каждый блок содержит указатель на следующий блок (см. <a href="">рис. 12.2</a>).</p><div  class="lecture_mark" id="mark_19"></div><p  align="left" id="id_20"><a name="image.12.2"></a><div><img src="12. Реализация файловой системы_files/12-20000.gif" alt="Хранение файла в виде связного списка дисковых блоков" width="426" height="167"></div><br><b>Рис. 12.2.</b> 
        Хранение файла в виде связного списка дисковых блоков</p><div  class="lecture_mark" id="mark_20"></div><p  id="id_21">Внешняя фрагментация для данного метода отсутствует. Любой свободный блок может быть использован для удовлетворения запроса. Заметим, что нет необходимости декларировать размер файла в момент создания. Файл может расти неограниченно.</p><div  class="lecture_mark" id="mark_21"></div><p  id="id_22">Связное выделение имеет, однако, несколько существенных недостатков.</p><div  class="lecture_mark" id="mark_22"></div><p  id="id_23">Во-первых, при прямом доступе к файлу для поиска i-го блока нужно осуществить несколько обращений к диску, последовательно считывая блоки от 1 до i-1, то есть выборка логически смежных записей, которые занимают физически несмежные секторы, может требовать много времени. Здесь мы теряем все преимущества прямого доступа к файлу.</p><div  class="lecture_mark" id="mark_23"></div><p  id="id_24">Во-вторых, данный способ не очень надежен. Наличие дефектного блока в списке приводит к потере информации в оставшейся части файла и потенциально к потере дискового пространства, отведенного под этот файл.</p><div  class="lecture_mark" id="mark_24"></div><p  id="id_25">Наконец, для указателя на следующий блок внутри блока нужно выделить место, что не всегда удобно. Емкость блока, традиционно являющаяся степенью двойки (многие программы читают и пишут блоками по степеням двойки), таким образом, перестает быть степенью двойки, так как указатель отбирает несколько байтов.</p><div  class="lecture_mark" id="mark_25"></div><p  id="id_26">Поэтому метод связного списка обычно в чистом виде не используется.</p><div  class="lecture_mark" id="mark_26"></div><h5 >Таблица отображения файлов</h5><p  id="id_27">Одним из вариантов предыдущего способа является хранение указателей не в дисковых блоках, а в индексной таблице в памяти, которая называется таблицей отображения файлов (<span class="keyword">FAT - file allocation table</span>) (см. <a href="">рис. 12.3</a>). Этой схемы придерживаются многие ОС (MS-DOS, OS/2, MS Windows и др.)</p><div  class="lecture_mark" id="mark_27"></div><p  id="id_28">По-прежнему существенно, что запись в директории содержит только ссылку на первый блок. Далее при помощи таблицы <span class="keyword">FAT</span> можно локализовать блоки файла независимо от его размера. В тех строках таблицы, которые соответствуют последним блокам файлов, обычно записывается некоторое граничное значение, например EOF.</p><div  class="lecture_mark" id="mark_28"></div><p  id="id_29">Главное достоинство данного подхода состоит в том, что по таблице отображения можно судить о физическом соседстве блоков, располагающихся на диске, и при выделении нового блока можно легко найти свободный блок диска, находящийся поблизости от других блоков данного файла. Минусом данной схемы может быть необходимость хранения в памяти этой довольно большой таблицы.</p><div  class="lecture_mark" id="mark_29"></div><p  align="left" id="id_30"><a name="image.12.3"></a><div><img src="12. Реализация файловой системы_files/12-30000.gif" alt="Метод связного списка с использованием таблицы в оперативной памяти" width="261" height="293"></div><br><b>Рис. 12.3.</b> 
        Метод связного списка с использованием таблицы в оперативной памяти</p><div  class="lecture_mark" id="mark_30"></div><h5 >Индексные узлы</h5><p  id="id_31">Наиболее распространенный метод выделения файлу блоков диска - связать с каждым файлом небольшую таблицу, называемую <span class="keyword">индексным узлом</span> (<span class="keyword">i-node</span>), которая перечисляет атрибуты и дисковые адреса блоков файла (см. <a href="">рис 12.4</a>). Запись в директории, относящаяся к файлу, содержит адрес индексного блока. По мере заполнения файла указатели на блоки диска в <span class="keyword">индексном узле</span> принимают осмысленные значения.</p><div  class="lecture_mark" id="mark_31"></div><p  id="id_32">Индексирование поддерживает прямой доступ к файлу, без ущерба от внешней фрагментации. Индексированное размещение широко распространено и поддерживает как последовательный, так и прямой доступ к файлу.</p><div  class="lecture_mark" id="mark_32"></div><p  id="id_33">Обычно применяется комбинация одноуровневого и многоуровневых индексов. Первые несколько адресов блоков файла хранятся непосредственно в <span class="keyword">индексном узле</span>, таким образом, для маленьких файлов <span class="keyword">индексный узел</span> хранит всю необходимую информацию об адресах блоков диска. Для больших файлов один из адресов <span class="keyword">индексного узла</span> указывает на блок косвенной адресации. Данный блок содержит адреса дополнительных блоков диска. Если этого недостаточно, используется блок двойной косвенной адресации, который содержит адреса блоков косвенной адресации. Если и этого не хватает, используется блок тройной косвенной адресации.</p><div  class="lecture_mark" id="mark_33"></div><p  align="left" id="id_34"><a name="image.12.4"></a><div><img src="12. Реализация файловой системы_files/12-40000.gif" alt="Структура индексного узла" width="431" height="484"></div><br><b>Рис. 12.4.</b> 
        Структура индексного узла</p><div  class="lecture_mark" id="mark_34"></div><p  id="id_35">Данную схему используют файловые системы Unix (а также файловые системы HPFS, NTFS и др.). Такой подход позволяет при фиксированном, относительно небольшом размере <span class="keyword">индексного узла</span> поддерживать работу с файлами, размер которых может меняться от нескольких байтов  до нескольких гигабайтов. Существенно, что для маленьких файлов используется только прямая адресация, обеспечивающая максимальную производительность.</p><div  class="lecture_mark" id="mark_35"></div><h4 >Управление свободным и занятым дисковым пространством</h4><p  id="id_36">Дисковое пространство, не выделенное ни одному файлу, также должно быть управляемым. В современных ОС используется несколько способов учета используемого места на диске. Рассмотрим наиболее распространенные.</p><div  class="lecture_mark" id="mark_36"></div><h5 >Учет при помощи организации битового вектора</h5><p  id="id_37">Часто список свободных блоков диска реализован в виде <span class="keyword">битового вектора</span> (bit map или bit vector). Каждый блок представлен одним битом, принимающим значение 0 или 1, в зависимости от того, занят он или свободен. Hапример, 00111100111100011000001 ... .</p><div  class="lecture_mark" id="mark_37"></div><p  id="id_38">Главное преимущество этого подхода состоит в том, что он относительно прост и эффективен при нахождении первого свободного блока или n последовательных блоков на диске. Многие компьютеры имеют инструкции манипулирования битами, которые могут использоваться для этой цели. Hапример, компьютеры семейств Intel и Motorola имеют инструкции, при помощи которых можно легко локализовать первый единичный бит в слове.</p><div  class="lecture_mark" id="mark_38"></div><p  id="id_39">Описываемый метод учета свободных блоков используется в Apple Macintosh.</p><div  class="lecture_mark" id="mark_39"></div><p  id="id_40">Несмотря на то что размер описанного <span class="keyword">битового вектора</span> наименьший из всех возможных структур, даже такой вектор может оказаться большого размера. Поэтому данный метод эффективен, только если <span class="keyword">битовый вектор</span> помещается в памяти целиком, что возможно лишь для относительно небольших дисков. Например, диск размером 4 Гбайт с блоками по 4 Кбайт нуждается в таблице размером 128 Кбайт для управления свободными блоками. Иногда, если <span class="keyword">битовый вектор</span> становится слишком большим, для ускорения поиска в нем его разбивают на регионы и организуют резюмирующие структуры данных, содержащие сведения о количестве свободных блоков для каждого региона.</p><div  class="lecture_mark" id="mark_40"></div><h5 >Учет при помощи организации связного списка</h5><p  id="id_41">Другой подход - связать в список все свободные блоки, размещая указатель на первый свободный блок в специально отведенном месте диска, попутно кэшируя в памяти эту информацию.</p><div  class="lecture_mark" id="mark_41"></div><p  id="id_42">Подобная схема не всегда эффективна. Для трассирования списка нужно выполнить много обращений к диску. Однако, к счастью, нам необходим, как правило, только первый свободный блок.</p><div  class="lecture_mark" id="mark_42"></div><p  id="id_43">Иногда прибегают к модификации подхода связного списка, организуя хранение адресов n свободных блоков в первом свободном блоке. Первые n-1 этих блоков действительно используются. Последний блок содержит адреса других n блоков и т. д.</p><div  class="lecture_mark" id="mark_43"></div><p  id="id_44">Существуют и другие методы, например, свободное пространство можно рассматривать как файл и вести для него соответствующий <span class="keyword">индексный узел</span>.</p><div  class="lecture_mark" id="mark_44"></div><h4 >Размер блока</h4><p  id="id_45">Размер логического блока играет важную роль. В некоторых системах (Unix) он может быть задан при форматировании диска. Небольшой размер блока будет приводить к тому, что каждый файл будет содержать много блоков. Чтение блока осуществляется с задержками на поиск и вращение, таким образом, файл из многих блоков будет читаться медленно. Большие блоки обеспечивают более высокую скорость обмена с диском, но из-за внутренней фрагментации (каждый файл занимает целое число блоков, и в среднем половина последнего блока пропадает) снижается процент полезного дискового пространства.</p><div  class="lecture_mark" id="mark_45"></div><p  id="id_46">Для систем со страничной организацией памяти характерна сходная проблема с размером страницы.</p><div  class="lecture_mark" id="mark_46"></div><p  id="id_47">Проведенные исследования показали, что большинство файлов имеют небольшой размер. Например, в Unix приблизительно 85% файлов имеют размер менее 8 Кбайт и 48% - менее 1 Кбайта.</p><div  class="lecture_mark" id="mark_47"></div><p  id="id_48">Можно также учесть, что в системах с виртуальной памятью желательно, чтобы единицей пересылки диск-память была страница (наиболее распространенный размер страниц памяти - 4 Кбайта). Отсюда обычный компромиссный выбор блока размером 512 байт, 1 Кбайт, 2 Кбайт, 4 Кбайт.</p><div  class="lecture_mark" id="mark_48"></div><h4 >Структура файловой системы на диске</h4><p  id="id_49">Рассмотрение методов работы с дисковым пространством дает общее представление о совокупности служебных данных, необходимых для описания файловой системы. Структура служебных данных типовой файловой системы, например Unix, на одном из разделов диска, таким образом, может состоять из четырех основных частей (см. <a href="">рис. 12.5</a>).</p><div  class="lecture_mark" id="mark_49"></div><p  align="left" id="id_50"><a name="image.12.5"></a><div><img src="12. Реализация файловой системы_files/12-50000.gif" alt="Примерная структура файловой системы на диске" width="428" height="115"></div><br><b>Рис. 12.5.</b> 
        Примерная структура файловой системы на диске</p><div  class="lecture_mark" id="mark_50"></div><p  id="id_51"><a name="keyword-context.1"></a>В начале раздела находится <span class="keyword_def">суперблок</span>, содержащий общее описание файловой системы, например:</p><div  class="lecture_mark" id="mark_51"></div><ul  id="id_52"><li>тип файловой системы;</li><li>размер файловой системы в блоках;</li><li>размер массива <span class="keyword">индексных узлов</span>;</li><li>размер логического блока.</li></ul><div  class="lecture_mark" id="mark_52"></div><p  id="id_57">Описанные структуры данных создаются на диске в результате его <b>форматирования</b> (например, утилитами format, makefs и др.). Их наличие позволяет обращаться к данным на диске как к файловой системе, а не как к обычной последовательности блоков.</p><div  class="lecture_mark" id="mark_57"></div><p  id="id_58">В файловых системах современных ОС для повышения устойчивости поддерживается несколько копий <span class="keyword">суперблока</span>. В некоторых версиях Unix <span class="keyword">суперблок</span> включал также и структуры данных, управляющие распределением дискового пространства, в результате чего <span class="keyword">суперблок</span> непрерывно подвергался модификации, что снижало надежность файловой системы в целом. Выделение структур данных, описывающих дисковое пространство, в отдельную часть является более правильным решением.</p><div  class="lecture_mark" id="mark_58"></div><p  id="id_59">Массив <span class="keyword">индексных узлов</span> (ilist) содержит список индексов, соответствующих файлам данной файловой системы. Размер массива <span class="keyword">индексных узлов</span> определяется администратором при установке системы. Максимальное число файлов, которые могут быть созданы в файловой системе, определяется числом доступных <span class="keyword">индексных узлов</span>.</p><div  class="lecture_mark" id="mark_59"></div><p  id="id_60">В блоках данных хранятся реальные данные файлов. Размер логического блока данных может задаваться при форматировании файловой системы. Заполнение диска содержательной информацией предполагает использование блоков хранения данных для файлов директорий и обычных файлов и имеет следствием модификацию массива <span class="keyword">индексных узлов</span> и данных, описывающих пространство диска. Отдельно взятый блок данных может принадлежать одному и только одному файлу в файловой системе.</p><div  class="lecture_mark" id="mark_60"></div><h3 >Реализация директорий</h3><p  id="id_61">Как уже говорилось, директория или каталог - это файл, имеющий вид таблицы и хранящий список входящих в него файлов или каталогов. Основная задача файлов-директорий - поддержка иерархической древовидной структуры файловой системы. Запись в директории имеет определенный для данной ОС формат, зачастую неизвестный пользователю, поэтому блоки данных файла-директории заполняются не через операции записи, а при помощи специальных системных вызовов (например, создание файла).</p><div  class="lecture_mark" id="mark_61"></div><p  id="id_62">Для доступа к файлу ОС использует путь (pathname), сообщенный пользователем. Запись в директории связывает имя файла или имя поддиректории с блоками данных на диске (см. <a href="">рис. 12.6</a>). В зависимости от способа выделения файлу блоков диска (см. раздел "Методы выделения дискового пространства") эта ссылка может быть номером первого блока или номером <span class="keyword">индексного узла</span>. В любом случае обеспечивается <span class="keyword">связь</span> символьного имени файла с данными на диске.</p><div  class="lecture_mark" id="mark_62"></div><p  align="left" id="id_63"><a name="image.12.6"></a><div><img src="12. Реализация файловой системы_files/12-60000.gif" alt="Реализация директорий" width="428" height="158"></div><br><b>Рис. 12.6.</b> 
        Реализация директорий</p><div  class="lecture_mark" id="mark_63"></div><p  id="id_64">Когда система открывает файл, она ищет его имя в директории. Затем из записи в директории или из структуры, на которую запись в директории указывает, извлекаются атрибуты и адреса блоков файла на диске. Эта информация помещается в системную таблицу в главной памяти. Все последующие ссылки на данный файл используют эту информацию. Атрибуты файла можно хранить непосредственно в записи в директории, как показано на <a href="">рис. 12.6</a>. Однако для организации <span class="keyword">совместного доступа к файлам</span> удобнее хранить атрибуты в <span class="keyword">индексном узле</span>, как это делается в Unix.</p><div  class="lecture_mark" id="mark_64"></div><p  id="id_65">Рассмотрим несколько конкретных примеров.</p><div  class="lecture_mark" id="mark_65"></div><h4 >Примеры реализации директорий в некоторых ОС</h4><h5 >Директории в ОС MS-DOS</h5><p  id="id_66">В ОС MS-DOS типовая запись в директории имеет вид, показанный на <a href="">рис. 12.7</a>.</p><div  class="lecture_mark" id="mark_66"></div><p  align="left" id="id_67"><a name="image.12.7"></a><div><img src="12. Реализация файловой системы_files/12-70000.gif" alt="Вариант записи в директории MS-DOS" width="425" height="113"></div><br><b>Рис. 12.7.</b> 
        Вариант записи в директории MS-DOS</p><div  class="lecture_mark" id="mark_67"></div><p  id="id_68">В ОС MS-DOS, как и в большинстве современных ОС, директории могут содержать поддиректории (специфицируемые битом атрибута), что позволяет конструировать произвольное дерево директорий файловой системы.</p><div  class="lecture_mark" id="mark_68"></div><p  id="id_69">Номер первого блока используется в качестве индекса в таблице <span class="keyword">FAT</span>. Далее по цепочке в этой таблице могут быть найдены остальные блоки.</p><div  class="lecture_mark" id="mark_69"></div><h5 >Директории в ОС Unix</h5><p  id="id_70">Структура директории проста. Каждая запись содержит имя файла и номер его <span class="keyword">индексного узла</span> (см. <a href="">рис. 12.8</a>). Вся остальная информация о файле (тип, размер, время модификации, владелец и т. д. и номера дисковых блоков) находится в <span class="keyword">индексном узле</span>.</p><div  class="lecture_mark" id="mark_70"></div><p  align="left" id="id_71"><a name="image.12.8"></a><div><img src="12. Реализация файловой системы_files/12-80000.gif" alt="Вариант записи в директории Unix" width="280" height="69"></div><br><b>Рис. 12.8.</b> 
        Вариант записи в директории Unix</p><div  class="lecture_mark" id="mark_71"></div><p  id="id_72">В более поздних версиях Unix форма записи претерпела ряд изменений, например имя файла описывается структурой. Однако суть осталась прежней.</p><div  class="lecture_mark" id="mark_72"></div><h4 >Поиск в директории</h4><p  id="id_73">Список файлов в директории обычно не является упорядоченным по именам файлов. Поэтому правильный выбор алгоритма поиска имени файла в директории имеет большое влияние на эффективность и надежность файловых систем.</p><div  class="lecture_mark" id="mark_73"></div><h5 >Линейный поиск</h5><p  id="id_74">Существует несколько стратегий просмотра списка символьных имен. Простейшей из них является линейный поиск. Директория просматривается с самого начала, пока не встретится нужное имя файла. Хотя это наименее эффективный способ поиска, оказывается, что в большинстве случаев он работает с приемлемой производительностью. Например, авторы Unix утверждали, что линейного поиска вполне достаточно. По-видимому, это связано с тем, что на фоне относительно медленного доступа к диску некоторые задержки, возникающие в процессе сканирования списка, несущественны.</p><div  class="lecture_mark" id="mark_74"></div><p  id="id_75">Метод прост, но требует временных затрат. Для создания нового файла вначале нужно проверить директорию на наличие такого же имени. Затем имя нового файла вставляется в конец директории (если, разумеется, файл с таким же именем в директории не существует, в противном случае нужно информировать пользователя). Для удаления файла нужно также выполнить поиск его имени в списке и пометить запись как неиспользуемую.</p><div  class="lecture_mark" id="mark_75"></div><p  id="id_76">Реальный недостаток данного метода - последовательный поиск файла. Информация о структуре директории используется часто, и неэффективный способ поиска будет заметен пользователями. Можно свести поиск к бинарному, если отсортировать список файлов. Однако это усложнит создание и удаление файлов, так как требуется перемещение большого объема информации.</p><div  class="lecture_mark" id="mark_76"></div><h5 >Хеш-таблица</h5><p  id="id_77">Хеширование (см. например, [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#10">Ахо, 2001</a>]) - другой способ, который может использоваться для размещения и последующего поиска имени файла в директории. В данном методе имена файлов также хранятся в каталоге в виде линейного списка, но дополнительно используется хеш-таблица. Хеш-таблица, точнее построенная на ее основе хеш-функция, позволяет по имени файла получить указатель на имя файла в списке. Таким образом, можно существенно уменьшить время поиска.</p><div  class="lecture_mark" id="mark_77"></div><p  id="id_78">В результате хеширования могут возникать коллизии, то есть ситуации, когда функция хеширования, примененная к разным именам файлов, дает один и тот же результат. Обычно имена таких файлов объединяют в связные списки, предполагая в дальнейшем осуществление в них последовательного поиска нужного имени файла. Выбор подходящего алгоритма хеширования позволяет свести к минимуму число коллизий. Однако всегда есть вероятность неблагоприятного исхода, когда непропорционально большому числу имен файлов функция хеширования ставит в соответствие один и тот же результат. В таком случае преимущество использования этой схемы по сравнению с последовательным поиском практически утрачивается.</p><div  class="lecture_mark" id="mark_78"></div><h5 >Другие методы поиска</h5><p  id="id_79">Помимо описанных методов поиска имени файла, в директории существуют и другие. В качестве примера можно привести организацию поиска в каталогах файловой системы NTFS при помощи так называемого B-дерева, которое стало стандартным способом организации индексов в системах баз данных (см. [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#10">Ахо, 2001</a>]).</p><div  class="lecture_mark" id="mark_79"></div><h3 >Монтирование файловых систем</h3><p  id="id_80">Так же как файл должен быть открыт перед использованием, и файловая система, хранящаяся на разделе диска, должна быть смонтирована, чтобы стать доступной процессам системы.</p><div  class="lecture_mark" id="mark_80"></div><p  id="id_81">Функция <span class="texample">mount</span> (монтировать) связывает файловую систему из указанного раздела на диске с существующей иерархией файловых систем, а функция <span class="texample">umount</span> (демонтировать) выключает файловую систему из иерархии. Функция <span class="texample">mount</span>, таким образом, дает пользователям возможность обращаться к данным в дисковом разделе как к файловой системе, а не как к последовательности дисковых блоков.</p><div  class="lecture_mark" id="mark_81"></div><p  id="id_85"><a name="keyword-context.2"></a>Процедура <span class="keyword_def">монтирования</span> состоит в следующем. Пользователь (в Unix это суперпользователь) сообщает ОС имя устройства и место в файловой структуре (имя пустого каталога), куда нужно присоединить файловую систему (точка <span class="keyword">монтирования</span>) (см. <a href="">рис. 12.9</a> и <a href="">рис. 12.10</a>). Hапример, в ОС Unix библиотечный вызов <span class="texample">mount</span> имеет вид:</p><div  class="lecture_mark" id="mark_85"></div><div  class="example"><pre>
mount(special pathname,directory pathname,options);
</pre></div><p  id="id_88">где <span class="texample">special pathname</span> - имя специального файла устройства (в общем случае имя раздела), соответствующего дисковому разделу с монтируемой файловой системой, <span class="texample">directory pathname</span> - каталог в существующей иерархии, где будет монтироваться файловая система (другими словами, точка или место <span class="keyword">монтирования</span>), а <span class="texample">options</span> указывает, следует ли монтировать файловую систему "только для чтения" (при этом не будут выполняться такие функции, как <span class="texample">write</span> и <span class="texample">create</span>, которые производят запись в файловую систему). Затем ОС должна убедиться, что устройство содержит действительную файловую систему ожидаемого формата с <span class="keyword">суперблоком</span>, списком индексов и корневым индексом.</p><div  class="lecture_mark" id="mark_88"></div><p  id="id_94">Некоторые ОС осуществляют <span class="keyword">монтирование</span> автоматически, как только встретят диск в первый раз (жесткие диски на этапе загрузки, гибкие - когда они вставлены в дисковод), ОС ищет файловую систему на устройстве. Если файловая система на устройстве имеется, она монтируется на корневом уровне, при этом к цепочке имен абсолютного имени файла (pathname) добавляется буква раздела.</p><div  class="lecture_mark" id="mark_94"></div><p  align="left" id="id_95"><a name="image.12.9"></a><div><img src="12. Реализация файловой системы_files/12-90000.gif" alt="Две файловые системы до монтирования" width="426" height="158"></div><br><b>Рис. 12.9.</b> 
        Две файловые системы до монтирования</p><div  class="lecture_mark" id="mark_95"></div><p  align="left" id="id_96"><a name="image.12.10"></a><div><img src="12. Реализация файловой системы_files/12-10001.gif" alt="Общая файловая система после монтирования" width="279" height="210"></div><br><b>Рис. 12.10.</b> 
        Общая файловая система после монтирования</p><div  class="lecture_mark" id="mark_96"></div><p  id="id_97">Ядро поддерживает таблицу <span class="keyword">монтирования</span> с записями о каждой смонтированной файловой системе. В каждой записи содержится информация о вновь смонтированном устройстве, о его <span class="keyword">суперблоке</span> и корневом каталоге, а также сведения о точке <span class="keyword">монтирования</span>. Для устранения потенциально опасных побочных эффектов число <span class="keyword">линков</span> (см. следующий раздел) к каталогу - точке <span class="keyword">монтирования</span> - должно быть равно 1. Занесение информации в таблицу <span class="keyword">монтирования</span> производится немедленно, поскольку может возникнуть конфликт между двумя процессами. Например, если монтирующий процесс приостановлен для открытия устройства или считывания <span class="keyword">суперблока</span> файловой системы, а тем временем другой процесс может попытаться смонтировать файловую систему.</p><div  class="lecture_mark" id="mark_97"></div><p  id="id_98">Наличие в логической структуре файлового архива точек <span class="keyword">монтирования</span> требует аккуратной реализации алгоритмов, осуществляющих навигацию по каталогам. Точку <span class="keyword">монтирования</span> можно пересечь двумя способами: из файловой системы, где производится <span class="keyword">монтирование</span>, в файловую систему, которая монтируется (в направлении от глобального корня к листу), и в обратном направлении. Алгоритмы поиска файлов должны предусматривать ситуации, в которых очередной компонент пути к файлу является точкой <span class="keyword">монтирования</span>, когда вместо анализа <span class="keyword">индексного узла</span> очередной директории приходится осуществлять обработку <span class="keyword">суперблока</span> монтированной системы.</p><div  class="lecture_mark" id="mark_98"></div><h3 >Связывание файлов</h3><p  id="id_99">Иерархическая организация, положенная в основу древовидной структуры файловой системы современных ОС, не предусматривает выражения отношений, в которых потомки связываются более чем с одним предком. Такая негибкость частично устраняется возможностью реализации связывания файлов или организации <span class="keyword">линков</span> (<span class="keyword">link</span>).</p><div  class="lecture_mark" id="mark_99"></div><p  id="id_100">Ядро позволяет пользователю связывать каталоги, упрощая написание программ, требующих пересечения дерева файловой системы (см. <a href="">рис. 12.11</a>). Часто имеет смысл хранить под разными именами одну и ту же команду (выполняемый файл). Например, выполняемый файл традиционного текстового редактора ОС Unix <span class="texample">vi</span> обычно может вызываться под именами <span class="texample">ex</span>, <span class="texample">edit</span>, <span class="texample">vi</span>, <span class="texample">view</span> и <span class="texample">vedit</span> файловой системы. Соединение между директорией и разделяемым файлом называется <span class="keyword">"связью"</span> или "ссылкой" (<span class="keyword">link</span>). Дерево файловой системы превращается в циклический граф.</p><div  class="lecture_mark" id="mark_100"></div><p  id="id_107">Это удобно, но создает ряд дополнительных проблем.</p><div  class="lecture_mark" id="mark_107"></div><p  id="id_108">Простейший способ реализовать связывание файла - просто дублировать информацию о нем в обеих директориях. При этом, однако, может возникнуть проблема совместимости в случае, если владельцы этих директорий попытаются независимо друг от друга изменить содержимое файла. Например, в ОС CP/M запись в директории о файле непосредственно содержит адреса дисковых блоков. Поэтому копии тех же дисковых адресов должны быть сделаны и в другой директории, куда файл линкуется. Если один из пользователей что-то добавляет к файлу, новые блоки будут перечислены только у него в директории и не будут "видны" другому пользователю.</p><div  class="lecture_mark" id="mark_108"></div><p  align="left" id="id_109"><a name="image.12.11"></a><div><img src="12. Реализация файловой системы_files/12-11000.gif" alt="Структура файловой системы с возможностью связывания файла с новым именем" width="324" height="233"></div><br><b>Рис. 12.11.</b> 
        Структура файловой системы с возможностью связывания файла с новым именем</p><div  class="lecture_mark" id="mark_109"></div><p  id="id_110">Проблема такого рода может быть решена двумя способами. Первый из них - так называемая <b>жесткая </b> <span class="keyword">связь</span> (hard link). Если блоки данных файла перечислены не в директории, а в небольшой структуре данных (например, в <span class="keyword">индексном узле</span>), связанной собственно с файлом, то второй пользователь может связаться непосредственно с этой, уже существующей структурой.</p><div  class="lecture_mark" id="mark_110"></div><p  id="id_111">Альтернативное решение - создание нового файла, который содержит путь к связываемому файлу. Такой подход называется <b>символической</b> линковкой (soft или symbolic link). При этом в соответствующем каталоге создается элемент, в котором имени <span class="keyword">связи</span> сопоставляется некоторое имя файла (этот файл даже не обязан существовать к моменту создания символической <span class="keyword">связи</span>). Для символической <span class="keyword">связи</span> может создаваться отдельный <span class="keyword">индексный узел</span> и даже заводиться отдельный блок данных для хранения потенциально длинного имени файла.</p><div  class="lecture_mark" id="mark_111"></div><p  id="id_112">Каждый из этих методов имеет свои минусы. В случае жесткой <span class="keyword">связи</span> возникает необходимость поддержки счетчика ссылок на файл для корректной реализации операции удаления файла. Например, в Unix такой счетчик является одним из атрибутов, хранящихся в <span class="keyword">индексном узле</span>. Удаление файла одним из пользователей уменьшает количество ссылок на файл на 1. Реальное удаление файла происходит, когда число ссылок на файл становится равным 0.</p><div  class="lecture_mark" id="mark_112"></div><p  id="id_113">В случае символической линковки такая проблема не возникает, так как только реальный владелец имеет ссылку на <span class="keyword">индексный узел</span> файла. Если собственник удаляет файл, то он разрушается, и попытки других пользователей работать с ним закончатся провалом. Удаление символического <span class="keyword">линка</span> на файл никак не влияет. Проблема организации символической <span class="keyword">связи</span> - потенциальное снижение скорости доступа к файлу. Файл символического <span class="keyword">линка</span> хранит путь к файлу, содержащий список вложенных директорий, для прохождения по которому необходимо осуществить несколько обращений к диску.</p><div  class="lecture_mark" id="mark_113"></div><p  id="id_114">Символический <span class="keyword">линк</span> имеет то преимущество, что он может использоваться для организации удобного доступа к файлам удаленных компьютеров, если, например, добавить к пути сетевой адрес удаленной машины.</p><div  class="lecture_mark" id="mark_114"></div><p  id="id_115">Циклический граф - структура более гибкая, нежели простое дерево, но работа с ней требует большой аккуратности. Поскольку теперь к файлу существует несколько путей, программа поиска файла может найти его на диске несколько раз. Простейшее практическое решение данной проблемы - ограничить число директорий при поиске. Полное устранение циклов при поиске - довольно трудоемкая процедура, выполняемая специальными утилитами и связанная с многократной трассировкой директорий файловой системы.</p><div  class="lecture_mark" id="mark_115"></div><h3 >Кооперация процессов при работе с файлами</h3><p  id="id_116">Когда различные пользователи работают вместе над проектом, они часто нуждаются в разделении файлов.</p><div  class="lecture_mark" id="mark_116"></div><p  id="id_117">Разделяемый файл - разделяемый ресурс. Как и в случае любого совместно используемого ресурса, процессы должны синхронизировать доступ к совместно используемым файлам, каталогам, чтобы избежать тупиковых ситуаций, дискриминации отдельных процессов и снижения производительности системы.</p><div  class="lecture_mark" id="mark_117"></div><p  id="id_118">Например, если несколько пользователей одновременно редактируют какой-либо файл и не принято специальных мер, то результат будет непредсказуем и зависит от того, в каком порядке осуществлялись записи в файл. Между двумя операциями read одного процесса другой процесс может модифицировать данные, что для многих приложений неприемлемо. Простейшее решение данной проблемы - предоставить возможность одному из процессов захватить файл, то есть блокировать доступ к разделяемому файлу других процессов на все время, пока файл остается открытым для данного процесса. Однако это было бы недостаточно гибко и не соответствовало бы характеру поставленной задачи.</p><div  class="lecture_mark" id="mark_118"></div><p  id="id_119">Рассмотрим вначале <b>грубый</b> подход, то есть временный захват пользовательским процессом файла или записи (части файла между указанными позициями).</p><div  class="lecture_mark" id="mark_119"></div><p  id="id_120">Системный вызов, позволяющий установить и проверить блокировки на файл, является неотъемлемым атрибутом современных многопользовательских ОС. В принципе, было бы логично связать синхронизацию доступа к файлу как к единому целому с системным вызовом open (т. е., например, открытие файла в режиме записи или обновления могло бы означать его монопольную блокировку соответствующим процессом, а открытие в режиме чтения - совместную блокировку). Так поступают во многих операционных системах (начиная с ОС Multics). В ОС Unix это не так, что имеет исторические причины.</p><div  class="lecture_mark" id="mark_120"></div><p  id="id_121">В первой версии системы Unix, разработанной Томпсоном и Ричи, механизм захвата файла отсутствовал. Применялся очень простой подход к обеспечению параллельного (от нескольких процессов) доступа к файлам: система позволяла любому числу процессов одновременно открывать один и тот же файл в любом режиме (чтения, записи или обновления) и не предпринимала никаких синхронизационных действий. Вся ответственность за корректность совместной обработки файла ложилась на использующие его процессы, и система даже не предоставляла каких-либо особых средств для синхронизации доступа процессов к файлу. Однако впоследствии для того, чтобы повысить привлекательность системы для коммерческих пользователей, работающих с базами данных, в версию V системы были включены механизмы захвата файла и записи, базирующиеся на системном вызове <span class="texample">fcntl</span>.</p><div  class="lecture_mark" id="mark_121"></div><p  id="id_123">Допускается два варианта синхронизации: с ожиданием, когда требование блокировки может привести к откладыванию процесса до того момента, когда это требование может быть удовлетворено, и без ожидания, когда процесс немедленно оповещается об удовлетворении требования блокировки или о невозможности ее удовлетворения в данный момент.</p><div  class="lecture_mark" id="mark_123"></div><p  id="id_124">Установленные блокировки относятся только к тому процессу, который их установил, и не наследуются процессами-потомками этого процесса. Более того, даже если некоторый процесс пользуется синхронизационными возможностями системного вызова <span class="texample">fcntl</span>, другие процессы по-прежнему могут работать с тем файлом без всякой синхронизации. Другими словами, это дело группы процессов, совместно использующих файл, - договориться о способе синхронизации параллельного доступа.</p><div  class="lecture_mark" id="mark_124"></div><p  id="id_126">Более тонкий подход заключается в прозрачной для пользователя блокировке отдельных структур ядра, отвечающих за работу с файлами части пользовательских данных. Например, в ОС Unix во время системного вызова, осуществляющего ту или иную операцию с файлом, как правило, происходит блокирование <span class="keyword">индексного узла</span>, содержащего адреса блоков данных файла. Может показаться, что организация блокировок или запрета более чем одному процессу работать с файлом во время выполнения системного вызова является излишней, так как в подавляющем большинстве случаев выполнение системных вызовов и так не прерывается, то есть ядро работает в условиях невытесняющей многозадачности. Однако в данном случае это не совсем так. Операции чтения и записи занимают продолжительное время и лишь инициируются центральным процессором, а осуществляются по независимым каналам, поэтому установка блокировок на время системного вызова является необходимой гарантией атомарности операций чтения и записи. На практике оказывается достаточным заблокировать один из буферов кэша диска, в заголовке которого ведется список процессов, ожидающих освобождения данного буфера. Таким образом, в соответствии с семантикой Unix изменения, сделанные одним пользователем, немедленно становятся "видны" другому пользователю, который держит данный файл открытым одновременно с первым.</p><div  class="lecture_mark" id="mark_126"></div><h4 >Примеры разрешения коллизий и тупиковых ситуаций</h4><p  id="id_127">Логика работы системы в сложных ситуациях может проиллюстрировать особенности организации мультидоступа.</p><div  class="lecture_mark" id="mark_127"></div><p  id="id_128">Рассмотрим в качестве примера <b>образование потенциального тупика</b> при создании <span class="keyword">связи</span> (<span class="keyword">link</span>), когда разрешен <span class="keyword">совместный доступ к файлу</span> [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#1">Bach, 1986</a>].</p><div  class="lecture_mark" id="mark_128"></div><p  id="id_129">Два процесса, выполняющие одновременно следующие функции: </p><div  class="lecture_mark" id="mark_129"></div><div  class="example"><pre>
процесс A: 		link("a/b/c/d","e/f/g");
процесс B: 		link("e/f","a/b/c/d/ee");
</pre></div><p  id="id_131">могут зайти в тупик. Предположим, что процесс A обнаружил индекс файла <span class="texample">"a/b/c/d"</span> в тот самый момент, когда процесс B обнаружил индекс файла <span class="texample">"e/f"</span>. Фраза "в тот же самый момент" означает, что системой достигнуто состояние, при котором каждый процесс получил искомый индекс. Когда же теперь процесс A попытается получить индекс файла <span class="texample">"e/f"</span>, он приостановит свое выполнение до тех пор, пока индекс файла <span class="texample">"f"</span> не освободится. В то же время процесс B пытается получить индекс каталога <span class="texample">"a/b/c/d"</span> и приостанавливается в ожидании освобождения индекса файла <span class="texample">"d"</span>. Процесс A будет удерживать заблокированным индекс, нужный процессу B, а процесс B, в свою очередь, будет удерживать заблокированным индекс, необходимый процессу A.</p><div  class="lecture_mark" id="mark_131"></div><p  id="id_138">Для предотвращения этого классического примера взаимной блокировки в файловой системе принято, чтобы ядро освобождало индекс исходного файла после увеличения значения счетчика <span class="keyword">связей</span>. Тогда, поскольку первый из ресурсов (индекс) свободен при обращении к следующему ресурсу, взаимной блокировки не происходит.</p><div  class="lecture_mark" id="mark_138"></div><p  id="id_139">Поводов для нежелательной <b>конкуренции</b> между процессами много, особенно <b>при удалении</b> имен каталогов. Предположим, что один процесс пытается найти данные файла по его полному символическому имени, последовательно проходя компонент за компонентом, а другой процесс удаляет каталог, имя которого входит в путь поиска. Допустим, процесс A делает разбор имени <span class="texample">"a/b/c/d"</span> и приостанавливается во время получения <span class="keyword">индексного узла</span> для файла <span class="texample">"c"</span>. Он может приостановиться при попытке заблокировать <span class="keyword">индексный узел</span> или при попытке обратиться к дисковому блоку, где этот <span class="keyword">индексный узел</span> хранится. Если процессу B нужно удалить <span class="keyword">связь</span> для каталога с именем <span class="texample">"c"</span>, он может приостановиться по той же самой причине, что и процесс A. Пусть ядро впоследствии решит возобновить процесс B раньше процесса A. Прежде чем процесс A продолжит свое выполнение, процесс B завершится, удалив <span class="keyword">связь</span> каталога <span class="texample">"c"</span> и его содержимое по этой <span class="keyword">связи</span>. Позднее процесс A попытается обратиться к несуществующему <span class="keyword">индексному узлу</span>, который уже был удален. Алгоритм поиска файла, проверяющий в первую очередь неравенство значения счетчика <span class="keyword">связей</span>&gt; нулю, должен сообщить об ошибке.</p><div  class="lecture_mark" id="mark_139"></div><p  id="id_144">Можно привести и другие примеры, которые демонстрируют необходимость тщательного проектирования файловой системы для ее последующей надежной работы.</p><div  class="lecture_mark" id="mark_144"></div><h3 >Hадежность файловой системы</h3><p  id="id_145">Жизнь полна неприятных неожиданностей, а разрушение файловой системы зачастую более опасно, чем разрушение компьютера. Поэтому файловые системы должны разрабатываться с учетом подобной возможности. Помимо очевидных решений, например своевременное дублирование информации (backup), файловые системы современных ОС содержат специальные средства для поддержки собственной совместимости.</p><div  class="lecture_mark" id="mark_145"></div><h4 >Целостность файловой системы</h4><p  id="id_146">Важный аспект надежной работы файловой системы - контроль ее целостности. В результате файловых операций блоки диска могут считываться в память, модифицироваться и затем записываться на диск. Причем многие файловые операции затрагивают сразу несколько объектов файловой системы. Например, копирование файла предполагает выделение ему блоков диска, формирование <span class="keyword">индексного узла</span>, изменение содержимого каталога и т. д. В течение короткого периода времени между этими шагами информация в файловой системе оказывается несогласованной.</p><div  class="lecture_mark" id="mark_146"></div><p  id="id_147">И если вследствие непредсказуемой остановки системы на диске будут сохранены изменения только для части этих объектов (нарушена атомарность файловой операции), файловая система на диске может быть оставлена в несовместимом состоянии. В результате могут возникнуть нарушения логики работы с данными, например появиться "потерянные" блоки диска, которые не принадлежат ни одному файлу и в то же время помечены как занятые, или, наоборот, блоки, помеченные как свободные, но в то же время занятые (на них есть ссылка в <span class="keyword">индексном узле</span>) или другие нарушения.</p><div  class="lecture_mark" id="mark_147"></div><p  id="id_148">В современных ОС предусмотрены меры, которые позволяют свести к минимуму ущерб от порчи файловой системы и затем полностью или частично восстановить ее целостность.</p><div  class="lecture_mark" id="mark_148"></div><h5 >Порядок выполнения операций</h5><p  id="id_149">Очевидно, что для правильного функционирования файловой системы значимость отдельных данных неравноценна. Искажение содержимого пользовательских файлов не приводит к серьезным (с точки зрения целостности файловой системы) последствиям, тогда как несоответствия в файлах, содержащих управляющую информацию (директории, <span class="keyword">индексные узлы</span>, <span class="keyword">суперблок</span> и т. п.), могут быть катастрофическими. Поэтому должен быть тщательно продуман порядок выполнения операций со структурами данных файловой системы.</p><div  class="lecture_mark" id="mark_149"></div><p  id="id_150">Рассмотрим пример создания жесткой <span class="keyword">связи</span> для файла [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#33">Робачевский, 1999</a>]. Для этого файловой системе необходимо выполнить следующие операции:</p><div  class="lecture_mark" id="mark_150"></div><ul  id="id_151"><li>создать новую запись в каталоге, указывающую на <span class="keyword">индексный узел</span> файла;</li><li>увеличить счетчик <span class="keyword">связей</span> в <span class="keyword">индексном узле</span>.</li></ul><div  class="lecture_mark" id="mark_151"></div><p  id="id_154">Если аварийный останов произошел между 1-й и 2-й операциями, то в каталогах файловой системы будут существовать два имени файла, адресующих <span class="keyword">индексный узел</span> со значением счетчика <span class="keyword">связей</span>, равному 1. Если теперь будет удалено одно из имен, это приведет к удалению файла как такового. Если же порядок операций изменен и, как прежде, останов произошел между первой и второй операциями, файл будет иметь несуществующую жесткую <span class="keyword">связь</span>, но существующая запись в каталоге будет правильной. Хотя это тоже является ошибкой, но ее последствия менее серьезны, чем в предыдущем случае.</p><div  class="lecture_mark" id="mark_154"></div><h5 >Журнализация</h5><p  id="id_155">Другим средством поддержки целостности является заимствованный из систем управления базами данных прием, называемый <span class="keyword">журнализация</span> (иногда употребляется термин <span class="keyword">"журналирование"</span>). Последовательность действий с объектами во время файловой операции протоколируется, и если произошел останов системы, то, имея в наличии протокол, можно осуществить откат системы назад в исходное целостное состояние, в котором она пребывала до начала операции. Подобная избыточность может стоить дорого, но она оправданна, так как в случае отказа позволяет реконструировать потерянные данные.</p><div  class="lecture_mark" id="mark_155"></div><p  id="id_156">Для отката необходимо, чтобы для каждой протоколируемой в журнале операции существовала обратная. Например, для каталогов и реляционных СУБД это именно так. По этой причине, в отличие от СУБД, в файловых системах протоколируются не все изменения, а лишь изменения метаданных (<span class="keyword">индексных узлов</span>, записей в каталогах и др.). Изменения в данных пользователя в протокол не заносятся. Кроме того, если протоколировать изменения пользовательских данных, то этим будет нанесен серьезный ущерб производительности системы, поскольку <span class="keyword">кэширование</span> потеряет смысл.</p><div  class="lecture_mark" id="mark_156"></div><p  id="id_157"><span class="keyword">Журнализация</span> реализована в NTFS, Ext3FS, ReiserFS и других системах. Чтобы подчеркнуть сложность задачи, нужно отметить, что существуют не вполне очевидные проблемы, связанные с процедурой отката. Например, отмена одних изменений может затрагивать данные, уже использованные другими файловыми операциями. Это означает, что такие операции также должны быть отменены. Данная проблема получила название каскадного отката транзакций [Брукшир, 2001]</p><div  class="lecture_mark" id="mark_157"></div><h5 >Проверка целостности файловой системы при помощи утилит</h5><p  id="id_158">Если же нарушение все же произошло, то для устранения проблемы несовместимости можно прибегнуть к утилитам (fsck, chkdsk, scandisk и др.), которые проверяют целостность файловой системы. Они могут запускаться после загрузки или после сбоя и осуществляют многократное сканирование разнообразных структур данных файловой системы в поисках противоречий.</p><div  class="lecture_mark" id="mark_158"></div><p  id="id_159">Возможны также эвристические проверки. Hапример, нахождение <span class="keyword">индексного узла</span>, номер которого превышает их число на диске или поиск в пользовательских директориях файлов, принадлежащих суперпользователю.</p><div  class="lecture_mark" id="mark_159"></div><p  id="id_160">К сожалению, приходится констатировать, что <b>не существует никаких средств, гарантирующих абсолютную сохранность</b> информации в файлах, и в тех ситуациях, когда целостность информации нужно гарантировать с высокой степенью надежности, прибегают к дорогостоящим процедурам дублирования.</p><div  class="lecture_mark" id="mark_160"></div><h4 >Управление "плохими" блоками </h4><p  id="id_161">Наличие дефектных блоков на диске - обычное дело. Внутри блока наряду с данными хранится контрольная сумма данных. Под "плохими" блоками обычно понимают блоки диска, для которых вычисленная контрольная сумма считываемых данных не совпадает с хранимой контрольной суммой. Дефектные блоки обычно появляются в процессе эксплуатации. Иногда они уже имеются при поставке вместе со списком, так как  очень затруднительно для поставщиков сделать диск полностью свободным от дефектов. Рассмотрим два решения проблемы дефектных блоков - одно на уровне аппаратуры, другое на уровне ядра ОС.</p><div  class="lecture_mark" id="mark_161"></div><p  id="id_162">Первый способ - хранить список плохих блоков в контроллере диска. Когда контроллер инициализируется, он читает плохие блоки и замещает дефектный блок резервным, помечая отображение в списке плохих блоков. Все реальные запросы будут идти к резервному блоку. Следует иметь в виду, что при этом механизм подъемника (наиболее распространенный механизм обработки запросов к блокам диска) будет работать неэффективно. Дело в том, что существует стратегия очередности обработки запросов к диску (подробнее см. лекцию "ввод-вывод"). Стратегия диктует направление движения считывающей головки диска к нужному цилиндру. Обычно резервные блоки размещаются на внешних цилиндрах. Если плохой блок расположен на внутреннем цилиндре и контроллер осуществляет подстановку прозрачным образом, то кажущееся движение головки будет осуществляться к внутреннему цилиндру, а фактическое - к внешнему. Это является нарушением стратегии и, следовательно, минусом данной схемы.</p><div  class="lecture_mark" id="mark_162"></div><p  id="id_163">Решение на уровне ОС может быть следующим. Прежде всего, необходимо тщательно сконструировать файл, содержащий дефектные блоки. Тогда они изымаются из списка свободных блоков. Затем нужно каким-то образом скрыть этот файл от прикладных программ.</p><div  class="lecture_mark" id="mark_163"></div><h3 >Производительность файловой системы</h3><p  id="id_164">Поскольку обращение к диску - операция относительно медленная, минимизация количества таких обращений - ключевая задача всех алгоритмов, работающих с внешней памятью. Наиболее типичная техника повышения скорости работы с диском - <span class="keyword">кэширование</span>.</p><div  class="lecture_mark" id="mark_164"></div><h4 >Кэширование</h4><p  id="id_165">Кэш диска представляет собой буфер в оперативной памяти, содержащий ряд блоков диска (см. <a href="">рис. 12.12</a>). Если имеется запрос на чтение/запись блока диска, то сначала производится проверка на предмет наличия этого блока в кэше. Если блок в кэше имеется, то запрос удовлетворяется из кэша, в противном случае запрошенный блок считывается в кэш с диска. Сокращение количества дисковых операций оказывается возможным вследствие присущего ОС свойства локальности (о свойстве локальности много говорилось в лекциях, посвященных описанию работы системы управления памятью).</p><div  class="lecture_mark" id="mark_165"></div><p  id="id_166">Аккуратная реализация <span class="keyword">кэширования</span> требует решения нескольких проблем.</p><div  class="lecture_mark" id="mark_166"></div><p  id="id_167"><b>Во-первых</b>, емкость буфера кэша ограничена. Когда блок должен быть загружен в заполненный буфер кэша, возникает <b>проблема замещения</b> блоков, то есть отдельные блоки должны быть удалены из него. Здесь работают те же стратегии и те же FIFO, Second Chance и LRU-алгоритмы замещения, что и при выталкивании страниц памяти.</p><div  class="lecture_mark" id="mark_167"></div><p  align="left" id="id_168"><a name="image.12.12"></a><div><img src="12. Реализация файловой системы_files/12-12000.gif" alt="Структура блочного кэша" width="427" height="232"></div><br><b>Рис. 12.12.</b> 
        Структура блочного кэша</p><div  class="lecture_mark" id="mark_168"></div><p  id="id_169">Замещение блоков должно осуществляться с учетом их важности для файловой системы. Блоки должны быть разделены на категории, например: блоки <span class="keyword">индексных узлов</span>, блоки косвенной адресации, блоки директорий, заполненные блоки данных и т. д., и в зависимости от принадлежности блока к той или иной категории можно применять к ним разную стратегию замещения.</p><div  class="lecture_mark" id="mark_169"></div><p  id="id_170"><b>Во-вторых</b>, поскольку <span class="keyword">кэширование</span> использует механизм отложенной записи, при котором модификация буфера не вызывает немедленной записи на диск, серьезной проблемой является "старение" информации в дисковых блоках, образы которых находятся в буферном кэше. Несвоевременная <b>синхронизация</b> буфера кэша и диска может привести к очень нежелательным последствиям в случае отказов оборудования или программного обеспечения. Поэтому стратегия и порядок отображения информации из кэша на диск должна быть тщательно продумана.</p><div  class="lecture_mark" id="mark_170"></div><p  id="id_171">Так, блоки, существенные для совместимости файловой системы (блоки <span class="keyword">индексных узлов</span>, блоки косвенной адресации, блоки директорий), должны быть переписаны на диск немедленно, независимо от того, в какой части LRU-цепочки они находятся. Hеобходимо тщательно выбрать порядок такого переписывания.</p><div  class="lecture_mark" id="mark_171"></div><p  id="id_172">В Unix имеется для этого вызов SYNC, который заставляет все модифицированные блоки записываться на диск немедленно. Для синхронизации содержимого кэша и диска периодически запускается фоновый процесс-демон. Кроме того, можно организовать синхронный режим работы с отдельными файлами, задаваемый при открытии файла, когда все изменения в файле немедленно сохраняются на диске.</p><div  class="lecture_mark" id="mark_172"></div><p  id="id_173"><b>Наконец</b>, проблема конкуренции процессов на доступ к блокам кэша решается ведением списков блоков, пребывающих в различных состояниях, и отметкой о состоянии блока в его дескрипторе. Например, блок может быть заблокирован, участвовать в операции ввода-вывода, а также иметь список процессов, ожидающих освобождения данного блока.</p><div  class="lecture_mark" id="mark_173"></div><h4 >Оптимальное размещение информации на диске</h4><p  id="id_174"><span class="keyword">Кэширование</span> - <b>не единственный</b> способ увеличения производительности системы. Другая важная техника - сокращение количества движений считывающей головки диска за счет разумной стратегии размещения информации. Например, массив <span class="keyword">индексных узлов</span> в Unix стараются разместить на средних дорожках. Также имеет смысл размещать <span class="keyword">индексные узлы</span> поблизости от блоков данных, на которые они ссылаются и т. д.</p><div  class="lecture_mark" id="mark_174"></div><p  id="id_175">Кроме того, рекомендуется периодически осуществлять дефрагментацию диска (сборку мусора), поскольку в популярных методиках выделения дисковых блоков (за исключением, может быть, <span class="keyword">FAT</span>) принцип локальности не работает, и последовательная обработка файла требует обращения к различным участкам диска.</p><div  class="lecture_mark" id="mark_175"></div><h3 >Реализация некоторых операций над файлами</h3><p  id="id_176">В предыдущей лекции перечислены основные операции над файлами. В данном разделе будет описан порядок работы некоторых системных вызовов для работы с файловой системой, следуя главным образом [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#1">Bach, 1986</a>], с учетом совокупности введенных в данной лекции понятий.</p><div  class="lecture_mark" id="mark_176"></div><h4 >Системные вызовы, работающие с символическим именем файла</h4><h5 >Системные вызовы, связывающие pathname с дескриптором файла</h5><p  id="id_177">Это функции создания и открытия файла. Например, в ОС Unix</p><div  class="lecture_mark" id="mark_177"></div><div  class="example"><pre>
fd = creat(pathname,modes);
fd = open(pathname,flags,modes);
</pre></div><p  id="id_179">Другие операции над файлами, такие как чтение, запись, позиционирование головок чтения-записи, воспроизведение дескриптора файла, установка параметров ввода-вывода, определение статуса файла и закрытие файла, используют значение полученного дескриптора файла.</p><div  class="lecture_mark" id="mark_179"></div><p  id="id_180">Рассмотрим работу системного вызова <span class="texample">open</span>.</p><div  class="lecture_mark" id="mark_180"></div><p  id="id_182">Логическая файловая подсистема просматривает файловую систему в поисках файла по его имени. Она проверяет права на открытие файла и выделяет открываемому файлу запись в таблице файлов. Запись таблицы файлов содержит указатель на <span class="keyword">индексный узел</span> открытого файла. Ядро выделяет запись в личной (закрытой) таблице в адресном пространстве процесса, выделенном процессу (таблица эта называется таблицей пользовательских дескрипторов открытых файлов) и запоминает указатель на данную запись. В роли указателя выступает дескриптор файла, возвращаемый пользователю. Запись в таблице пользовательских файлов указывает на запись в глобальной таблице файлов (см. <a href="">рис. 12.13</a>).</p><div  class="lecture_mark" id="mark_182"></div><p  id="id_183">Первые три пользовательских дескриптора (0, 1 и 2) именуются дескрипторами файлов стандартного ввода, стандартного вывода и стандартного файла ошибок. Процессы в системе Unix по договоренности используют дескриптор файла стандартного ввода при чтении вводимой информации, дескриптор файла стандартного вывода при записи выводимой информации и дескриптор стандартного файла ошибок для записи сообщений об ошибках.</p><div  class="lecture_mark" id="mark_183"></div><p  align="left" id="id_184"><a name="image.12.13"></a><div><img src="12. Реализация файловой системы_files/12-13000.gif" alt="Структуры данных после открытия файлов" width="428" height="403"></div><br><b>Рис. 12.13.</b> 
        Структуры данных после открытия файлов</p><div  class="lecture_mark" id="mark_184"></div><h5 >Связывание файла </h5><p  id="id_185">Системная функция <span class="texample">link</span> связывает файл с новым именем в структуре каталогов файловой системы, создавая для существующего индекса новую запись в каталоге. Синтаксис вызова функции <span class="texample">link</span>:</p><div  class="lecture_mark" id="mark_185"></div><div  class="example"><pre>
link(source file name, target file name);
</pre></div><p  id="id_189">где <span class="texample">source file name</span> - существующее имя файла, а <span class="texample">target file name</span> - новое (дополнительное) имя, присваиваемое файлу после выполнения функции <span class="texample">link</span>.</p><div  class="lecture_mark" id="mark_189"></div><p  id="id_193">Сначала ОС определяет местонахождение индекса исходного файла и увеличивает значение счетчика <span class="keyword">связей</span> в <span class="keyword">индексном узле</span>. Затем ядро ищет файл с новым именем; если он существует, функция <span class="texample">link</span> завершается неудачно, и ядро восстанавливает прежнее значение счетчика <span class="keyword">связей</span>, измененное ранее. В противном случае ядро находит в родительском каталоге свободную запись для файла с новым именем, записывает в нее новое имя и номер индекса исходного файла.</p><div  class="lecture_mark" id="mark_193"></div><h5 >Удаление файла</h5><p  id="id_195">В Unix системная функция <span class="texample">unlink</span> удаляет из каталога точку входа для файла. Синтаксис вызова функции <span class="texample">unlink</span>:</p><div  class="lecture_mark" id="mark_195"></div><div  class="example"><pre>
unlink(pathname);	
</pre></div><p  id="id_199">Если удаляемое имя является последней <span class="keyword">связью</span> файла с каким-либо каталогом, ядро в итоге освобождает все информационные блоки файла. Однако если у файла было несколько <span class="keyword">связей</span>, он остается все еще доступным под другими именами.</p><div  class="lecture_mark" id="mark_199"></div><p  id="id_200">Для того чтобы забрать дисковые блоки, ядро в цикле просматривает таблицу содержимого <span class="keyword">индексного узла</span>, освобождая все блоки прямой адресации немедленно. Что касается блоков косвенной адресации, то ядро освобождает все блоки, появляющиеся на различных уровнях косвенности, рекурсивно, причем в первую очередь освобождаются блоки с меньшим уровнем.</p><div  class="lecture_mark" id="mark_200"></div><h4 >Системные вызовы, работающие с файловым дескриптором</h4><p  id="id_201">Открытый файл может использоваться для чтения и записи последовательностей байтов. Для этого поддерживаются два системных вызова <span class="texample">read</span> и <span class="texample">write</span>, работающие с файловым дескриптором (или handle в терминологии Microsoft), полученным при ранее выполненных системных вызовах <span class="texample">open</span> или <span class="texample">creat</span>.</p><div  class="lecture_mark" id="mark_201"></div><h5 >Функции ввода-вывода из файла</h5><p  id="id_206">Системный вызов <span class="texample">read</span> выполняет чтение обычного файла</p><div  class="lecture_mark" id="mark_206"></div><div  class="example"><pre>
number = read(fd,buffer,count);
</pre></div><p  id="id_209">где <span class="texample">fd</span> - дескриптор файла, возвращаемый функцией <span class="texample">open</span>, <span class="texample">buffer</span> - адрес структуры данных в пользовательском процессе, где будут размещаться считанные данные в случае успешного завершения выполнения функции <span class="texample">read</span>, <span class="texample">count</span> - количество байтов, которые пользователю нужно прочитать, <span class="texample">number</span> - количество фактически прочитанных байтов.</p><div  class="lecture_mark" id="mark_209"></div><p  id="id_216">Синтаксис вызова системной функции <span class="texample">write</span> (писать):</p><div  class="lecture_mark" id="mark_216"></div><div  class="example"><pre>
number = write(fd,buffer,count);
</pre></div><p  id="id_219">где переменные <span class="texample">fd</span>, <span class="texample">buffer</span>, <span class="texample">count</span> и <span class="texample">number</span> имеют тот же смысл, что и для вызова системной функции <span class="texample">read</span>. Алгоритм записи в обычный файл похож на алгоритм чтения из обычного файла. Однако если в файле отсутствует блок, соответствующий смещению в байтах до места, куда должна производиться запись, ядро выделяет блок и присваивает ему номер в соответствии с точным указанием места в таблице содержимого <span class="keyword">индексного узла</span>.</p><div  class="lecture_mark" id="mark_219"></div><p  id="id_225">Обычное использование системных функций <span class="texample">read</span> и <span class="texample">write</span> обеспечивает последовательный доступ к файлу, однако процессы могут использовать вызов системной функции <span class="texample">lseek</span> для указания места в файле, где будет производиться ввод-вывод, и осуществления произвольного доступа к файлу. Синтаксис вызова системной функции:</p><div  class="lecture_mark" id="mark_225"></div><div  class="example"><pre>
position = lseek(fd,offset,reference);
</pre></div><p  id="id_230">где <span class="texample">fd</span> - дескриптор файла, идентифицирующий файл, <span class="texample">offset</span> - смещение в байтах, а <span class="texample">reference</span> указывает, является ли значение <span class="texample">offset</span> смещением от начала файла, смещением от текущей позиции ввода-вывода или смещением от конца файла. Возвращаемое значение, <span class="texample">position</span>, является смещением в байтах до места, где будет начинаться следующая операция чтения или записи.</p><div  class="lecture_mark" id="mark_230"></div><h3 >Современные архитектуры файловых систем</h3><p  id="id_236">Современные ОС предоставляют пользователю возможность работать сразу с несколькими файловыми системами (Linux работает с Ext2fs, <span class="keyword">FAT</span> и др.). Файловая система в традиционном понимании становится частью более общей многоуровневой структуры (см. <a href="">рис. 12.14</a>).</p><div  class="lecture_mark" id="mark_236"></div><p  id="id_237">На верхнем уровне располагается так называемый диспетчер файловых систем (например, в Windows 95 этот компонент называется installable filesystem manager). Он связывает запросы прикладной программы с конкретной файловой системой.</p><div  class="lecture_mark" id="mark_237"></div><p  id="id_238">Каждая файловая система (иногда говорят - драйвер файловой системы) на этапе инициализации регистрируется у диспетчера, сообщая ему точки входа, для последующих обращений к данной файловой системе.</p><div  class="lecture_mark" id="mark_238"></div><p  id="id_239">Та же идея поддержки нескольких файловых систем в рамках одной ОС может быть реализована по-другому, например исходя из концепции <span class="keyword">виртуальной файловой системы</span>. <span class="keyword">Виртуальная файловая система (vfs)</span> представляет собой независимый от реализации уровень и опирается на реальные файловые системы (s5fs, ufs, <span class="keyword">FAT</span>, NFS, FFS. Ext2fs ѕ). При этом возникают структуры данных <span class="keyword">виртуальной файловой системы</span> типа виртуальных <span class="keyword">индексных узлов</span> vnode, которые обобщают <span class="keyword">индексные узлы</span> конкретных систем.</p><div  class="lecture_mark" id="mark_239"></div><p  align="left" id="id_240"><a name="image.12.14"></a><div><img src="12. Реализация файловой системы_files/12-14000.gif" alt="Архитектура современной файловой системы" width="424" height="273"></div><br><b>Рис. 12.14.</b> 
        Архитектура современной файловой системы</p><div  class="lecture_mark" id="mark_240"></div><h3 >Заключение</h3><p  id="id_241">Реализация файловой системы связана с такими вопросами, как поддержка понятия логического блока диска, связывания имени файла и блоков его данных, проблемами разделения файлов и проблемами управления дискового пространства.</p><div  class="lecture_mark" id="mark_241"></div><p  id="id_242">Наиболее распространенные способы выделения дискового пространства: непрерывное выделение, организация связного списка и система с <span class="keyword">индексными узлами</span>.</p><div  class="lecture_mark" id="mark_242"></div><p  id="id_243">Файловая система часто реализуется в виде слоеной модульной структуры. Нижние слои имеют дело с оборудованием, а верхние - с символическими именами и логическими свойствами файлов.</p><div  class="lecture_mark" id="mark_243"></div><p  id="id_244">Директории могут быть организованы различными способами и могут хранить атрибуты файла и адреса блоков файлов, а иногда для этого предназначается специальная структура (<span class="keyword">индексные узлы</span>).</p><div  class="lecture_mark" id="mark_244"></div><p  id="id_245">Проблемы надежности и производительности файловой системы - важнейшие аспекты ее дизайна.</p><div  class="lecture_mark" id="mark_245"></div>


	</td>
	</tr>
	<tr><td height="8"><img src="12. Реализация файловой системы_files/empty000.gif" width="1" height="8"></td></tr>
	</table>
	<!-- /content -->

</td>
<td><img src="12. Реализация файловой системы_files/empty000.gif" width="8" height="1"></td>
</tr>
</table>
<!-- /bottom -->
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td class="orang" height="1"><img src="12. Реализация файловой системы_files/empty000.gif" width="1" height="1"></td></tr>
<td class="ltxt" align=center>&copy; INTUIT.ru, 2003-2008. Все права защищены.</td>
</tr>
</table>
<!-- /bottom -->

<script src="12. Реализация файловой системы_files/urchin00.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-3475067-1";
urchinTracker();
</script></body>
</html>


<!-- This document saved from http://www.intuit.ru/department/os/osintro/12/osintro_12.html -->
