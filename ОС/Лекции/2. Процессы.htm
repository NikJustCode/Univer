<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>INTUIT.ru::Интернет-Университет Информационных Технологий</title>
<link href="2. Процессы_files/printabl.css" type="text/css" rel="stylesheet">
</head>
<body leftmargin="6" topmargin="6" marginheight="6" marginwidth="6">


<div align="left">
<span style="color: #000000; font-weight: bold;">
&nbsp;&nbsp;
<span style="font-size:12pt;">Интернет-Университет Информационных Технологий</span>
</span>
</div>

&nbsp;&nbsp;
<span align="rright" style="color: #330066; text-decoration:underline;">http://www.INTUIT.ru</span>


<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td height="8" colspan=3><img src="2. Процессы_files/empty000.gif" width="1" height="8"></td></tr>
<tr><td class="orang" height="1" colspan=3><img src="2. Процессы_files/empty000.gif" width="1" height="1"></td></tr>
<tr><td height="8" colspan=3><img src="2. Процессы_files/empty000.gif" width="1" height="8"></td></tr>
<tr valign="top">
<td><img src="2. Процессы_files/empty000.gif" width="8" height="1"></td>
<td>
	<!-- content -->
	<table border="0" cellpadding="0" cellspacing="0" width="100%">
	<tr><td class="head">Основы операционных систем</td></tr>
<tr><td height="4"><img src="2. Процессы_files/empty000.gif" width="1" height="4"></td></tr>
	<tr><td class="orang" height="1"><img src="2. Процессы_files/empty000.gif" width="1" height="1"></td></tr>
	<tr><td height="8"><img src="2. Процессы_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td><span class="headsub">


2. Лекция:

 Процессы: версия для печати и PDA</span>

<br>
<span class="rtxt">В лекции описывается основополагающее понятие процесса, рассматриваются его состояния, модель представления процесса в операционной системе и операции, которые могут выполняться над процессами операционной системой.
</span>

</td></tr>

	<tr><td height="8"><img src="2. Процессы_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td class="orang" height="1"><img src="2. Процессы_files/empty000.gif" width="1" height="1"></td></tr>
	<tr><td height="8"><img src="2. Процессы_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td>


<h3 ></h3><p  id="id_1">Начиная с этой лекции мы будем знакомиться с внутренним устройством и механизмами действия операционных систем, разбирая одну за другой их основные функции по отдельности и во взаимосвязи. Фундаментальным понятием для изучения работы операционных систем является понятие <span class="keyword">процессов</span> как основных динамических объектов, над которыми системы выполняют определенные действия. Данная лекция посвящена описанию таких объектов, их <span class="keyword">состояний</span> и свойств, их представлению в вычислительных системах, а также <span class="keyword">операциям</span>, которые могут проводиться над ними.</p><div  class="lecture_mark" id="mark_1"></div><h3 >Понятие процесса</h3><p  id="id_2">В первой лекции, поясняя понятие "операционная система" и описывая способы построения операционных систем, мы часто применяли слова "программа" и "задание". Мы говорили: вычислительная система исполняет одну или несколько программ, операционная система планирует задания, программы могут обмениваться данными и т. д. Мы использовали эти термины в некотором общеупотребительном, житейском смысле, предполагая, что все читатели одинаково представляют себе, что подразумевается под ними в каждом конкретном случае. При этом одни и те же слова обозначали и объекты в статическом состоянии, необрабатывающиеся вычислительной системой (например, совокупность файлов на диске), и объекты в динамическом состоянии, находящиеся в процессе исполнения. Это было возможно, пока мы говорили об общих свойствах операционных систем, не вдаваясь в подробности их внутреннего устройства и поведения, или о работе вычислительных систем первого-второго поколений, которые не могли обрабатывать более одной программы или одного задания одновременно, по сути дела не имея операционных систем. Но теперь мы начинаем знакомиться с деталями функционирования современных компьютерных систем, и нам придется уточнить терминологию.</p><div  class="lecture_mark" id="mark_2"></div><p  id="id_3">Рассмотрим следующий пример. Два студента запускают программу извлечения квадратного корня. Один хочет вычислить квадратный корень из 4, а второй – из 1. С точки зрения студентов, запущена одна и та же программа; с точки зрения компьютерной системы, ей приходится заниматься двумя различными вычислительными <span class="keyword">процессами</span>, так как разные исходные данные приводят к разному набору вычислений. Следовательно, на уровне происходящего внутри вычислительной системы мы не можем использовать термин "программа" в пользовательском смысле слова. </p><div  class="lecture_mark" id="mark_3"></div><p  id="id_4">Рассматривая системы пакетной обработки, мы ввели понятие "задание" как совокупность программы, набора команд языка управления заданиями, необходимых для ее выполнения, и входных данных. С точки зрения студентов, они, подставив разные исходные данные, сформировали два различных задания. Может быть, термин "задание" подойдет нам для описания внутреннего функционирования компьютерных систем? Чтобы выяснить это, давайте рассмотрим другой пример. Пусть оба студента пытаются извлечь корень квадратный из 1, то есть пусть они сформировали идентичные задания, но загрузили их в вычислительную систему со сдвигом по времени. В то время как одно из выполняемых заданий приступило к печати полученного значения и ждет окончания операции ввода-вывода, второе только начинает исполняться. Можно ли говорить об идентичности заданий внутри вычислительной системы в данный момент? Нет, так как <span class="keyword">состояние процесса</span> их выполнения различно. Следовательно, и слово "задание" в пользовательском смысле не может применяться для описания происходящего в вычислительной системе.</p><div  class="lecture_mark" id="mark_4"></div><p  id="id_5">Это происходит потому, что термины "программа" и "задание" предназначены для описания статических, неактивных объектов. Программа же в <span class="keyword">процессе</span> исполнения является динамическим, активным объектом. По ходу ее работы компьютер обрабатывает различные команды и преобразует значения переменных. Для выполнения программы операционная система должна выделить определенное количество оперативной памяти, закрепить за ней определенные устройства ввода-вывода или файлы (откуда должны поступать входные данные и куда нужно доставить полученные результаты), то есть зарезервировать определенные ресурсы из общего числа ресурсов всей вычислительной системы. Их количество и конфигурация с течением времени могут изменяться. Для описания таких активных объектов внутри компьютерной системы вместо терминов "программа" и "задание" мы будем использовать новый термин – "<span class="keyword">процесс</span>". </p><div  class="lecture_mark" id="mark_5"></div><p  id="id_6">В ряде учебных пособий и монографий для простоты предлагается рассматривать <span class="keyword">процесс</span> как абстракцию, характеризующую программу во время выполнения. На наш взгляд, эта рекомендация не совсем корректна. <a name="keyword-context.1"></a>Понятие <span class="keyword_def">процесса</span> характеризует некоторую совокупность набора исполняющихся команд, ассоциированных с ним ресурсов (выделенная для исполнения память или адресное пространство, стеки, используемые файлы и устройства ввода-вывода и т. д.) и текущего момента его выполнения (значения регистров, программного счетчика, состояние стека и значения переменных), находящуюся под управлением операционной системы. Не существует взаимно-однозначного соответствия между <span class="keyword">процессами</span> и программами, обрабатываемыми вычислительными системами. Как будет показано далее, в некоторых операционных системах для работы определенных программ может организовываться более одного <span class="keyword">процесса</span> или один и тот же <span class="keyword">процесс</span> может исполнять последовательно несколько различных программ. Более того, даже в случае обработки только одной программы в рамках одного <span class="keyword">процесса</span> нельзя считать, что <span class="keyword">процесс</span> представляет собой просто динамическое описание кода исполняемого файла, данных и выделенных для них ресурсов. <span class="keyword">Процесс</span> находится под управлением операционной системы, поэтому в нем может выполняться часть кода ее ядра (не находящегося в исполняемом файле!), как в случаях, специально запланированных авторами программы (например, при использовании системных вызовов), так и в непредусмотренных ситуациях (например, при обработке внешних прерываний).</p><div  class="lecture_mark" id="mark_6"></div><h3 >Состояния процесса</h3><p  id="id_7">При использовании такой абстракции все, что выполняется в вычислительных системах (не только программы пользователей, но и, возможно, определенные части операционных систем), организовано как набор <span class="keyword">процессов</span>. Понятно, что реально на однопроцессорной компьютерной системе в каждый момент времени может исполняться только один <span class="keyword">процесс</span>. Для мультипрограммных вычислительных систем псевдопараллельная обработка нескольких <span class="keyword">процессов</span> достигается с помощью переключения процессора с одного <span class="keyword">процесса</span> на другой. Пока один <span class="keyword">процесс</span> выполняется, остальные ждут своей очереди.</p><div  class="lecture_mark" id="mark_7"></div><p  id="id_8">Как видим, каждый <span class="keyword">процесс</span> может находиться как минимум в двух <span class="keyword">состояниях</span>: <span class="texample"><span class="keyword">процесс</span> исполняется</span> и <span class="texample"><span class="keyword">процесс</span> не исполняется</span>. Диаграмма <span class="keyword">состояний процесса</span> в такой модели изображена на <a href="">рис. 2.1</a>.</p><div  class="lecture_mark" id="mark_8"></div><p  align="left" id="id_11"><a name="image.2.1"></a><div><img src="2. Процессы_files/2-100000.gif" alt="Простейшая диаграмма состояний процесса" width="339" height="94"></div><br><b>Рис. 2.1.</b> 
        Простейшая диаграмма состояний процесса</p><div  class="lecture_mark" id="mark_11"></div><p  id="id_12"><span class="keyword">Процесс</span>, находящийся в <span class="keyword">состоянии</span><span class="texample"><span class="keyword"> процесс</span> исполняется</span>, через некоторое время может быть <span class="keyword">завершен</span> операционной системой или приостановлен и снова переведен в <span class="keyword">состояние</span><span class="texample"><span class="keyword"> процесс</span> не исполняется</span>. <span class="keyword">Приостановка процесса</span> происходит по двум причинам: для его дальнейшей работы потребовалось какое-либо событие (например, завершение операции ввода-вывода) или истек временной интервал, отведенный операционной системой для работы данного <span class="keyword">процесса</span>. После этого операционная система по определенному алгоритму выбирает для исполнения один из <span class="keyword">процессов</span>, находящихся в <span class="keyword">состоянии</span><span class="texample"><span class="keyword"> процесс</span> не исполняется</span>, и переводит его в <span class="keyword">состояние</span><span class="texample"><span class="keyword"> процесс</span> исполняется</span>. Новый <span class="keyword">процесс</span>, появляющийся в системе, первоначально помещается в <span class="keyword">состояние</span><span class="texample"><span class="keyword"> процесс</span> не исполняется</span>.</p><div  class="lecture_mark" id="mark_12"></div><p  id="id_18">Это очень грубая модель, она не учитывает, в частности, то, что <span class="keyword">процесс</span>, выбранный для исполнения, может все еще ждать события, из-за которого он был приостановлен, и реально к выполнению не готов. Для того чтобы избежать такой ситуации, разобьем <span class="keyword">состояние</span><span class="texample"><span class="keyword"> процесс</span> не исполняется</span> на два новых <span class="keyword">состояния</span>: <span class="texample"><span class="keyword">готовность</span></span> и <span class="texample"><span class="keyword">ожидание</span></span> (см. <a href="">рис. 2.2</a>). </p><div  class="lecture_mark" id="mark_18"></div><p  align="left" id="id_22"><a name="image.2.2"></a><div><img src="2. Процессы_files/2-200000.gif" alt="Более подробная диаграмма состояний процесса" width="339" height="168"></div><br><b>Рис. 2.2.</b> 
        Более подробная диаграмма состояний процесса</p><div  class="lecture_mark" id="mark_22"></div><p  id="id_23">Всякий новый <span class="keyword">процесс</span>, появляющийся в системе, попадает в <span class="keyword">состояние</span> <span class="texample">готовность</span>. Операционная система, пользуясь каким-либо алгоритмом планирования, выбирает один из готовых <span class="keyword">процессов</span> и переводит его в <span class="keyword">состояние</span> <span class="texample">исполнение</span>. В <span class="keyword">состоянии</span> <span class="texample">исполнение</span> происходит непосредственное выполнение программного кода <span class="keyword">процесса</span>. Выйти из этого <span class="keyword">состояния</span><span class="keyword"> процесс</span> может по трем причинам:</p><div  class="lecture_mark" id="mark_23"></div><ul  id="id_27"><li>операционная система прекращает его деятельность;</li><li>он не может продолжать свою работу, пока не произойдет некоторое событие, и операционная система переводит его в <span class="keyword">состояние</span> <span class="texample">ожидание</span>;</li><li>в результате возникновения прерывания в вычислительной системе (например, прерывания от таймера по истечении предусмотренного времени выполнения) его возвращают в <span class="keyword">состояние</span> <span class="texample">готовность</span>.</li></ul><div  class="lecture_mark" id="mark_27"></div><p  id="id_33">Из <span class="keyword">состояния</span> <span class="texample">ожидание</span> процесс попадает в  <span class="keyword">состояние</span> <span class="texample">готовность</span> после того, как ожидаемое событие произошло, и он снова может быть выбран для исполнения.</p><div  class="lecture_mark" id="mark_33"></div><p  id="id_36">Наша новая модель хорошо описывает поведение <span class="keyword">процессов</span> во время их существования, но она не акцентирует внимания на появлении <span class="keyword">процесса</span> в системе и его исчезновении. Для полноты картины нам необходимо ввести еще два <span class="keyword">состояния процессов</span>: <span class="texample"><span class="keyword">рождение</span></span> и <span class="texample"><span class="keyword">закончил исполнение</span></span> (см. <a href="">рис. 2.3</a>). </p><div  class="lecture_mark" id="mark_36"></div><p  align="left" id="id_39"><a name="image.2.3"></a><div><img src="2. Процессы_files/2-300000.gif" alt="Диаграмма состояний процесса, принятая в курсе" width="339" height="213"></div><br><b>Рис. 2.3.</b> 
        Диаграмма состояний процесса, принятая в курсе</p><div  class="lecture_mark" id="mark_39"></div><p  id="id_40">Теперь для появления в вычислительной системе <span class="keyword">процесс</span> должен пройти через <span class="keyword">состояние</span> <span class="texample">рождение</span>. При рождении <span class="keyword">процесс</span> получает в свое распоряжение адресное пространство, в которое загружается программный код <span class="keyword">процесса</span>; ему выделяются стек и системные ресурсы; устанавливается начальное значение программного счетчика этого <span class="keyword">процесса</span> и т. д. Родившийся <span class="keyword">процесс</span> переводится в <span class="keyword">состояние</span> <span class="texample">готовность</span>. При <span class="keyword">завершении</span> своей деятельности <span class="keyword">процесс</span> из <span class="keyword">состояния</span> <span class="texample">исполнение</span> попадает в <span class="keyword">состояние</span> <span class="texample">закончил исполнение</span>. </p><div  class="lecture_mark" id="mark_40"></div><p  id="id_45">В конкретных операционных системах <span class="keyword">состояния процесса</span> могут быть еще более детализированы, могут появиться некоторые новые варианты переходов из одного <span class="keyword">состояния</span> в другое. Так, например, модель <span class="keyword">состояний процессов</span> для операционной системы Windows NT содержит 7 различных <span class="keyword">состояний</span>, а для операционной системы Unix – 9. Тем не менее так или иначе, все операционные системы подчиняются изложенной выше модели. </p><div  class="lecture_mark" id="mark_45"></div><h3 >Операции над процессами и связанные с ними понятия</h3><h4 >Набор операций</h4><p  id="id_46"><span class="keyword">Процесс</span> не может перейти из одного <span class="keyword">состояния</span> в другое самостоятельно. Изменением <span class="keyword">состояния процессов</span> занимается операционная система, совершая <span class="keyword">операции</span> над ними. Количество таких <span class="keyword">операций</span> в нашей модели пока совпадает с количеством стрелок на диаграмме <span class="keyword">состояний</span>. Удобно объединить их в три пары:</p><div  class="lecture_mark" id="mark_46"></div><ul  id="id_47"><li><span class="keyword">создание процесса</span> – <span class="keyword">завершение процесса</span>;</li><li><span class="keyword">приостановка процесса</span> (перевод из <span class="keyword">состояния</span> <span class="texample">исполнение</span> в <span class="keyword">состояние</span> <span class="texample">готовность</span>) – <span class="keyword">запуск процесса</span> (перевод из <span class="keyword">состояния</span> <span class="texample">готовность</span> в <span class="keyword">состояние</span> <span class="texample">исполнение</span>);</li><li><span class="keyword">блокирование процесса</span> (перевод из <span class="keyword">состояния</span> <span class="texample">исполнение</span> в <span class="keyword">состояние</span> <span class="texample">ожидание</span>) – <span class="keyword">разблокирование процесса</span> (перевод из <span class="keyword">состояния</span> <span class="texample">ожидание</span> в <span class="keyword">состояние</span> <span class="texample">готовность</span>).</li></ul><div  class="lecture_mark" id="mark_47"></div><p  id="id_59">В дальнейшем, когда мы будем говорить об алгоритмах планирования, в нашей модели появится еще одна <span class="keyword">операция</span>, не имеющая парной: изменение приоритета <span class="keyword">процесса</span>.</p><div  class="lecture_mark" id="mark_59"></div><p  id="id_60"><span class="keyword">Операции </span><span class="keyword">создания</span> и <span class="keyword">завершения процесса</span> являются одноразовыми, так как применяются к <span class="keyword">процессу</span> не более одного раза (некоторые системные <span class="keyword">процессы</span> при работе вычислительной системы не завершаются никогда). Все остальные <span class="keyword">операции</span>, связанные с изменением <span class="keyword">состояния процессов</span>, будь то <span class="keyword">запуск</span> или <span class="keyword">блокировка</span>, как правило, являются многоразовыми. Рассмотрим подробнее, как операционная система выполняет <span class="keyword">операции над процессами</span>.</p><div  class="lecture_mark" id="mark_60"></div><h4 >Process Control Block и контекст процесса</h4><p  id="id_61">Для того чтобы операционная система могла выполнять <span class="keyword">операции над процессами</span>, каждый <span class="keyword">процесс</span> представляется в ней некоторой структурой данных. Эта структура содержит информацию, специфическую для данного <span class="keyword">процесса</span>: </p><div  class="lecture_mark" id="mark_61"></div><ul  id="id_62"><li><span class="keyword">состояние</span>, в котором находится <span class="keyword">процесс</span>;</li><li>программный счетчик <span class="keyword">процесса</span> или, другими словами, адрес команды, которая должна быть выполнена для него следующей;</li><li>содержимое регистров процессора;</li><li>данные, необходимые для планирования использования процессора и управления памятью (приоритет <span class="keyword">процесса</span>, размер и расположение адресного пространства и т. д.);</li><li>учетные данные (идентификационный номер <span class="keyword">процесса</span>, какой пользователь инициировал его работу, общее время использования процессора данным <span class="keyword">процессом</span> и т. д.);</li><li>сведения об устройствах ввода-вывода, связанных с <span class="keyword">процессом</span> (например, какие устройства закреплены за <span class="keyword">процессом</span>, таблицу открытых файлов).</li></ul><div  class="lecture_mark" id="mark_62"></div><p  id="id_69">Ее состав и строение зависят, конечно, от конкретной операционной системы. Во многих операционных системах информация, характеризующая <span class="keyword">процесс</span>, хранится не в одной, а в нескольких связанных структурах данных. Эти структуры могут иметь различные наименования, содержать дополнительную информацию или, наоборот, лишь часть описанной информации. Для нас это не имеет значения. Для нас важно лишь то, что для любого <span class="keyword">процесса</span>, находящегося в вычислительной системе, вся информация, необходимая для совершения <span class="keyword">операций</span> над ним, доступна операционной системе. Для простоты изложения будем считать, что она хранится в одной структуре данных. Мы будем называть ее <span class="keyword">PCB</span> (Process Control Block) или <span class="keyword">блоком управления процессом</span>. <a name="keyword-context.2"></a><span class="keyword_def">Блок управления процессом</span> является моделью <span class="keyword">процесса</span> для операционной системы. Любая <span class="keyword">операция</span>, производимая операционной системой над <span class="keyword">процессом</span>, вызывает определенные изменения в <span class="keyword">PCB</span>. В рамках принятой модели <span class="keyword">состояний процессов</span> содержимое <span class="keyword">PCB</span> между <span class="keyword">операциями</span> остается постоянным.</p><div  class="lecture_mark" id="mark_69"></div><p  id="id_70">Информацию, для хранения которой предназначен <span class="keyword">блок управления процессом</span>, удобно для дальнейшего изложения разделить на две части. Содержимое всех регистров процессора (включая значение программного счетчика) будем называть <span class="keyword">регистровым контекстом</span><span class="keyword"> процесса</span>, а все остальное – <span class="keyword">системным контекстом</span><span class="keyword"> процесса</span>. Знания <span class="keyword">регистрового</span> и <span class="keyword">системного контекстов</span><span class="keyword"> процесса</span> достаточно для того, чтобы управлять его работой в операционной системе, совершая над ним <span class="keyword">операции</span>. Однако этого недостаточно для того, чтобы полностью охарактеризовать <span class="keyword">процесс</span>. Операционную систему не интересует, какими именно вычислениями занимается <span class="keyword">процесс</span>, т. е. какой код и какие данные находятся в его адресном пространстве. С точки зрения пользователя, наоборот, наибольший интерес представляет содержимое адресного пространства <span class="keyword">процесса</span>, возможно, наряду с <span class="keyword">регистровым контекстом</span> определяющее последовательность преобразования данных и полученные результаты. Код и данные, находящиеся в адресном пространстве <span class="keyword">процесса</span>, будем называть его <span class="keyword">пользовательским контекстом</span>. Совокупность <span class="keyword">регистрового</span>, <span class="keyword">системного</span> и <span class="keyword">пользовательского контекстов</span><span class="keyword"> процесса</span> для краткости принято называть просто <span class="keyword">контекстом процесса</span>. В любой момент времени <span class="keyword">процесс</span> полностью характеризуется своим <span class="keyword">контекстом</span>.</p><div  class="lecture_mark" id="mark_70"></div><h4 >Одноразовые операции</h4><p  id="id_71">Сложный жизненный путь <span class="keyword">процесса</span> в компьютере начинается с его рождения. Любая операционная система, поддерживающая концепцию <span class="keyword">процессов</span>, должна обладать средствами для их <span class="keyword">создания</span>. В очень простых системах (например, в системах, спроектированных для работы только одного конкретного приложения) все <span class="keyword">процессы</span> могут быть порождены на этапе старта системы. Более сложные операционные системы создают <span class="keyword">процессы</span> динамически, по мере необходимости. Инициатором рождения нового <span class="keyword">процесса</span> после старта операционной системы может выступить либо <span class="keyword">процесс</span> пользователя, совершивший специальный системный вызов, либо сама операционная система, то есть, в конечном итоге, тоже некоторый <span class="keyword">процесс</span>. <span class="keyword">Процесс</span>, инициировавший <span class="keyword">создание</span> нового <span class="keyword">процесса</span>, принято называть процессом-родителем (parent process), а вновь созданный <span class="keyword">процесс</span> – процессом-ребенком (child process). Процессы-дети могут в свою очередь порождать новых детей и т. д., образуя, в общем случае, внутри системы набор генеалогических деревьев <span class="keyword">процессов</span> – генеалогический лес. Пример генеалогического леса изображен на <a href="">рисунке 2.4</a>. Следует отметить, что все пользовательские <span class="keyword">процессы</span> вместе с некоторыми <span class="keyword">процессами</span> операционной системы принадлежат одному и тому же дереву леса. В ряде вычислительных систем лес вообще вырождается в одно такое дерево. </p><div  class="lecture_mark" id="mark_71"></div><p  align="left" id="id_72"><a name="image.2.4"></a><div><img src="2. Процессы_files/2-400000.gif" alt="Упрощенный генеалогический лес процессов. Стрелочка означает отношение родитель–ребенок" width="339" height="171"></div><br><b>Рис. 2.4.</b> 
        Упрощенный генеалогический лес процессов. Стрелочка означает отношение родитель–ребенок</p><div  class="lecture_mark" id="mark_72"></div><p  id="id_73">При рождении <span class="keyword">процесса</span> система заводит новый <span class="keyword">PCB</span> с <span class="keyword">состоянием процесса</span> <span class="texample">рождение</span> и начинает его заполнять. Новый <span class="keyword">процесс</span> получает собственный уникальный идентификационный номер. Поскольку для хранения идентификационного номера <span class="keyword">процесса</span> в операционной системе отводится ограниченное количество битов, для соблюдения уникальности номеров количество одновременно присутствующих в ней <span class="keyword">процессов</span> должно быть ограничено. После <span class="keyword">завершения</span> какого-либо <span class="keyword">процесса</span> его освободившийся идентификационный номер может быть повторно использован для другого <span class="keyword">процесса</span>.</p><div  class="lecture_mark" id="mark_73"></div><p  id="id_75">Обычно для выполнения своих функций процесс-ребенок требует определенных ресурсов: памяти, файлов, устройств ввода-вывода и т. д. Существует два подхода к их выделению. Новый <span class="keyword">процесс</span> может получить в свое распоряжение некоторую часть родительских ресурсов, возможно разделяя с процессом-родителем и другими процессами-детьми права на них, или может получить свои ресурсы непосредственно от операционной системы. Информация о выделенных ресурсах заносится в <span class="keyword">PCB</span>. </p><div  class="lecture_mark" id="mark_75"></div><p  id="id_76">После наделения процесса-ребенка ресурсами необходимо занести в его адресное пространство программный код, значения данных, установить программный счетчик. Здесь также возможны два решения. В первом случае процесс-ребенок становится дубликатом процесса-родителя по <span class="keyword">регистровому</span> и <span class="keyword">пользовательскому контекстам</span>, при этом должен существовать способ определения, кто для кого из процессов-двойников является родителем. Во втором случае процесс-ребенок загружается новой программой из какого-либо файла. Операционная система Unix разрешает порождение <span class="keyword">процесса</span> только первым способом; для запуска новой программы необходимо сначала создать копию процесса-родителя, а затем процесс-ребенок должен заменить свой <span class="keyword">пользовательский контекст</span> с помощью специального системного вызова. Операционная система VAX/VMS допускает только второе решение. В Windows NT возможны оба варианта (в различных API).</p><div  class="lecture_mark" id="mark_76"></div><p  id="id_77">Порождение нового <span class="keyword">процесса</span> как дубликата процесса-родителя приводит к возможности существования программ (т. е. исполняемых файлов), для работы которых организуется более одного <span class="keyword">процесса</span>. Возможность замены <span class="keyword">пользовательского контекста</span><span class="keyword"> процесса</span> по ходу его работы (т. е. загрузки для исполнения новой программы) приводит к тому, что в рамках одного и того же <span class="keyword">процесса</span> может последовательно выполняться несколько различных программ.</p><div  class="lecture_mark" id="mark_77"></div><p  id="id_78">После того как <span class="keyword">процесс</span> наделен содержанием, в <span class="keyword">PCB</span> дописывается оставшаяся информация, и <span class="keyword">состояние</span> нового <span class="keyword">процесса</span> изменяется на <span class="keyword">готовность</span>. Осталось сказать несколько слов о том, как ведут себя процессы-родители после рождения процессов-детей. Процесс-родитель может продолжать свое выполнение одновременно с выполнением процесса-ребенка, а может ожидать <span class="keyword">завершения</span> работы некоторых или всех своих "детей". </p><div  class="lecture_mark" id="mark_78"></div><p  id="id_79">Мы не будем подробно останавливаться на причинах, которые могут привести к <span class="keyword">завершению</span> жизненного цикла <span class="keyword">процесса</span>. После того как <span class="keyword">процесс</span> завершил свою работу, операционная система переводит его в <span class="keyword">состояние</span> <span class="texample">закончил исполнение</span> и освобождает все ассоциированные с ним ресурсы, делая соответствующие записи в <span class="keyword">блоке управления процессом</span>. При этом сам <span class="keyword">PCB</span> не уничтожается, а остается в системе еще некоторое время. Это связано с тем, что процесс-родитель после <span class="keyword">завершения</span> процесса-ребенка может запросить операционную систему о причине "смерти" порожденного им <span class="keyword">процесса</span> и/или статистическую информацию о его работе. Подобная информация сохраняется в <span class="keyword">PCB</span> отработавшего <span class="keyword">процесса</span> до запроса процесса-родителя или до конца его деятельности, после чего все следы завершившегося <span class="keyword">процесса</span> окончательно исчезают из системы. В операционной системе Unix <span class="keyword">процессы</span>, находящиеся в <span class="keyword">состоянии</span> <span class="texample">закончил исполнение</span>, принято называть процессами-зомби.</p><div  class="lecture_mark" id="mark_79"></div><p  id="id_82">Следует заметить, что в ряде операционных систем (например, в VAX/VMS) гибель процесса-родителя приводит к <span class="keyword">завершению</span> работы всех его "детей". В других операционных системах (например, в Unix) процессы-дети продолжают свое существование и после окончания работы процесса-родителя. При этом возникает необходимость изменения информации в <span class="keyword">PCB</span> процессов-детей о породившем их <span class="keyword">процессе</span> для того, чтобы генеалогический лес <span class="keyword">процессов</span> оставался целостным. Рассмотрим следующий пример. Пусть <span class="keyword">процесс</span> с номером 2515 был порожден <span class="keyword">процессом</span> с номером 2001 и после <span class="keyword">завершения</span> его работы остается в вычислительной системе неограниченно долго. Тогда не исключено, что номер 2001 будет использован операционной системой повторно для совсем другого <span class="keyword">процесса</span>. Если не изменить информацию о процессе-родителе для <span class="keyword">процесса</span> 2515, то генеалогический лес <span class="keyword">процессов</span> окажется некорректным – <span class="keyword">процесс</span> 2515 будет считать своим родителем новый <span class="keyword">процесс</span> 2001, а <span class="keyword">процесс</span> 2001 будет открещиваться от нежданного потомка. Как правило, "осиротевшие" <span class="keyword">процессы</span> "усыновляются" одним из системных <span class="keyword">процессов</span>, который порождается при старте операционной системы и функционирует все время, пока она работает.</p><div  class="lecture_mark" id="mark_82"></div><h4 >Многоразовые операции</h4><p  id="id_83">Одноразовые <span class="keyword">операции</span> приводят к изменению количества <span class="keyword">процессов</span>, находящихся под управлением операционной системы, и всегда связаны с выделением или освобождением определенных ресурсов. Многоразовые <span class="keyword">операции</span>, напротив, не приводят к изменению количества <span class="keyword">процессов</span> в операционной системе и не обязаны быть связанными с выделением или освобождением ресурсов.</p><div  class="lecture_mark" id="mark_83"></div><p  id="id_84">В этом разделе мы кратко опишем действия, которые производит операционная система при выполнении многоразовых <span class="keyword">операций над процессами</span>. Более подробно эти действия будут рассмотрены далее в соответствующих лекциях. </p><div  class="lecture_mark" id="mark_84"></div><p  id="id_85"><span class="keyword">Запуск процесса</span>. Из числа <span class="keyword">процессов</span>, находящихся в <span class="keyword">состоянии</span> <span class="texample">готовность</span>, операционная система выбирает один <span class="keyword">процесс</span> для последующего исполнения. Критерии и алгоритмы такого выбора будут подробно рассмотрены в лекции 3 – "Планирование <span class="keyword">процессов</span>". Для избранного <span class="keyword">процесса</span> операционная система обеспечивает наличие в оперативной памяти информации, необходимой для его дальнейшего выполнения. То, как она это делает, будет в деталях описано в лекциях 8-10. Далее <span class="keyword">состояние процесса</span> изменяется на <span class="texample"><span class="keyword">исполнение</span></span>, восстанавливаются значения регистров для данного <span class="keyword">процесса</span> и управление передается команде, на которую указывает счетчик команд <span class="keyword">процесса</span>. Все данные, необходимые для восстановления <span class="keyword">контекста</span>, извлекаются из <span class="keyword">PCB процесса</span>, над которым совершается <span class="keyword">операция</span>. </p><div  class="lecture_mark" id="mark_85"></div><p  id="id_88"><span class="keyword_def">Приостановка процесса</span>. <a name="keyword-context.3"></a>Работа <span class="keyword">процесса</span>, находящегося в <span class="keyword">состоянии</span> <span class="texample">исполнение</span>, приостанавливается в результате какого-либо прерывания. Процессор автоматически сохраняет счетчик команд и, возможно, один или несколько регистров в стеке исполняемого <span class="keyword">процесса</span>, а затем передает управление по специальному адресу обработки данного прерывания. На этом деятельность hardware по обработке прерывания завершается. По указанному адресу обычно располагается одна из частей операционной системы. Она сохраняет динамическую часть <span class="keyword">системного</span> и <span class="keyword">регистрового контекстов</span><span class="keyword"> процесса</span> в его <span class="keyword">PCB</span>, переводит <span class="keyword">процесс</span> в <span class="keyword">состояние</span> <span class="texample">готовность</span> и приступает к обработке прерывания, то есть к выполнению определенных действий, связанных с возникшим прерыванием. <span class="keyword"></span></p><div  class="lecture_mark" id="mark_88"></div><p  id="id_91"><span class="keyword_def">Блокирование процесса</span>. <a name="keyword-context.4"></a><span class="keyword">Процесс</span> блокируется, когда он не может продолжать работу, не дождавшись возникновения какого-либо события в вычислительной системе. Для этого он обращается к операционной системе с помощью определенного системного вызова. Операционная система обрабатывает системный вызов (инициализирует операцию ввода-вывода, добавляет <span class="keyword">процесс</span> в очередь <span class="keyword">процессов</span>, дожидающихся освобождения устройства или возникновения события, и т. д.) и, при необходимости сохранив нужную часть <span class="keyword">контекста процесса</span> в его <span class="keyword">PCB</span>, переводит <span class="keyword">процесс</span> из <span class="keyword">состояния</span> <span class="texample">исполнение</span> в <span class="keyword">состояние</span> <span class="texample">ожидание</span>.<span class="keyword"></span> Подробнее эта <span class="keyword">операция</span> будет рассматриваться в лекции 13. </p><div  class="lecture_mark" id="mark_91"></div><p  id="id_94"><span class="keyword_def">Разблокирование процесса</span>. <a name="keyword-context.5"></a>После возникновения в системе какого-либо события операционной системе нужно точно определить, какое именно событие произошло. Затем операционная система проверяет, находился ли некоторый <span class="keyword">процесс</span> в <span class="keyword">состоянии</span> <span class="texample">ожидание</span> для данного события, и если находился, переводит его в <span class="keyword">состояние</span> <span class="texample">готовность</span>, выполняя необходимые действия, связанные с наступлением события (инициализация <span class="keyword">операции</span> ввода-вывода для очередного ожидающего <span class="keyword">процесса</span> и т. п.).<span class="keyword"></span> Эта <span class="keyword">операция</span>, как и <span class="keyword">операция </span><span class="keyword">блокирования</span>, будет подробно описана в лекции 13. </p><div  class="lecture_mark" id="mark_94"></div><h4 >Переключение контекста</h4><p  id="id_97">До сих пор мы рассматривали <span class="keyword">операции над процессами</span> изолированно, независимо друг от друга. В действительности же деятельность мультипрограммной операционной системы состоит из цепочек <span class="keyword">операций</span>, выполняемых над различными <span class="keyword">процессами</span>, и сопровождается переключением процессора с одного <span class="keyword">процесса</span> на другой. </p><div  class="lecture_mark" id="mark_97"></div><p  id="id_98">Давайте для примера упрощенно рассмотрим, как в реальности может протекать <span class="keyword">операция </span><span class="keyword">разблокирования процесса</span>, ожидающего ввода-вывода (см. <a href="">рис. 2.5</a>). При исполнении процессором некоторого <span class="keyword">процесса</span> (на рисунке – <span class="keyword">процесс</span> 1) возникает прерывание от устройства ввода-вывода, сигнализирующее об окончании <span class="keyword">операций</span> на устройстве. Над выполняющимся <span class="keyword">процессом</span> производится <span class="keyword">операция </span><span class="keyword">приостановки</span>. Далее операционная система разблокирует <span class="keyword">процесс</span>, инициировавший запрос на ввод-вывод (на рисунке – <span class="keyword">процесс</span> 2) и осуществляет <span class="keyword">запуск</span> приостановленного или нового <span class="keyword">процесса</span>, выбранного при выполнении планирования (на рисунке был выбран <span class="keyword">разблокированный процесс</span>). Как мы видим, в результате обработки информации об окончании <span class="keyword">операции</span> ввода-вывода возможна смена <span class="keyword">процесса</span>, находящегося в <span class="keyword">состоянии</span> <span class="texample">исполнение</span>. </p><div  class="lecture_mark" id="mark_98"></div><p  align="left" id="id_100"><a name="image.2.5"></a><div><img src="2. Процессы_files/2-500000.gif" alt='Выполнение операции разблокирования процесса. Использование термина "код пользователя" не ограничивает общности рисунка только пользовательскими процессами' width="338" height="273"></div><br><b>Рис. 2.5.</b> 
        Выполнение операции разблокирования процесса. Использование термина "код пользователя" не ограничивает общности рисунка только пользовательскими процессами</p><div  class="lecture_mark" id="mark_100"></div><p  id="id_101">Для корректного переключения процессора с одного <span class="keyword">процесса</span> на другой необходимо сохранить <span class="keyword">контекст</span> исполнявшегося <span class="keyword">процесса</span> и восстановить <span class="keyword">контекст процесса</span>, на который будет переключен процессор. Такая процедура сохранения/восстановления работоспособности <span class="keyword">процессов</span> называется <span class="keyword">переключением контекста</span>. Время, затраченное на <span class="keyword">переключение контекста</span>, не используется вычислительной системой для совершения полезной работы и представляет собой накладные расходы, снижающие производительность системы. Оно меняется от машины к машине и обычно колеблется в диапазоне от 1 до 1000 микросекунд. Существенно сократить накладные расходы в современных операционных системах позволяет расширенная модель <span class="keyword">процессов</span>, включающая в себя понятие threads of execution (нити исполнения или просто нити). Подробнее о нитях исполнения мы будем говорить в лекции 4 – "Кооперация <span class="keyword">процессов</span> и основные аспекты ее логической организации". </p><div  class="lecture_mark" id="mark_101"></div><h3 >Заключение</h3><p  id="id_102"><a name="keyword-context.6"></a>Понятие <span class="keyword_def">процесса</span> характеризует некоторую совокупность набора исполняющихся команд, ассоциированных с ним ресурсов и текущего момента его выполнения, находящуюся под управлением операционной системы. <a name="keyword-context.7"></a>В любой момент <span class="keyword">процесс</span> полностью описывается своим <span class="keyword_def">контекстом</span>, состоящим из <span class="keyword">регистровой</span>, <span class="keyword">системной</span> и <span class="keyword">пользовательской</span> частей. <a name="keyword-context.8"></a>В операционной системе <span class="keyword">процессы</span> представляются определенной структурой данных – <span class="keyword_def">PCB</span>, отражающей содержание <span class="keyword">регистрового</span> и <span class="keyword">системного контекстов</span>. <a name="keyword-context.9"></a><span class="keyword">Процессы</span> могут находиться в пяти основных <span class="keyword_def">состояниях</span>: <span class="texample"><span class="keyword">рождение</span></span>, <span class="texample"><span class="keyword">готовность</span></span>, <span class="texample"><span class="keyword">исполнение</span></span>, <span class="texample"><span class="keyword">ожидание</span></span>, <span class="texample"><span class="keyword">закончил исполнение</span></span>. <a name="keyword-context.10"></a>Из <span class="keyword">состояния</span> в <span class="keyword">состояние</span><span class="keyword"> процесс</span> переводится операционной системой в результате выполнения над ним <span class="keyword_def">операций</span>. Операционная система может выполнять над <span class="keyword">процессами</span> следующие <span class="keyword">операции</span>: <span class="keyword">создание процесса</span>, <span class="keyword">завершение процесса</span>, <span class="keyword">приостановка процесса</span>, <span class="keyword">запуск процесса</span>, <span class="keyword">блокирование процесса</span>, <span class="keyword">разблокирование процесса</span>, изменение приоритета <span class="keyword">процесса</span>. <a name="keyword-context.11"></a>Между <span class="keyword">операциями</span> содержимое <span class="keyword">PCB</span> не изменяется. Деятельность мультипрограммной операционной системы состоит из цепочек перечисленных <span class="keyword">операций</span>, выполняемых над различными <span class="keyword">процессами</span>, и сопровождается процедурами сохранения/восстановления работоспособности <span class="keyword">процессов</span>, т. е. <span class="keyword_def">переключением контекста</span>. <span class="keyword">Переключение контекста</span> не имеет отношения к полезной работе, выполняемой <span class="keyword">процессами</span>, и время, затраченное на него, сокращает полезное время работы процессора.</p><div  class="lecture_mark" id="mark_102"></div>


	</td>
	</tr>
	<tr><td height="8"><img src="2. Процессы_files/empty000.gif" width="1" height="8"></td></tr>
	</table>
	<!-- /content -->

</td>
<td><img src="2. Процессы_files/empty000.gif" width="8" height="1"></td>
</tr>
</table>
<!-- /bottom -->
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td class="orang" height="1"><img src="2. Процессы_files/empty000.gif" width="1" height="1"></td></tr>
<td class="ltxt" align=center>&copy; INTUIT.ru, 2003-2008. Все права защищены.</td>
</tr>
</table>
<!-- /bottom -->

<script src="2. Процессы_files/urchin00.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-3475067-1";
urchinTracker();
</script></body>
</html>


<!-- This document saved from http://www.intuit.ru/department/os/osintro/2/osintro_2.html -->
