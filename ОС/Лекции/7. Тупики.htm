<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>INTUIT.ru::Интернет-Университет Информационных Технологий</title>
<link href="7. Тупики_files/printabl.css" type="text/css" rel="stylesheet">
</head>
<body leftmargin="6" topmargin="6" marginheight="6" marginwidth="6">


<div align="left">
<span style="color: #000000; font-weight: bold;">
&nbsp;&nbsp;
<span style="font-size:12pt;">Интернет-Университет Информационных Технологий</span>
</span>
</div>

&nbsp;&nbsp;
<span align="rright" style="color: #330066; text-decoration:underline;">http://www.INTUIT.ru</span>


<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td height="8" colspan=3><img src="7. Тупики_files/empty000.gif" width="1" height="8"></td></tr>
<tr><td class="orang" height="1" colspan=3><img src="7. Тупики_files/empty000.gif" width="1" height="1"></td></tr>
<tr><td height="8" colspan=3><img src="7. Тупики_files/empty000.gif" width="1" height="8"></td></tr>
<tr valign="top">
<td><img src="7. Тупики_files/empty000.gif" width="8" height="1"></td>
<td>
	<!-- content -->
	<table border="0" cellpadding="0" cellspacing="0" width="100%">
	<tr><td class="head">Основы операционных систем</td></tr>
<tr><td height="4"><img src="7. Тупики_files/empty000.gif" width="1" height="4"></td></tr>
	<tr><td class="orang" height="1"><img src="7. Тупики_files/empty000.gif" width="1" height="1"></td></tr>
	<tr><td height="8"><img src="7. Тупики_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td><span class="headsub">


7. Лекция:

 Тупики: версия для печати и PDA</span>

<br>
<span class="rtxt">В лекции рассматриваются вопросы взаимоблокировок, тупиковых ситуаций и "зависаний" системы
</span>

</td></tr>

	<tr><td height="8"><img src="7. Тупики_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td class="orang" height="1"><img src="7. Тупики_files/empty000.gif" width="1" height="1"></td></tr>
	<tr><td height="8"><img src="7. Тупики_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td>


<h3 >Введение </h3><p  id="id_1">В предыдущих лекциях мы рассматривали способы синхронизации процессов, которые позволяют процессам успешно кооперироваться. Однако в некоторых случаях могут возникнуть непредвиденные затруднения. Предположим, что несколько процессов конкурируют за обладание конечным числом <span class="keyword">ресурсов</span>. <a name="keyword-context.1"></a>Если запрашиваемый процессом <span class="keyword">ресурс</span> недоступен, ОС переводит данный процесс в состояние ожидания. В случае когда требуемый <span class="keyword">ресурс</span> удерживается другим ожидающим процессом, первый процесс не сможет сменить свое состояние. Такая ситуация называется <span class="keyword_def">тупиком (deadlock)</span>.  <a name="keyword-context.2"></a>Говорят, что в мультипрограммной системе процесс находится в состоянии <span class="keyword">тупика</span>, если он ожидает события, которое никогда не произойдет. <a name="keyword-context.3"></a>Системная <span class="keyword">тупиковая ситуация</span>, или "зависание системы", является следствием 
того, что один или более процессов находятся в состоянии <span class="keyword">тупика</span>. Иногда подобные ситуации называют <span class="keyword_def">взаимоблокировками</span>. В общем случае проблема <span class="keyword">тупиков</span> эффективного решения не имеет.</p><div  class="lecture_mark" id="mark_1"></div><p  id="id_2">Рассмотрим пример. Предположим, что два процесса осуществляют вывод с ленты на принтер. Один из них успел монополизировать ленту и претендует на принтер, а другой наоборот. После этого оба процесса оказываются заблокированными в ожидании второго <span class="keyword">ресурса</span> (см. <a href="">рис. 7.1</a>).</p><div  class="lecture_mark" id="mark_2"></div><p  align="left" id="id_3"><a name="image.7.1"></a><div><img src="7. Тупики_files/7-100000.gif" alt="Пример тупиковой ситуации" width="420" height="165"></div><br><b>Рис. 7.1.</b> 
        Пример тупиковой ситуации</p><div  class="lecture_mark" id="mark_3"></div><p  id="id_4"><b>Определение</b>. Множество процессов находится в <span class="keyword">тупиковой ситуации</span>, если каждый процесс из множества ожидает события, которое может вызвать только другой процесс данного множества. Так как все процессы чего-то ожидают, то ни один из них не сможет инициировать событие, которое разбудило бы другого члена множества и, следовательно, все процессы будут спать вместе.</p><div  class="lecture_mark" id="mark_4"></div><p  id="id_5">Выше приведен пример <span class="keyword">взаимоблокировки</span>, возникающей при работе с так называемыми выделенными устройствами. <span class="keyword">Тупики</span>, однако, могут иметь место и в других ситуациях. Hапример, в системах управления базами данных записи могут быть локализованы процессами, чтобы избежать состояния гонок (см. лекцию 5 "Алгоритмы синхронизации"). В этом случае может получиться так, что один из процессов заблокировал записи, необходимые другому процессу, и наоборот. Таким образом, <span class="keyword">тупики</span> могут иметь место как на аппаратных, так и на программных <span class="keyword">ресурсах</span>.</p><div  class="lecture_mark" id="mark_5"></div><p  id="id_6"><span class="keyword">Тупики</span> также могут быть вызваны ошибками программирования. Например, процесс может напрасно ждать открытия семафора, потому что в некорректно написанном приложении эту операцию забыли предусмотреть. Другой причиной бесконечного ожидания может быть дискриминационная политика по отношению к некоторым процессам. Однако чаще всего событие, которого ждет процесс в <span class="keyword">тупиковой ситуации</span>, – освобождение <span class="keyword">ресурса</span>, поэтому в дальнейшем будут рассмотрены методы борьбы с <span class="keyword">тупиками</span> ресурсного типа.</p><div  class="lecture_mark" id="mark_6"></div><p  id="id_7"><span class="keyword">Ресурсами</span> могут быть как устройства, так и данные. Hекоторые <span class="keyword">ресурсы</span> допускают разделение между процессами, то есть являются <b>разделяемыми</b>   <span class="keyword">ресурсами</span>. Например, память, процессор, диски коллективно используются процессами. Другие не допускают разделения, то есть являются <b>выделенными</b>, например лентопротяжное устройство. К <span class="keyword">взаимоблокировке</span> может привести использование как выделенных, так и разделяемых <span class="keyword">ресурсов</span>. Например, чтение с разделяемого диска может одновременно осуществляться несколькими процессами, тогда как запись предполагает исключительный доступ к данным на диске. Можно считать, что часть диска, куда происходит запись, выделена конкретному процессу. Поэтому в дальнейшем мы будем исходить из предположения, что <span class="keyword">тупики</span> связаны с выделенными <span class="keyword">ресурсами
</span>, то есть <span class="keyword">тупики</span> возникают, когда процессу предоставляется эксклюзивный доступ к устройствам, файлам и другим <span class="keyword">ресурсам</span>.</p><div  class="lecture_mark" id="mark_7"></div><p  id="id_8">Традиционная последовательность событий при работе с <span class="keyword">ресурсом</span> состоит из запроса, использования и освобождения <span class="keyword">ресурса</span>. Тип запроса зависит от природы <span class="keyword">ресурса</span> и от ОС. Запрос может быть явным, например специальный вызов request, или неявным – open для открытия файла. Обычно, если <span class="keyword">ресурс</span> занят и запрос отклонен, запрашивающий процесс переходит в состояние ожидания.</p><div  class="lecture_mark" id="mark_8"></div><p  id="id_9">Далее в данной лекции будут рассматриваться вопросы обнаружения, предотвращения, обхода <span class="keyword">тупиков</span> и восстановления после <span class="keyword">тупиков</span>. Как правило, борьба с <span class="keyword">тупиками</span> – очень дорогостоящее мероприятие. Тем не менее для ряда систем, например для систем реального времени, иного выхода нет.</p><div  class="lecture_mark" id="mark_9"></div><h3 >Условия возникновения тупиков</h3><p  id="id_10"><span class="keyword">Условия возникновения тупиков</span> были сформулированы Коффманом, Элфиком и Шошани в 1970 г.</p><div  class="lecture_mark" id="mark_10"></div><ol  id="id_11"><li>Условие взаимоисключения (Mutual exclusion). Одновременно использовать <span class="keyword">ресурс</span> может только один процесс.</li><li>Условие ожидания <span class="keyword">ресурсов</span> (Hold and wait). Процессы удерживают <span class="keyword">ресурсы</span>, уже выделенные им, и могут запрашивать другие <span class="keyword">ресурсы</span>. </li><li>Условие неперераспределяемости (No preemtion). <span class="keyword">Ресурс</span>, выделенный ранее, не может быть принудительно забран у процесса. Освобождены они могут быть только процессом, который их удерживает.</li><li>Условие кругового ожидания (Circular wait). Существует кольцевая цепь процессов, в которой каждый процесс ждет доступа к <span class="keyword">ресурсу</span>, удерживаемому другим процессом цепи.</li></ol><div  class="lecture_mark" id="mark_11"></div><p  id="id_16">Для образования <span class="keyword">тупика</span> необходимым и достаточным является выполнение <b>всех четырех</b> условий. </p><div  class="lecture_mark" id="mark_16"></div><p  id="id_17">Обычно <span class="keyword">тупик</span> моделируется циклом в графе, состоящем из узлов двух видов: прямоугольников – процессов и эллипсов – <span class="keyword">ресурсов</span>, наподобие того, что изображен на <a href="">рис. 7.1</a>. Стрелки, направленные от <span class="keyword">ресурса</span> к процессу, показывают, что <span class="keyword">ресурс</span> выделен данному процессу. Стрелки, направленные от процесса к <span class="keyword">ресурсу</span>, означают, что процесс запрашивает данный <span class="keyword">ресурс</span>.</p><div  class="lecture_mark" id="mark_17"></div><h3 >Основные направления борьбы с тупиками</h3><p  id="id_18">Проблема <span class="keyword">тупиков</span> инициировала много интересных исследований в области информатики. Очевидно, что условие циклического ожидания отличается от остальных. Первые три условия формируют правила, существующие в системе, тогда как четвертое условие описывает ситуацию, которая может сложиться при определенной неблагоприятной последовательности событий. Поэтому методы предотвращения <span class="keyword">взаимоблокировок</span> ориентированы главным образом на нарушение первых трех условий путем введения ряда ограничений на поведение процессов и способы распределения <span class="keyword">ресурсов</span>. Методы обнаружения и устранения менее консервативны и сводятся к поиску и разрыву цикла ожидания <span class="keyword">ресурсов</span>. </p><div  class="lecture_mark" id="mark_18"></div><p  id="id_19">Итак, основные направления борьбы с <span class="keyword">тупиками</span>:</p><div  class="lecture_mark" id="mark_19"></div><ul  id="id_20"><li>Игнорирование проблемы в целом</li><li>Предотвращение <span class="keyword">тупиков</span></li><li>Обнаружение <span class="keyword">тупиков</span></li><li>Восстановление после <span class="keyword">тупиков</span></li></ul><div  class="lecture_mark" id="mark_20"></div><h3 >Игнорирование проблемы тупиков</h3><p  id="id_25">Простейший подход – не замечать проблему <span class="keyword">тупиков</span>. Для того чтобы принять такое решение, необходимо оценить вероятность возникновения <span class="keyword">взаимоблокировки</span> и сравнить ее с вероятностью ущерба от других отказов аппаратного и программного обеспечения. Проектировщики обычно не желают жертвовать производительностью системы или удобством пользователей для внедрения сложных и дорогостоящих средств борьбы с <span class="keyword">тупиками</span>.</p><div  class="lecture_mark" id="mark_25"></div><p  id="id_26">Любая ОС, имеющая в ядре ряд массивов фиксированной размерности, потенциально страдает от <span class="keyword">тупиков</span>, даже если они не обнаружены. Таблица открытых файлов, таблица процессов, фактически каждая таблица являются ограниченными <span class="keyword">ресурсами</span>. Заполнение всех записей таблицы процессов может привести к тому, что очередной запрос на создание процесса может быть отклонен. При неблагоприятном стечении обстоятельств несколько процессов могут выдать такой запрос одновременно и оказаться в <span class="keyword">тупике</span>. Следует ли отказываться от вызова CreateProcess, чтобы решить эту проблему?</p><div  class="lecture_mark" id="mark_26"></div><p  id="id_27">Подход большинства популярных ОС (Unix, Windows и др.) состоит в том, чтобы игнорировать данную проблему в предположении, что маловероятный случайный <span class="keyword">тупик</span> предпочтительнее, чем нелепые правила, заставляющие пользователей ограничивать число процессов, открытых файлов и т. п. Сталкиваясь с нежелательным выбором между строгостью и удобством, трудно найти решение, которое устраивало бы всех.</p><div  class="lecture_mark" id="mark_27"></div><h3 >Способы предотвращения тупиков</h3><p  id="id_28">Цель предотвращения <span class="keyword">тупиков</span> – обеспечить условия, исключающие возможность возникновения <span class="keyword">тупиковых</span> ситуаций. Большинство методов связано с предотвращением одного из <span class="keyword">условий возникновения взаимоблокировки</span>.</p><div  class="lecture_mark" id="mark_28"></div><p  id="id_29">Система, предоставляя <span class="keyword">ресурс</span> в распоряжение процесса, должна принять решение, безопасно это или нет. Возникает вопрос: есть ли такой алгоритм, который помогает всегда избегать <span class="keyword">тупиков</span> и делать правильный выбор. Ответ – да, мы можем избегать <span class="keyword">тупиков</span>, но только если определенная информация известна заранее. </p><div  class="lecture_mark" id="mark_29"></div><h4 >Способы предотвращения тупиков путем тщательного распределения ресурсов. Алгоритм банкира</h4><p  id="id_30">Можно избежать <span class="keyword">взаимоблокировки</span>, если распределять <span class="keyword">ресурсы</span>, придерживаясь определенных правил. Среди такого рода алгоритмов наиболее известен <span class="keyword_def">алгоритм банкира</span>, предложенный Дейкстрой, который базируется на так называемых <b>безопасных</b> или <b>надежных</b> состояниях (safe state). <a name="keyword-context.4"></a><span class="keyword_def">Безопасное состояние</span> – это такое состояние, для которого имеется по крайней мере одна последовательность событий, которая не приведет к <span class="keyword">взаимоблокировке</span>. Модель алгоритма основана на действиях банкира, который, имея в наличии капитал, выдает кредиты.</p><div  class="lecture_mark" id="mark_30"></div><p  id="id_31">Суть алгоритма состоит в следующем.</p><div  class="lecture_mark" id="mark_31"></div><ul  id="id_32"><li>Предположим, что у системы в наличии n устройств, например лент.</li><li>ОС принимает запрос от пользовательского процесса, если его максимальная потребность не превышает n.</li><li>Пользователь гарантирует, что если ОС в состоянии удовлетворить его запрос, то все устройства будут возвращены системе в течение конечного времени.</li><li>Текущее состояние системы называется <b>надежным</b>, если ОС может обеспечить всем процессам их выполнение в течение конечного времени.</li><li>В соответствии с <span class="keyword">алгоритмом банкира</span> выделение устройств возможно, только если состояние системы остается надежным.</li></ul><div  class="lecture_mark" id="mark_32"></div><p  id="id_38">Рассмотрим пример надежного состояния для системы с 3 пользователями и 11 устройствами, где 9 устройств задействовано, а 2 имеется в резерве. Пусть текущая ситуация такова:</p><div  class="lecture_mark" id="mark_38"></div><p  align="left" id="id_39"><a name="image.7.2"></a><div><img src="7. Тупики_files/7-200000.gif" alt="Пример надежного состояния для системы с 3 пользователями и 11 устройствами." width="548" height="171"></div><br><b>Рис. 7.2.</b> 
        Пример надежного состояния для системы с 3 пользователями и 11 устройствами.</p><div  class="lecture_mark" id="mark_39"></div><p  id="id_40">Данное состояние надежно. Последующие действия системы могут быть таковы. Вначале удовлетворить запросы третьего пользователя, затем дождаться, когда он закончит работу и освободит свои три устройства. Затем можно обслужить первого и второго пользователей. То есть система удовлетворяет только те запросы, которые оставляют ее в надежном состоянии, и отклоняет остальные. </p><div  class="lecture_mark" id="mark_40"></div><p  id="id_41">Термин <b>ненадежное</b> состояние не предполагает, что обязательно возникнут <span class="keyword">тупики</span>. Он лишь говорит о том, что в случае неблагоприятной последовательности событий система может зайти в <span class="keyword">тупик</span>.</p><div  class="lecture_mark" id="mark_41"></div><p  id="id_42">Данный алгоритм обладает тем достоинством, что при его использовании нет необходимости в перераспределении <span class="keyword">ресурсов</span> и откате процессов назад. Однако использование этого метода требует выполнения ряда условий.</p><div  class="lecture_mark" id="mark_42"></div><ul  id="id_43"><li>Число пользователей и число <span class="keyword">ресурсов</span> фиксировано. </li><li>Число работающих пользователей должно оставаться постоянным. </li><li>Алгоритм требует, чтобы клиенты гарантированно возвращали <span class="keyword">ресурсы</span>. </li><li>Должны быть заранее указаны максимальные требования процессов к <span class="keyword">ресурсам</span>. Чаще всего данная информация отсутствует.</li></ul><div  class="lecture_mark" id="mark_43"></div><p  id="id_48">Наличие таких жестких и зачастую неприемлемых требований может склонить разработчиков к выбору других решений проблемы <span class="keyword">взаимоблокировки</span>.</p><div  class="lecture_mark" id="mark_48"></div><h4 >Предотвращение тупиков за счет нарушения условий возникновения тупиков</h4><p  id="id_49">В отсутствие информации о будущих запросах единственный способ избежать <span class="keyword">взаимоблокировки</span> – добиться невыполнения хотя бы одного из условий раздела <span class="keyword">"Условия возникновения тупиков</span>". </p><div  class="lecture_mark" id="mark_49"></div><h5 >Нарушение условия взаимоисключения</h5><p  id="id_50">В общем случае избежать взаимоисключений невозможно. Доступ к некоторым <span class="keyword">ресурсам</span> должен быть исключительным. Тем не менее некоторые устройства удается обобществить. В качестве примера рассмотрим принтер. Известно, что пытаться осуществлять вывод на принтер могут несколько процессов. Во избежание хаоса организуют промежуточное формирование всех выходных данных процесса на диске, то есть разделяемом устройстве. Лишь один системный процесс, называемый сервисом или демоном принтера, отвечающий за вывод документов на печать по мере освобождения принтера, реально с ним взаимодействует. Эта схема называется спулингом (spooling). Таким образом, принтер становится разделяемым устройством, и <span class="keyword">тупик</span> для него устранен.</p><div  class="lecture_mark" id="mark_50"></div><p  id="id_51">К сожалению, не для всех устройств и не для всех данных можно организовать спулинг. Неприятным побочным следствием такой модели может быть потенциальная <span class="keyword">тупиковая ситуация</span> из-за конкуренции за дисковое пространство для буфера спулинга. Тем не менее в той или иной форме эта идея применяется часто. </p><div  class="lecture_mark" id="mark_51"></div><h5 >Нарушение условия ожидания дополнительных ресурсов</h5><p  id="id_52">Условия ожидания <span class="keyword">ресурсов</span> можно избежать, потребовав выполнения стратегии двухфазного захвата. </p><div  class="lecture_mark" id="mark_52"></div><ul  id="id_53"><li>В первой фазе процесс должен запрашивать все необходимые ему <span class="keyword">ресурсы</span> сразу. До тех пор пока они не предоставлены, процесс не может продолжать выполнение. </li><li>Если в первой фазе некоторые <span class="keyword">ресурсы</span>, которые были нужны данному процессу, уже заняты другими процессами, он освобождает все <span class="keyword">ресурсы</span>, которые были ему выделены, и пытается повторить первую фазу.</li></ul><div  class="lecture_mark" id="mark_53"></div><p  id="id_56">В известном смысле этот подход напоминает требование захвата всех <span class="keyword">ресурсов</span> заранее. Естественно, что только специально организованные программы могут быть приостановлены в течение первой фазы и рестартованы впоследствии. </p><div  class="lecture_mark" id="mark_56"></div><p  id="id_57">Таким образом, один из способов – заставить все процессы затребовать нужные им <span class="keyword">ресурсы</span> перед выполнением ("все или ничего"). Если система в состоянии выделить процессу все необходимое, он может работать до завершения. Если хотя бы один из <span class="keyword">ресурсов</span> занят, процесс будет ждать. </p><div  class="lecture_mark" id="mark_57"></div><p  id="id_58">Данное решение применяется в пакетных <b>мэйнфреймах</b> (mainframe), которые требуют от пользователей перечислить все необходимые его программе <span class="keyword">ресурсы</span>. Другим примером может служить механизм двухфазной локализации записей в СУБД. Однако в целом подобный подход не слишком привлекателен и приводит к неэффективному использованию компьютера. Как уже отмечалось, перечень будущих запросов к <span class="keyword">ресурсам</span> редко удается спрогнозировать. Если такая информация есть, то можно воспользоваться <span class="keyword">алгоритмом банкира</span>. Заметим также, что описываемый подход противоречит парадигме модульности в программировании, поскольку приложение должно знать о предполагаемых запросах к <span class="keyword">ресурсам</span> во всех модулях. </p><div  class="lecture_mark" id="mark_58"></div><h5 >Нарушение принципа отсутствия перераспределения </h5><p  id="id_59">Если бы можно было отбирать <span class="keyword">ресурсы</span> у удерживающих их процессов до завершения этих процессов, то удалось бы добиться невыполнения третьего <span class="keyword">условия возникновения тупиков</span>. Перечислим минусы данного подхода.</p><div  class="lecture_mark" id="mark_59"></div><p  id="id_60">Во-первых, отбирать у процессов можно только те <span class="keyword">ресурсы</span>, состояние которых легко сохранить, а позже восстановить, например состояние процессора. Во-вторых, если процесс в течение некоторого времени использует определенные <span class="keyword">ресурсы</span>, а затем освобождает эти <span class="keyword">ресурсы</span>, он может потерять результаты работы, проделанной до настоящего момента. Наконец, следствием данной схемы может быть дискриминация отдельных процессов, у которых постоянно отбирают <span class="keyword">ресурсы</span>.</p><div  class="lecture_mark" id="mark_60"></div><p  id="id_61">Весь вопрос в цене подобного решения, которая может быть слишком высокой, если необходимость отбирать <span class="keyword">ресурсы</span> возникает часто. </p><div  class="lecture_mark" id="mark_61"></div><h5 >Hарушение условия кругового ожидания</h5><p  id="id_62">Трудно предложить разумную стратегию, чтобы избежать последнего условия из раздела <span class="keyword">"Условия возникновения тупиков</span>" – циклического ожидания.</p><div  class="lecture_mark" id="mark_62"></div><p  id="id_63">Один из способов – упорядочить <span class="keyword">ресурсы</span>. Например, можно присвоить всем <span class="keyword">ресурсам</span> уникальные номера и потребовать, чтобы процессы запрашивали <span class="keyword">ресурсы</span> в порядке их возрастания. Тогда круговое ожидание возникнуть не может. После последнего запроса и освобождения всех <span class="keyword">ресурсов</span> можно разрешить процессу опять осуществить первый запрос. Очевидно, что практически невозможно найти порядок, который удовлетворит всех.</p><div  class="lecture_mark" id="mark_63"></div><p  id="id_64">Один из немногих примеров упорядочивания <span class="keyword">ресурсов</span> – создание иерархии спин-блокировок в Windows 2000. Спин-блокировка – простейший способ синхронизации (вопросы синхронизации процессов рассмотрены в соответствующей лекции). Спин-блокировка может быть захвачена и освобождена процессом. Классическая <span class="keyword">тупиковая ситуация</span> возникает, когда процесс P1 захватывает спин-блокировку S1 и претендует на спин-блокировку S2, а процесс P2, захватывает спин-блокировку S2 и хочет дополнительно захватить спин-блокировку S1. Чтобы этого избежать, все спин-блокировки помещаются в упорядоченный список. Захват может осуществляться только в порядке, указанном в списке.</p><div  class="lecture_mark" id="mark_64"></div><p  id="id_65">Другой способ атаки условия кругового ожидания – действовать в соответствии с правилом, согласно которому каждый процесс может иметь только один <span class="keyword">ресурс</span> в каждый момент времени. Если нужен второй <span class="keyword">ресурс</span> – освободи первый. Очевидно, что для многих процессов это неприемлемо.</p><div  class="lecture_mark" id="mark_65"></div><p  id="id_66">Таким образом, технология предотвращения циклического ожидания, как правило, неэффективна и может без необходимости закрывать доступ к <span class="keyword">ресурсам</span>.</p><div  class="lecture_mark" id="mark_66"></div><h4 >Обнаружение тупиков </h4><p  id="id_67">Обнаружение <span class="keyword">взаимоблокировки</span> сводится к фиксации <span class="keyword">тупиковой ситуации</span> и выявлению вовлеченных в нее процессов. Для этого производится проверка наличия циклического ожидания в случаях, когда выполнены первые три <span class="keyword">условия возникновения тупика</span>. Методы обнаружения активно используют графы распределения <span class="keyword">ресурсов</span>.</p><div  class="lecture_mark" id="mark_67"></div><p  id="id_68">Рассмотрим модельную ситуацию.</p><div  class="lecture_mark" id="mark_68"></div><ul  id="id_69"><li>Процесс P<sub>1</sub> ожидает <span class="keyword">ресурс</span> R<sub>1</sub>.</li><li>Процесс P<sub>2</sub> удерживает <span class="keyword">ресурс</span> R<sub>2</sub> и ожидает <span class="keyword">ресурс</span> R<sub>1</sub>.</li><li>Процесс P<sub>3</sub> удерживает <span class="keyword">ресурс</span> R<sub>1</sub> и ожидает <span class="keyword">ресурс</span> R<sub>3</sub>.</li><li>Процесс P<sub>4</sub> ожидает <span class="keyword">ресурс</span> R<sub>2</sub>.</li><li>Процесс P<sub>5</sub> удерживает <span class="keyword">ресурс</span> R<sub>3</sub> и ожидает <span class="keyword">ресурс</span> R<sub>2</sub>.</li></ul><div  class="lecture_mark" id="mark_69"></div><p  id="id_75">Вопрос состоит в том, является ли данная ситуация <span class="keyword">тупиковой</span>, и если да, то какие процессы в ней участвуют. Для ответа на этот вопрос можно сконструировать граф <span class="keyword">ресурсов</span>, как показано на <a href="">рис. 7.3</a>. Из рисунка видно, что имеется цикл, моделирующий условие кругового ожидания, и что процессы P<sub>2</sub>,P<sub>3</sub>,P<sub>5</sub>, а может быть, и другие находятся в <span class="keyword">тупиковой ситуации</span>.</p><div  class="lecture_mark" id="mark_75"></div><p  align="left" id="id_76"><a name="image.7.3"></a><div><img src="7. Тупики_files/7-300000.gif" alt="Граф ресурсов" width="549" height="260"></div><br><b>Рис. 7.3.</b> 
        Граф ресурсов</p><div  class="lecture_mark" id="mark_76"></div><p  id="id_77">Визуально легко обнаружить наличие <span class="keyword">тупика</span>, но нужны также формальные алгоритмы, реализуемые на компьютере. </p><div  class="lecture_mark" id="mark_77"></div><p  id="id_78">Один из таких алгоритмов описан в [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#30">Таненбаум, 2002</a>], там же можно найти ссылки на другие алгоритмы.</p><div  class="lecture_mark" id="mark_78"></div><p  id="id_79">Существуют и другие способы обнаружения <span class="keyword">тупиков</span>, применимые также в ситуациях, когда имеется несколько <span class="keyword">ресурсов</span> каждого типа. Так в [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#16">Дейтел, 1987</a>] описан способ, называемый редукцией графа распределения <span class="keyword">ресурсов</span>, а в [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#30">Таненбаум, 2002</a>] – матричный алгоритм. </p><div  class="lecture_mark" id="mark_79"></div><h4 >Восстановление после тупиков </h4><p  id="id_80">Обнаружив <span class="keyword">тупик</span>, можно вывести из него систему, нарушив одно из условий существования <span class="keyword">тупика</span>. При этом, возможно, несколько процессов частично или полностью потеряют результаты проделанной работы.</p><div  class="lecture_mark" id="mark_80"></div><p  id="id_81">Сложность восстановления обусловлена рядом факторов.</p><div  class="lecture_mark" id="mark_81"></div><ul  id="id_82"><li>В большинстве систем нет достаточно эффективных средств, чтобы приостановить процесс, вывести его из системы и возобновить впоследствии с того места, где он был остановлен.</li><li>Если даже такие средства есть, то их использование требует затрат и внимания оператора.</li><li>Восстановление после <span class="keyword">тупика</span> может потребовать значительных усилий.</li></ul><div  class="lecture_mark" id="mark_82"></div><p  id="id_86">Самый простой и наиболее распространенный способ устранить <span class="keyword">тупик</span> – завершить выполнение одного или более процессов, чтобы впоследствии использовать его <span class="keyword">ресурсы</span>. Тогда в случае удачи остальные процессы смогут выполняться. Если это не помогает, можно ликвидировать еще несколько процессов. После каждой ликвидации должен запускаться алгоритм обнаружения <span class="keyword">тупика</span>.</p><div  class="lecture_mark" id="mark_86"></div><p  id="id_87">По возможности лучше ликвидировать тот процесс, который может быть без ущерба возвращен к началу (такие процессы называются идемпотентными). Примером такого процесса может служить компиляция. С другой стороны, процесс, который изменяет содержимое базы данных, не всегда может быть корректно запущен повторно.</p><div  class="lecture_mark" id="mark_87"></div><p  id="id_88">В некоторых случаях можно временно забрать <span class="keyword">ресурс</span> у текущего владельца и передать его другому процессу. Возможность забрать <span class="keyword">ресурс</span> у процесса, дать его другому процессу и затем без ущерба вернуть назад сильно зависит от природы <span class="keyword">ресурса</span>. Подобное восстановление часто затруднительно, если не невозможно.</p><div  class="lecture_mark" id="mark_88"></div><p  id="id_89">В ряде систем реализованы средства отката и перезапуска или рестарта с контрольной точки (сохранение состояния системы в какой-то момент времени). Если проектировщики системы знают, что <span class="keyword">тупик</span> вероятен, они могут периодически организовывать для процессов контрольные точки. Иногда это приходится делать разработчикам прикладных программ.</p><div  class="lecture_mark" id="mark_89"></div><p  id="id_90">Когда <span class="keyword">тупик</span> обнаружен, видно, какие <span class="keyword">ресурсы</span> вовлечены в цикл кругового ожидания. Чтобы осуществить восстановление, процесс, который владеет таким <span class="keyword">ресурсом</span>, должен быть отброшен к моменту времени, предшествующему его запросу на этот <span class="keyword">ресурс</span>. </p><div  class="lecture_mark" id="mark_90"></div><h4 >Заключение</h4><p  id="id_91">Возникновение <span class="keyword">тупиков</span> является потенциальной проблемой любой операционной системы. Они возникают, когда имеется группа процессов, каждый из которых пытается получить исключительный доступ к некоторым <span class="keyword">ресурсам</span> и претендует на <span class="keyword">ресурсы</span>, принадлежащие другому процессу. В итоге все они оказываются в состоянии бесконечного ожидания.</p><div  class="lecture_mark" id="mark_91"></div><p  id="id_92">С <span class="keyword">тупиками</span> можно бороться, можно их обнаруживать, избегать и восстанавливать систему после <span class="keyword">тупиков</span>. Однако цена подобных действий высока и соответствующие усилия должны предприниматься только в системах, где игнорирование <span class="keyword">тупиковых ситуаций</span> приводит к катастрофическим последствиям.</p><div  class="lecture_mark" id="mark_92"></div>


	</td>
	</tr>
	<tr><td height="8"><img src="7. Тупики_files/empty000.gif" width="1" height="8"></td></tr>
	</table>
	<!-- /content -->

</td>
<td><img src="7. Тупики_files/empty000.gif" width="8" height="1"></td>
</tr>
</table>
<!-- /bottom -->
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td class="orang" height="1"><img src="7. Тупики_files/empty000.gif" width="1" height="1"></td></tr>
<td class="ltxt" align=center>&copy; INTUIT.ru, 2003-2008. Все права защищены.</td>
</tr>
</table>
<!-- /bottom -->

<script src="7. Тупики_files/urchin00.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-3475067-1";
urchinTracker();
</script></body>
</html>


<!-- This document saved from http://www.intuit.ru/department/os/osintro/7/osintro_7.html -->
