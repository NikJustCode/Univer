<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>INTUIT.ru::Интернет-Университет Информационных Технологий</title>
<link href="1. Введение_files/printabl.css" type="text/css" rel="stylesheet">
</head>
<body leftmargin="6" topmargin="6" marginheight="6" marginwidth="6">


<div align="left">
<span style="color: #000000; font-weight: bold;">
&nbsp;&nbsp;
<span style="font-size:12pt;">Интернет-Университет Информационных Технологий</span>
</span>
</div>

&nbsp;&nbsp;
<span align="rright" style="color: #330066; text-decoration:underline;">http://www.INTUIT.ru</span>


<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td height="8" colspan=3><img src="1. Введение_files/empty000.gif" width="1" height="8"></td></tr>
<tr><td class="orang" height="1" colspan=3><img src="1. Введение_files/empty000.gif" width="1" height="1"></td></tr>
<tr><td height="8" colspan=3><img src="1. Введение_files/empty000.gif" width="1" height="8"></td></tr>
<tr valign="top">
<td><img src="1. Введение_files/empty000.gif" width="8" height="1"></td>
<td>
	<!-- content -->
	<table border="0" cellpadding="0" cellspacing="0" width="100%">
	<tr><td class="head">Основы операционных систем</td></tr>
<tr><td height="4"><img src="1. Введение_files/empty000.gif" width="1" height="4"></td></tr>
	<tr><td class="orang" height="1"><img src="1. Введение_files/empty000.gif" width="1" height="1"></td></tr>
	<tr><td height="8"><img src="1. Введение_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td><span class="headsub">


1. Лекция:

 Введение: версия для печати и PDA</span>

<br>
<span class="rtxt">В данной лекции вводится понятие операционной системы; рассматривается эволюция развития операционных систем; описываются функции операционных систем и подходы к построению операционных систем.
</span>

</td></tr>

	<tr><td height="8"><img src="1. Введение_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td class="orang" height="1"><img src="1. Введение_files/empty000.gif" width="1" height="1"></td></tr>
	<tr><td height="8"><img src="1. Введение_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td>


<h3 ></h3><p  id="id_1"><a name="keyword-context.1"></a><span class="keyword_def">Операционная система (ОС)</span> – это программа, которая обеспечивает возможность рационального использования оборудования компьютера удобным для пользователя образом. Вводная лекция рассказывает о предмете, изучаемом в рамках настоящего курса. Вначале мы попытаемся ответить на вопрос, что такое <span class="keyword">ОС</span>. Затем последует анализ эволюции <span class="keyword">ОС</span> и рассказ о возникновении основных концепций и компонентов современных <span class="keyword">ОС</span>. В заключение будет представлена классификация <span class="keyword">ОС</span> с точки зрения особенностей архитектуры и использования ресурсов компьютера.</p><div  class="lecture_mark" id="mark_1"></div><h3 >Что такое операционная система</h3><h4 >Структура вычислительной системы</h4><p  id="id_2">Из чего состоит любая вычислительная система? Во-первых, из того, что в англоязычных странах принято называть словом hardware, или техническое обеспечение: <span class="keyword">процессор</span>, память, монитор, дисковые устройства и т.д., объединенные магистральным соединением, которое называется шиной. Некоторые сведения об архитектуре компьютера имеются в приложении 1 к настоящей лекции.</p><div  class="lecture_mark" id="mark_2"></div><p  id="id_3">Во-вторых, вычислительная система состоит из программного обеспечения. Все программное обеспечение принято делить на две части: прикладное и системное. К прикладному программному обеспечению, как правило, относятся разнообразные банковские и прочие бизнес-программы, игры, текстовые процессоры и т. п. Под системным программным обеспечением обычно понимают программы, способствующие функционированию и разработке прикладных программ. Надо сказать, что деление на прикладное и системное программное обеспечение является отчасти условным и зависит от того, кто осуществляет такое деление. Так, обычный пользователь, неискушенный в программировании, может считать Microsoft Word системной программой, а, с точки зрения программиста, это – приложение. Компилятор языка Си для обычного программиста – системная программа, а для системного – прикладная. Несмотря на эту нечеткую грань, данную ситуацию можно отобразить в виде последовательности слоев (см. рис. 1.1), выделив отдельно наиболее общую часть системного программного обеспечения – операционную систему:</p><div  class="lecture_mark" id="mark_3"></div><p  align="left" id="id_4"><a name="image.1.1"></a><div><img src="1. Введение_files/1-100000.gif" alt="Слои программного обеспечения компьютерной системы" width="285" height="291"></div><br><b>Рис. 1.1.</b> 
        Слои программного обеспечения компьютерной системы</p><div  class="lecture_mark" id="mark_4"></div><h4 >Что такое ОС</h4><p  id="id_5">Большинство пользователей имеет опыт эксплуатации <span class="keyword">операционных систем</span>, но тем не менее они затруднятся дать этому понятию точное определение. Давайте кратко рассмотрим основные точки зрения.</p><div  class="lecture_mark" id="mark_5"></div><h5 >Операционная система как виртуальная машина</h5><p  id="id_6"><a name="keyword-context.2"></a>При разработке <span class="keyword_def">ОС</span> широко применяется абстрагирование, которое является важным методом упрощения и позволяет сконцентрироваться на взаимодействии высокоуровневых компонентов системы, игнорируя детали их реализации. В этом смысле <span class="keyword">ОС</span> представляет собой интерфейс между пользователем и компьютером.</p><div  class="lecture_mark" id="mark_6"></div><p  id="id_7">Архитектура большинства компьютеров на уровне машинных команд очень неудобна для использования прикладными программами. Например, работа с диском предполагает знание внутреннего устройства его электронного компонента – контроллера для ввода команд вращения диска, поиска и форматирования дорожек, чтения и записи секторов и т. д. Ясно, что средний программист не в состоянии учитывать все особенности работы оборудования (в современной терминологии – заниматься разработкой драйверов устройств), а должен иметь простую высокоуровневую абстракцию, скажем представляя информационное пространство диска как набор файлов. Файл можно открывать для чтения или записи, использовать для получения или сброса информации, а потом закрывать. Это концептуально проще, чем заботиться о деталях перемещения головок дисков или организации работы мотора. Аналогичным образом, с помощью простых и ясных абстракций, скрываются от программиста все ненужные подробности организации <span class="keyword">прерываний</span>, работы таймера, управления памятью и т. д. Более того, на современных вычислительных комплексах можно создать иллюзию неограниченного размера оперативной памяти и числа <span class="keyword">процессоров</span>. Всем этим занимается <span class="keyword">операционная система</span>. <a name="keyword-context.3"></a>Таким образом, <span class="keyword_def">операционная система</span> представляется пользователю <span class="keyword">виртуальной машиной</span>, с которой проще иметь дело, чем непосредственно с оборудованием компьютера.</p><div  class="lecture_mark" id="mark_7"></div><h5 >Операционная система как менеджер ресурсов</h5><p  id="id_8"><span class="keyword">Операционная система</span> предназначена для управления всеми частями весьма сложной архитектуры компьютера. Представим, к примеру, что произойдет, если несколько программ, работающих на одном компьютере, будут пытаться одновременно осуществлять вывод на принтер. Мы получили бы мешанину строчек и страниц, выведенных различными программами. <span class="keyword">Операционная система</span> предотвращает такого рода хаос за счет буферизации информации, предназначенной для печати, на диске и организации очереди на печать. Для многопользовательских компьютеров необходимость управления ресурсами и их защиты еще более очевидна. <a name="keyword-context.4"></a>Следовательно, <span class="keyword_def">операционная система</span>, как <span class="keyword">менеджер ресурсов</span>, осуществляет упорядоченное и контролируемое распределение <span class="keyword">процессоров</span>, памяти и других ресурсов между различными программами.</p><div  class="lecture_mark" id="mark_8"></div><h5 >Операционная система как защитник пользователей и программ</h5><p  id="id_9">Если вычислительная система допускает совместную работу нескольких пользователей, то возникает проблема организации их безопасной деятельности. Необходимо обеспечить сохранность информации на диске, чтобы никто не мог удалить или повредить чужие файлы. Нельзя разрешить программам одних пользователей произвольно вмешиваться в работу программ других пользователей. Нужно пресекать попытки несанкционированного использования вычислительной системы. Всю эту деятельность осуществляет <span class="keyword">операционная система</span> как организатор безопасной работы пользователей и их программ. <a name="keyword-context.5"></a>С такой точки зрения <span class="keyword_def">операционная система</span> представляется системой безопасности государства, на которую возложены полицейские и контрразведывательные функции.</p><div  class="lecture_mark" id="mark_9"></div><h5 >Операционная система как постоянно функционирующее ядро</h5><p  id="id_10"><a name="keyword-context.6"></a>Наконец, можно дать и такое определение: <span class="keyword_def">операционная система</span> – это программа, постоянно работающая на компьютере и взаимодействующая со всеми прикладными программами. Казалось бы, это абсолютно правильное определение, но, как мы увидим дальше, во многих современных <span class="keyword">операционных системах</span> постоянно работает на компьютере лишь часть <span class="keyword">операционной системы</span>, которую принято называть ее ядром. </p><div  class="lecture_mark" id="mark_10"></div><p  id="id_11">Как мы видим, существует много точек зрения на то, что такое <span class="keyword">операционная система</span>. Невозможно дать ей адекватное строгое определение. Нам проще сказать не что есть <span class="keyword">операционная система</span>, а для чего она нужна и что она делает. Для выяснения этого вопроса рассмотрим историю развития вычислительных систем.</p><div  class="lecture_mark" id="mark_11"></div><h4 >Краткая история эволюции вычислительных систем</h4><p  id="id_12">Мы будем рассматривать историю развития именно вычислительных, а не <span class="keyword">операционных систем</span>, потому что hardware и программное обеспечение эволюционировали совместно, оказывая взаимное влияние друг на друга. Появление новых технических возможностей приводило к прорыву в области создания удобных, эффективных и безопасных программ, а свежие идеи в программной области стимулировали поиски новых технических решений. Именно эти критерии – удобство, эффективность и безопасность – играли роль факторов естественного отбора при эволюции вычислительных систем.</p><div  class="lecture_mark" id="mark_12"></div><h5 >Первый период (1945–1955 гг.). Ламповые машины. Операционных систем нет</h5><p  id="id_13">Мы начнем исследование развития компьютерных комплексов с появления электронных вычислительных систем (опуская историю механических и электромеханических устройств).</p><div  class="lecture_mark" id="mark_13"></div><p  id="id_14">Первые шаги в области разработки электронных вычислительных машин были предприняты в конце Второй мировой войны. В середине 40-х были созданы первые ламповые вычислительные устройства и появился принцип программы, хранящейся в памяти машины (John Von Neumann, июнь 1945 г.). В то время одна и та же группа людей участвовала и в проектировании, и в эксплуатации, и в программировании вычислительной машины. Это была скорее научно-исследовательская работа в области вычислительной техники, а не регулярное использование компьютеров в качестве инструмента решения каких-либо практических задач из других прикладных областей. Программирование осуществлялось исключительно на машинном языке. Об <span class="keyword">операционных системах</span> не было и речи, все задачи организации вычислительного процесса решались вручную каждым программистом с пульта управления. За пультом мог находиться только один пользователь. Программа загружалась в память машины в лучшем случае с колоды перфокарт, а обычно с помощью панели переключателей. </p><div  class="lecture_mark" id="mark_14"></div><p  id="id_15">Вычислительная система выполняла одновременно только одну операцию (ввод-вывод или собственно вычисления). Отладка программ велась с пульта управления с помощью изучения состояния памяти и регистров машины. В конце этого периода появляется первое системное программное обеспечение: в 1951–1952 гг. возникают прообразы первых компиляторов с символических языков (Fortran и др.), а в 1954 г. Nat Rochester разрабатывает Ассемблер для IBM-701. </p><div  class="lecture_mark" id="mark_15"></div><p  id="id_16">Существенная часть времени уходила на подготовку запуска программы, а сами программы выполнялись строго последовательно. Такой режим работы называется последовательной обработкой данных. В целом первый период характеризуется крайне высокой стоимостью вычислительных систем, их малым количеством и низкой эффективностью использования. </p><div  class="lecture_mark" id="mark_16"></div><h5 >Второй период (1955 г.–начало 60-х). Компьютеры на основе транзисторов. Пакетные операционные системы</h5><p  id="id_17">С середины 50-х годов начался следующий период в эволюции вычислительной техники, связанный с появлением новой технической базы – полупроводниковых элементов. Применение <span class="keyword">транзисторов</span> вместо часто перегоравших электронных <span class="keyword">ламп</span> привело к повышению надежности компьютеров. Теперь машины могут непрерывно работать достаточно долго, чтобы на них можно было возложить выполнение практически важных задач. Снижается потребление вычислительными машинами электроэнергии, совершенствуются системы охлаждения. Размеры компьютеров уменьшились. Снизилась стоимость эксплуатации и обслуживания вычислительной техники. Началось использование ЭВМ коммерческими фирмами. Одновременно наблюдается бурное развитие алгоритмических языков (LISP, COBOL, ALGOL-60, PL-1 и т.д.). Появляются первые настоящие компиляторы, редакторы связей, библиотеки математических и служебных подпрограмм. Упрощается процесс программирования. Пропадает необходимость взваливать на одних и тех же людей весь процесс разработки и использования компьютеров. Именно в этот период происходит разделение персонала на программистов и операторов, специалистов по эксплуатации и разработчиков вычислительных машин. </p><div  class="lecture_mark" id="mark_17"></div><p  id="id_18">Изменяется сам процесс прогона программ. Теперь пользователь приносит программу с входными данными в виде колоды перфокарт и указывает необходимые ресурсы. Такая колода получает название задания. Оператор загружает задание в память машины и запускает его на исполнение. Полученные выходные данные печатаются на принтере, и пользователь получает их обратно через некоторое (довольно продолжительное) время. </p><div  class="lecture_mark" id="mark_18"></div><p  id="id_19">Смена запрошенных ресурсов вызывает приостановку выполнения программ, в результате <span class="keyword">процессор</span> часто простаивает. Для повышения эффективности использования компьютера задания с похожими ресурсами начинают собирать вместе, создавая пакет заданий.</p><div  class="lecture_mark" id="mark_19"></div><p  id="id_20"><a name="keyword-context.7"></a>Появляются первые <span class="keyword_def">системы пакетной обработки</span>, которые просто автоматизируют запуск одной программы из пакета за другой и тем самым увеличивают коэффициент загрузки <span class="keyword">процессора</span>. При реализации <span class="keyword">систем пакетной обработки</span> был разработан формализованный язык управления заданиями, с помощью которого программист сообщал системе и оператору, какую работу он хочет выполнить на вычислительной машине. <span class="keyword">Системы пакетной обработки</span> стали прообразом современных <span class="keyword">операционных систем</span>, они были первыми системными программами, предназначенными для управления вычислительным процессом. </p><div  class="lecture_mark" id="mark_20"></div><h5 >Третий период (начало 60-х – 1980 г.). Компьютеры на основе интегральных микросхем. Первые многозадачные ОС</h5><p  id="id_21">Следующий важный период развития вычислительных машин относится к началу 60-х – 1980 г. В это время в технической базе произошел переход от отдельных полупроводниковых элементов типа <span class="keyword">транзисторов</span> к <span class="keyword">интегральным микросхемам</span>. Вычислительная техника становится более надежной и дешевой. Растет сложность и количество задач, решаемых компьютерами. Повышается производительность <span class="keyword">процессоров</span>. </p><div  class="lecture_mark" id="mark_21"></div><p  id="id_22">Повышению эффективности использования процессорного времени мешает низкая скорость работы механических устройств ввода-вывода (быстрый считыватель перфокарт мог обработать 1200 перфокарт в минуту, принтеры печатали до 600 строк в минуту). Вместо непосредственного чтения пакета заданий с перфокарт в память начинают использовать его предварительную запись, сначала на магнитную ленту, а затем и на диск. Когда в процессе выполнения задания требуется ввод данных, они читаются с диска. Точно так же выходная информация сначала копируется в системный буфер и записывается на ленту или диск, а печатается только после завершения задания. Вначале действительные операции ввода-вывода осуществлялись в режиме off-line, то есть с использованием других, более простых, отдельно стоящих компьютеров. В дальнейшем они начинают выполняться на том же компьютере, который производит вычисления, то есть в режиме on-line. Такой прием получает название spooling (сокращение от Simultaneous Peripheral Operation On Line) или подкачки-откачки данных. Введение техники подкачки-откачки в <span class="keyword">пакетные системы</span> позволило совместить реальные операции ввода-вывода одного задания с выполнением другого задания, но потребовало разработки аппарата <span class="keyword">прерываний</span> для извещения <span class="keyword">процессора</span> об окончании этих операций.</p><div  class="lecture_mark" id="mark_22"></div><p  id="id_23">Магнитные ленты были устройствами последовательного доступа, то есть информация считывалась с них в том порядке, в каком была записана. Появление магнитного диска, для которого не важен порядок чтения информации, то есть устройства прямого доступа, привело к дальнейшему развитию вычислительных систем. При обработке пакета заданий на магнитной ленте очередность запуска заданий определялась порядком их ввода. При обработке пакета заданий на магнитном диске появилась возможность выбора очередного выполняемого задания. <span class="keyword">Пакетные системы</span> начинают заниматься планированием заданий: в зависимости от наличия запрошенных ресурсов, срочности вычислений и т.д. на счет выбирается то или иное задание.</p><div  class="lecture_mark" id="mark_23"></div><p  id="id_24">Дальнейшее повышение эффективности использования <span class="keyword">процессора</span> было достигнуто с помощью мультипрограммирования. Идея мультипрограммирования заключается в следующем: пока одна программа выполняет операцию ввода-вывода, <span class="keyword">процессор</span> не простаивает, как это происходило при однопрограммном режиме, а выполняет другую программу. Когда операция ввода-вывода заканчивается, <span class="keyword">процессор</span> возвращается к выполнению первой программы. Эта идея напоминает поведение преподавателя и студентов на экзамене. Пока один студент (программа) обдумывает ответ на вопрос (операция ввода-вывода), преподаватель (<span class="keyword">процессор</span>) выслушивает ответ другого студента (вычисления). Естественно, такая ситуация требует наличия в комнате нескольких студентов. Точно так же мультипрограммирование требует наличия в памяти нескольких программ одновременно. При этом каждая программа загружается в свой участок оперативной памяти, называемый разделом, и не должна влиять на выполнение другой программы. (Студенты сидят за отдельными столами и не подсказывают друг другу.)</p><div  class="lecture_mark" id="mark_24"></div><p  id="id_25">Появление мультипрограммирования требует настоящей революции в строении вычислительной системы. Особую роль здесь играет аппаратная поддержка (многие аппаратные новшества появились еще на предыдущем этапе эволюции), наиболее существенные особенности которой перечислены ниже.</p><div  class="lecture_mark" id="mark_25"></div><ul  id="id_26"><li>Реализация защитных механизмов. Программы не должны иметь самостоятельного доступа к распределению ресурсов, что приводит к появлению привилегированных и непривилегированных команд. Привилегированные команды, например команды ввода-вывода, могут исполняться только <span class="keyword">операционной системой</span>. Говорят, что она работает в привилегированном режиме. Переход управления от прикладной программы к <span class="keyword">ОС</span> сопровождается контролируемой сменой режима. Кроме того, это защита памяти, позволяющая изолировать конкурирующие пользовательские программы друг от друга, а <span class="keyword">ОС</span> – от программ пользователей. </li><li>Наличие <span class="keyword">прерываний</span>. Внешние <span class="keyword">прерывания</span> оповещают <span class="keyword">ОС</span> о том, что произошло асинхронное событие, например завершилась операция ввода-вывода. Внутренние <span class="keyword">прерывания</span> (сейчас их принято называть <span class="keyword">исключительными ситуациями</span>) возникают, когда выполнение программы привело к ситуации, требующей вмешательства <span class="keyword">ОС</span>, например деление на ноль или попытка нарушения защиты.</li><li>Развитие параллелизма в архитектуре. Прямой доступ к памяти и организация каналов ввода-вывода позволили освободить центральный <span class="keyword">процессор</span> от рутинных операций.</li></ul><div  class="lecture_mark" id="mark_26"></div><p  id="id_30">Не менее важна в организации мультипрограммирования роль <span class="keyword">операционной системы</span>. Она отвечает за следующие операции.</p><div  class="lecture_mark" id="mark_30"></div><ul  id="id_31"><li>Организация интерфейса между прикладной программой и <span class="keyword">ОС</span> при помощи <span class="keyword">системных вызовов</span>.</li><li>Организация очереди из заданий в памяти и выделение <span class="keyword">процессора</span> одному из заданий потребовало планирования использования <span class="keyword">процессора</span>.</li><li>Переключение с одного задания на другое требует сохранения содержимого регистров и структур данных, необходимых для выполнения задания, иначе говоря, контекста для обеспечения правильного продолжения вычислений.</li><li>Поскольку память является ограниченным ресурсом, нужны стратегии управления памятью, то есть требуется упорядочить процессы размещения, замещения и выборки информации из памяти.</li><li>Организация хранения информации на внешних носителях в виде файлов и обеспечение доступа к конкретному файлу только определенным категориям пользователей. </li><li>Поскольку программам может потребоваться произвести санкционированный обмен данными, необходимо их обеспечить средствами коммуникации. </li><li>Для корректного обмена данными необходимо разрешать конфликтные ситуации, возникающие при работе с различными ресурсами и предусмотреть координацию программами своих действий, т.е. снабдить систему средствами синхронизации.</li></ul><div  class="lecture_mark" id="mark_31"></div><p  id="id_39">Мультипрограммные системы обеспечили возможность более эффективного использования системных ресурсов (например, <span class="keyword">процессора</span>, памяти, периферийных устройств), но они еще долго оставались <span class="keyword">пакетными</span>. Пользователь не мог непосредственно взаимодействовать с заданием и должен был предусмотреть с помощью управляющих карт все возможные ситуации. Отладка программ по-прежнему занимала много времени и требовала изучения многостраничных распечаток содержимого памяти и регистров или использования отладочной печати.</p><div  class="lecture_mark" id="mark_39"></div><p  id="id_40">Появление электронно-лучевых дисплеев и переосмысление возможностей применения клавиатур поставили на очередь решение этой проблемы. Логическим расширением систем мультипрограммирования стали time-sharing системы, или <span class="keyword">системы разделения времени</span><sup><a href="" class="objectName">1)</a></sup>. В них <span class="keyword">процессор</span> переключается между задачами не только на время операций ввода-вывода, но и просто по прошествии определенного времени. Эти переключения происходят так часто, что пользователи могут взаимодействовать со своими программами во время их выполнения, то есть интерактивно. В результате появляется возможность одновременной работы нескольких пользователей на одной компьютерной системе. У каждого пользователя для этого должна быть хотя бы одна программа в памяти. Чтобы уменьшить ограничения на количество работающих пользователей, была внедрена идея неполного нахождения исполняемой программы в оперативной памяти. Основная часть программы находится на диске, и фрагмент, который необходимо в данный момент выполнять, может быть загружен в оперативную память, а ненужный – выкачан обратно на диск. Это реализуется с помощью механизма виртуальной памяти. Основным достоинством такого механизма является создание иллюзии неограниченной оперативной памяти ЭВМ.</p><div  class="lecture_mark" id="mark_40"></div><p  id="id_42">В <span class="keyword">системах разделения времени</span> пользователь получил возможность эффективно производить отладку программы в интерактивном режиме и записывать информацию на диск, не используя перфокарты, а непосредственно с клавиатуры. Появление on-line-файлов привело к необходимости разработки развитых файловых систем. </p><div  class="lecture_mark" id="mark_42"></div><p  id="id_43">Параллельно внутренней эволюции вычислительных систем происходила и внешняя их эволюция. До начала этого периода вычислительные комплексы были, как правило, несовместимы. Каждый имел собственную <span class="keyword">операционную систему</span>, свою систему команд и т. д. В результате программу, успешно работающую на одном типе машин, необходимо было полностью переписывать и заново отлаживать для выполнения на компьютерах другого типа. В начале третьего периода появилась идея создания семейств программно совместимых машин, работающих под управлением одной и той же <span class="keyword">операционной системы</span>. Первым семейством программно совместимых компьютеров, построенных на <span class="keyword">интегральных микросхемах</span>, стала серия машин IBM/360. Разработанное в начале 60-х годов, это семейство значительно превосходило машины второго поколения по критерию цена/производительность. За ним последовала линия компьютеров PDP, несовместимых с линией IBM, и лучшей моделью в ней стала PDP-11.</p><div  class="lecture_mark" id="mark_43"></div><p  id="id_44">Сила "одной семьи" была одновременно и ее слабостью. Широкие возможности этой концепции (наличие всех моделей: от мини-компьютеров до гигантских машин; обилие разнообразной периферии; различное окружение; различные пользователи) порождали сложную и громоздкую <span class="keyword">операционную систему</span>. Миллионы строчек Ассемблера, написанные тысячами программистов, содержали множество ошибок, что вызывало непрерывный поток публикаций о них и попыток исправления. Только в <span class="keyword">операционной системе</span> OS/360 содержалось более 1000 известных ошибок. Тем не менее идея стандартизации <span class="keyword">операционных систем</span> была широко внедрена в сознание пользователей и в дальнейшем получила активное развитие.</p><div  class="lecture_mark" id="mark_44"></div><h5 >Четвертый период (с 1980 г. по настоящее время). Персональные компьютеры. Классические, сетевые и распределенные системы</h5><p  id="id_45">Следующий период в эволюции вычислительных систем связан с появлением больших <span class="keyword">интегральных схем</span> (БИС). В эти годы произошло резкое возрастание степени интеграции и снижение стоимости микросхем. Компьютер, не отличающийся по архитектуре от PDP-11, по цене и простоте эксплуатации стал доступен отдельному человеку, а не отделу предприятия или университета. Наступила эра персональных компьютеров. Первоначально персональные компьютеры предназначались для использования одним пользователем в однопрограммном режиме, что повлекло за собой деградацию архитектуры этих ЭВМ и их <span class="keyword">операционных систем</span> (в частности, пропала необходимость защиты файлов и памяти, планирования заданий и т. п.).</p><div  class="lecture_mark" id="mark_45"></div><p  id="id_46">Компьютеры стали использоваться не только специалистами, что потребовало разработки "дружественного" программного обеспечения. </p><div  class="lecture_mark" id="mark_46"></div><p  id="id_47">Однако рост сложности и разнообразия задач, решаемых на персональных компьютерах, необходимость повышения надежности их работы привели к возрождению практически всех черт, характерных для архитектуры больших вычислительных систем.</p><div  class="lecture_mark" id="mark_47"></div><p  id="id_48">В середине 80-х стали бурно развиваться сети компьютеров, в том числе персональных, работающих под управлением <span class="keyword">сетевых</span> или <span class="keyword">распределенных операционных систем</span>. </p><div  class="lecture_mark" id="mark_48"></div><p  id="id_49">В <span class="keyword">сетевых операционных системах</span> пользователи могут получить доступ к ресурсам другого сетевого компьютера, только они должны знать об их наличии и уметь это сделать. Каждая машина в сети работает под управлением своей локальной <span class="keyword">операционной системы</span>, отличающейся от <span class="keyword">операционной системы</span> автономного компьютера наличием дополнительных средств (программной поддержкой для сетевых интерфейсных устройств и доступа к удаленным ресурсам), но эти дополнения не меняют структуру <span class="keyword">операционной системы</span>. </p><div  class="lecture_mark" id="mark_49"></div><p  id="id_50"><span class="keyword">Распределенная система</span>, напротив, внешне выглядит как обычная автономная система. Пользователь не знает и не должен знать, где его файлы хранятся – на локальной или удаленной машине – и где его программы выполняются. Он может вообще не знать, подключен ли его компьютер к сети. Внутреннее строение <span class="keyword">распределенной операционной системы</span> имеет существенные отличия от автономных систем.</p><div  class="lecture_mark" id="mark_50"></div><p  id="id_51">В дальнейшем автономные <span class="keyword">операционные системы</span> мы будем называть классическими <span class="keyword">операционными системами</span>.</p><div  class="lecture_mark" id="mark_51"></div><p  id="id_52">Просмотрев этапы развития вычислительных систем, мы можем выделить шесть основных функций, которые выполняли классические <span class="keyword">операционные системы</span> в процессе эволюции:</p><div  class="lecture_mark" id="mark_52"></div><ul  id="id_53"><li>Планирование заданий и использования <span class="keyword">процессора</span>.</li><li>Обеспечение программ средствами коммуникации и синхронизации.</li><li>Управление памятью.</li><li>Управление файловой системой.</li><li>Управление вводом-выводом.</li><li>Обеспечение безопасности</li></ul><div  class="lecture_mark" id="mark_53"></div><p  id="id_60">Каждая из приведенных функций обычно реализована в виде подсистемы, являющейся структурным компонентом <span class="keyword">ОС</span>. В каждой <span class="keyword">операционной системе</span> эти функции, конечно, реализовывались по-своему, в различном объеме. Они не были изначально придуманы как составные части <span class="keyword">операционных систем</span>, а появились в процессе развития, по мере того как вычислительные системы становились все более удобными, эффективными и безопасными. Эволюция вычислительных систем, созданных человеком, пошла по такому пути, но никто еще не доказал, что это единственно возможный путь их развития. <span class="keyword">Операционные системы</span> существуют потому, что на данный момент их существование – это разумный способ использования вычислительных систем. Рассмотрение общих принципов и алгоритмов реализации их функций и составляет содержание большей части нашего курса, в котором будут последовательно описаны перечисленные подсистемы.</p><div  class="lecture_mark" id="mark_60"></div><h4 >Основные понятия, концепции ОС</h4><p  id="id_61">В процессе эволюции возникло несколько важных концепций, которые стали неотъемлемой частью теории и практики <span class="keyword">ОС</span>. Рассматриваемые в данном разделе понятия будут встречаться и разъясняться на протяжении всего курса. Здесь дается их краткое описание.</p><div  class="lecture_mark" id="mark_61"></div><h5 >Системные вызовы</h5><p  id="id_62">В любой <span class="keyword">операционной системе</span> поддерживается механизм, который позволяет пользовательским программам обращаться к услугам ядра <span class="keyword">ОС</span>. В <span class="keyword">операционных системах</span> наиболее известной советской вычислительной машины БЭСМ-6 соответствующие средства "общения" с ядром назывались экстракодами, в <span class="keyword">операционных системах</span> IBM они назывались системными макрокомандами и т.д. В <span class="keyword">ОС</span> Unix такие средства называют <span class="keyword">системными вызовами</span>. </p><div  class="lecture_mark" id="mark_62"></div><p  id="id_63"><a name="keyword-context.8"></a><span class="keyword_def">Системные вызовы</span> (system calls) – это интерфейс между <span class="keyword">операционной системой</span> и пользовательской программой. Они создают, удаляют и используют различные объекты, главные из которых – процессы и файлы. Пользовательская программа запрашивает сервис у <span class="keyword">операционной системы</span>, осуществляя <span class="keyword">системный вызов</span>. Имеются библиотеки процедур, которые загружают машинные регистры определенными параметрами и осуществляют <span class="keyword">прерывание</span> <span class="keyword">процессора</span>, после чего управление передается обработчику данного <span class="keyword">вызова</span>, входящему в ядро <span class="keyword">операционной системы</span>. Цель таких библиотек – сделать <span class="keyword">системный вызов</span> похожим на обычный <span class="keyword">вызов</span> подпрограммы.</p><div  class="lecture_mark" id="mark_63"></div><p  id="id_64">Основное отличие состоит в том, что при <span class="keyword">системном вызове</span> задача переходит в привилегированный режим или режим ядра (kernel mode). Поэтому <span class="keyword">системные вызовы</span> иногда еще называют программными <span class="keyword">прерываниями</span>, в отличие от аппаратных <span class="keyword">прерываний</span>, которые чаще называют просто <span class="keyword">прерываниями</span>.</p><div  class="lecture_mark" id="mark_64"></div><p  id="id_65">В этом режиме работает код ядра <span class="keyword">операционной системы</span>, причем исполняется он в адресном пространстве и в контексте вызвавшей его задачи. Таким образом, ядро <span class="keyword">операционной системы</span> имеет полный доступ к памяти пользовательской программы, и при <span class="keyword">системном вызове</span> достаточно передать адреса одной или нескольких областей памяти с параметрами <span class="keyword">вызова</span> и адреса одной или нескольких областей памяти для результатов <span class="keyword">вызова</span>.</p><div  class="lecture_mark" id="mark_65"></div><p  id="id_66">В большинстве <span class="keyword">операционных систем </span><span class="keyword">системный вызов</span> осуществляется командой программного <span class="keyword">прерывания</span> (INT). Программное <span class="keyword">прерывание</span> – это синхронное событие, которое может быть повторено при выполнении одного и того же программного кода.</p><div  class="lecture_mark" id="mark_66"></div><h5 >Прерывания</h5><p  id="id_67"><a name="keyword-context.9"></a><span class="keyword_def">Прерывание</span> (hardware interrupt) – это событие, генерируемое внешним (по отношению к <span class="keyword">процессору</span>) устройством. Посредством аппаратных <span class="keyword">прерываний</span> аппаратура либо информирует центральный <span class="keyword">процессор</span> о том, что произошло какое-либо событие, требующее немедленной реакции (например, пользователь нажал клавишу), либо сообщает о завершении асинхронной операции ввода-вывода (например, закончено чтение данных с диска в основную память). Важный тип аппаратных <span class="keyword">прерываний</span> – <span class="keyword">прерывания</span> таймера, которые генерируются периодически через фиксированный промежуток времени. <span class="keyword">Прерывания</span> таймера используются <span class="keyword">операционной системой</span> при планировании процессов. Каждый тип аппаратных <span class="keyword">прерываний</span> имеет собственный номер, однозначно определяющий источник <span class="keyword">прерывания</span>. Аппаратное <span class="keyword">прерывание</span> – это асинхронное событие, то есть оно возникает вне зависимости от того, какой код исполняется <span class="keyword">процессором</span> в данный момент. Обработка аппаратного <span class="keyword">прерывания</span> не должна учитывать, какой процесс является текущим.</p><div  class="lecture_mark" id="mark_67"></div><h5 >Исключительные ситуации</h5><p  id="id_68"><a name="keyword-context.10"></a><span class="keyword_def">Исключительная ситуация</span> (exception) – событие, возникающее в результате попытки выполнения программой команды, которая по каким-то причинам не может быть выполнена до конца. Примерами таких команд могут быть попытки доступа к ресурсу при отсутствии достаточных привилегий или обращения к отсутствующей странице памяти. <span class="keyword">Исключительные ситуации</span>, как и <span class="keyword">системные вызовы</span>, являются синхронными событиями, возникающими в контексте текущей задачи. <span class="keyword">Исключительные ситуации</span> можно разделить на исправимые и неисправимые. К исправимым относятся такие <span class="keyword">исключительные ситуации</span>, как отсутствие нужной информации в оперативной памяти. После устранения причины исправимой <span class="keyword">исключительной ситуации</span> программа может выполняться дальше. Возникновение в процессе работы <span class="keyword">операционной системы</span> исправимых <span class="keyword">исключительных ситуаций</span> считается нормальным явлением. Неисправимые <span class="keyword">исключительные ситуации</span> чаще всего возникают в результате ошибок в программах (например, деление на ноль). Обычно в таких случаях <span class="keyword">операционная система</span> реагирует завершением программы, вызвавшей <span class="keyword">исключительную ситуацию</span>.</p><div  class="lecture_mark" id="mark_68"></div><h5 >Файлы</h5><p  id="id_69">Файлы предназначены для хранения информации на внешних носителях, то есть принято, что информация, записанная, например, на диске, должна находиться внутри файла. Обычно под файлом понимают именованную часть пространства на носителе информации. </p><div  class="lecture_mark" id="mark_69"></div><p  id="id_70">Главная задача файловой системы (file system) – скрыть особенности ввода-вывода и дать программисту простую абстрактную модель файлов, независимых от устройств. Для чтения, создания, удаления, записи, открытия и закрытия файлов также имеется обширная категория <span class="keyword">системных вызовов</span> (создание, удаление, открытие, закрытие, чтение и т.д.). Пользователям хорошо знакомы такие связанные с организацией файловой системы понятия, как каталог, текущий каталог, корневой каталог, путь. Для манипулирования этими объектами в <span class="keyword">операционной системе</span> имеются <span class="keyword">системные вызовы</span>. Файловая система <span class="keyword">ОС</span> описана в лекциях 11–12.</p><div  class="lecture_mark" id="mark_70"></div><h5 >Процессы, нити</h5><p  id="id_71">Концепция процесса в <span class="keyword">ОС</span> одна из наиболее фундаментальных. Процессы подробно рассмотрены в лекциях 2–7. Там же описаны нити, или легковесные процессы.</p><div  class="lecture_mark" id="mark_71"></div><h3 >Архитектурные особенности ОС</h3><p  id="id_72">До сих пор мы говорили о взгляде на <span class="keyword">операционные системы</span> извне, о том, что делают <span class="keyword">операционные системы</span>. Дальнейший наш курс будет посвящен тому, как они это делают. Но мы пока ничего не сказали о том, что они представляют собой изнутри, какие подходы существуют к их построению.</p><div  class="lecture_mark" id="mark_72"></div><h4 >Монолитное ядро</h4><p  id="id_73">По сути дела, <span class="keyword">операционная система</span> – это обычная программа, поэтому было бы логично и организовать ее так же, как устроено большинство программ, то есть составить из процедур и функций. В этом случае компоненты <span class="keyword">операционной системы</span> являются не самостоятельными модулями, а составными частями одной большой программы. Такая структура <span class="keyword">операционной системы</span> называется <span class="keyword">монолитным ядром</span> (monolithic kernel). <span class="keyword">Монолитное ядро</span> представляет собой набор процедур, каждая из которых может вызвать каждую. Все процедуры работают в привилегированном режиме. <a name="keyword-context.11"></a>Таким образом, <span class="keyword_def">монолитное ядро</span> – это такая схема <span class="keyword">операционной системы</span>, при которой все ее компоненты являются составными частями одной программы, используют общие структуры данных и взаимодействуют друг с другом путем непосредственного вызова процедур. Для монолитной <span class="keyword">операционной системы</span> ядро совпадает со всей системой. </p><div  class="lecture_mark" id="mark_73"></div><p  id="id_74">Во многих <span class="keyword">операционных системах</span> с <span class="keyword">монолитным ядром</span> сборка ядра, то есть его компиляция, осуществляется отдельно для каждого компьютера, на который устанавливается <span class="keyword">операционная система</span>. При этом можно выбрать список оборудования и программных протоколов, поддержка которых будет включена в ядро. Так как ядро является единой программой, перекомпиляция – это единственный способ добавить в него новые компоненты или исключить неиспользуемые. Следует отметить, что присутствие в ядре лишних компонентов крайне нежелательно, так как ядро всегда полностью располагается в оперативной памяти. Кроме того, исключение ненужных компонентов повышает надежность <span class="keyword">операционной системы</span> в целом. </p><div  class="lecture_mark" id="mark_74"></div><p  id="id_75"><span class="keyword">Монолитное ядро</span> – старейший способ организации <span class="keyword">операционных систем</span>. Примером систем с <span class="keyword">монолитным ядром</span> является большинство Unix-систем.</p><div  class="lecture_mark" id="mark_75"></div><p  id="id_76">Даже в монолитных системах можно выделить некоторую структуру. Как в бетонной глыбе можно различить вкрапления щебенки, так и в <span class="keyword">монолитном ядре</span> выделяются вкрапления сервисных процедур, соответствующих <span class="keyword">системным вызовам</span>. Сервисные процедуры выполняются в привилегированном режиме, тогда как пользовательские программы – в непривилегированном. Для перехода с одного уровня привилегий на другой иногда может использоваться главная сервисная программа, определяющая, какой именно <span class="keyword">системный вызов</span> был сделан, корректность входных данных для этого <span class="keyword">вызова</span> и передающая управление соответствующей сервисной процедуре с переходом в привилегированный режим работы. Иногда выделяют также набор программных утилит, которые помогают выполнять сервисные процедуры.</p><div  class="lecture_mark" id="mark_76"></div><h4 >Многоуровневые системы (Layered systems)</h4><p  id="id_77">Продолжая структуризацию, можно разбить всю вычислительную систему на ряд более мелких уровней с хорошо определенными связями между ними, так чтобы объекты уровня N могли вызывать только объекты уровня N-1. Нижним уровнем в таких системах обычно является hardware, верхним уровнем – интерфейс пользователя. Чем ниже уровень, тем более привилегированные команды и действия может выполнять модуль, находящийся на этом уровне. Впервые такой подход был применен при создании системы THE (Technishe Hogeschool Eindhoven) Дейкстрой (Dijkstra) и его студентами в 1968 г. Эта система имела следующие уровни:</p><div  class="lecture_mark" id="mark_77"></div><p  align="left" id="id_78"><a name="image.1.2"></a><div><img src="1. Введение_files/1-200000.gif" alt="Слоеная система THE" width="272" height="116"></div><br><b>Рис. 1.2.</b> 
        Слоеная система THE</p><div  class="lecture_mark" id="mark_78"></div><p  id="id_79">Слоеные системы хорошо реализуются. При использовании операций нижнего слоя не нужно знать, как они реализованы, нужно лишь понимать, что они делают. Слоеные системы хорошо тестируются. Отладка начинается с нижнего слоя и проводится послойно. При возникновении ошибки мы можем быть уверены, что она находится в тестируемом слое. Слоеные системы хорошо модифицируются. При необходимости можно заменить лишь один слой, не трогая остальные. Но слоеные системы сложны для разработки: тяжело правильно определить порядок слоев и что к какому слою относится. Слоеные системы менее эффективны, чем монолитные. Так, например, для выполнения операций ввода-вывода программе пользователя придется последовательно проходить все слои от верхнего до нижнего.</p><div  class="lecture_mark" id="mark_79"></div><h4 >Виртуальные машины</h4><p  id="id_80">В начале лекции мы говорили о взгляде на <span class="keyword">операционную систему</span> как на <span class="keyword">виртуальную машину</span>, когда пользователю нет необходимости знать детали внутреннего устройства компьютера. Он работает с файлами, а не с магнитными головками и двигателем; он работает с огромной виртуальной, а не ограниченной реальной оперативной памятью; его мало волнует, единственный он на машине пользователь или нет. Рассмотрим несколько иной подход. <a name="keyword-context.12"></a>Пусть <span class="keyword">операционная система</span> реализует <span class="keyword_def">виртуальную машину</span> для каждого пользователя, но не упрощая ему жизнь, а, наоборот, усложняя. Каждая такая <span class="keyword">виртуальная машина</span> предстает перед пользователем как голое железо – копия всего hardware в вычислительной системе, включая <span class="keyword">процессор</span>, привилегированные и непривилегированные команды, устройства ввода-вывода, <span class="keyword">прерывания</span> и т.д. И он остается с этим железом один на один. При попытке обратиться к такому виртуальному железу на уровне привилегированных команд в действительности происходит <span class="keyword">системный вызов</span> реальной <span class="keyword">операционной системы</span>, которая и производит все необходимые действия. Такой подход позволяет каждому пользователю загрузить свою <span class="keyword">операционную систему</span> на <span class="keyword">виртуальную машину</span> и делать с ней все, что душа пожелает.</p><div  class="lecture_mark" id="mark_80"></div><p  align="left" id="id_81"><a name="image.1.3"></a><div><img src="1. Введение_files/1-300000.gif" alt="Вариант виртуальной машины" width="338" height="99"></div><br><b>Рис. 1.3.</b> 
        Вариант виртуальной машины</p><div  class="lecture_mark" id="mark_81"></div><p  id="id_82">Первой реальной системой такого рода была система CP/CMS, или VM/370, как ее называют сейчас, для семейства машин IBM/370.</p><div  class="lecture_mark" id="mark_82"></div><p  id="id_83">Недостатком таких <span class="keyword">операционных систем</span> является снижение эффективности <span class="keyword">виртуальных машин</span> по сравнению с реальным компьютером, и, как правило, они очень громоздки. Преимущество же заключается в использовании на одной вычислительной системе программ, написанных для разных <span class="keyword">операционных систем</span>.</p><div  class="lecture_mark" id="mark_83"></div><h4 >Микроядерная архитектура</h4><p  id="id_84">Современная тенденция в разработке <span class="keyword">операционных систем</span> состоит в перенесении значительной части системного кода на уровень пользователя и одновременной минимизации ядра. <a name="keyword-context.13"></a>Речь идет о подходе к построению ядра, называемом <span class="keyword_def">микроядерной архитектурой</span> (microkernel architecture) <span class="keyword">операционной системы</span>, когда большинство ее составляющих являются самостоятельными программами. В этом случае взаимодействие между ними обеспечивает специальный модуль ядра, называемый микроядром. Микроядро работает в привилегированном режиме и обеспечивает взаимодействие между программами, планирование использования <span class="keyword">процессора</span>, первичную обработку <span class="keyword">прерываний</span>, операции ввода-вывода и базовое управление памятью.</p><div  class="lecture_mark" id="mark_84"></div><p  align="left" id="id_85"><a name="image.1.4"></a><div><img src="1. Введение_files/1-400000.gif" alt="Микроядерная архитектура операционной системы" width="338" height="196"></div><br><b>Рис. 1.4.</b> 
        Микроядерная архитектура операционной системы</p><div  class="lecture_mark" id="mark_85"></div><p  id="id_86">Остальные компоненты системы взаимодействуют друг с другом путем передачи сообщений через микроядро.</p><div  class="lecture_mark" id="mark_86"></div><p  id="id_87">Основное достоинство <span class="keyword">микроядерной архитектуры</span> – высокая степень модульности ядра <span class="keyword">операционной системы</span>. Это существенно упрощает добавление в него новых компонентов. В микроядерной <span class="keyword">операционной системе</span> можно, не прерывая ее работы, загружать и выгружать новые драйверы, файловые системы и т. д. Существенно упрощается процесс отладки компонентов ядра, так как новая версия драйвера может загружаться без перезапуска всей <span class="keyword">операционной системы</span>. Компоненты ядра <span class="keyword">операционной системы</span> ничем принципиально не отличаются от пользовательских программ, поэтому для их отладки можно применять обычные средства. <span class="keyword">Микроядерная архитектура</span> повышает надежность системы, поскольку ошибка на уровне непривилегированной программы менее опасна, чем отказ на уровне режима ядра.</p><div  class="lecture_mark" id="mark_87"></div><p  id="id_88">В то же время <span class="keyword">микроядерная архитектура</span><span class="keyword"> операционной системы</span> вносит дополнительные накладные расходы, связанные с передачей сообщений, что существенно влияет на производительность. Для того чтобы микроядерная <span class="keyword">операционная система</span> по скорости не уступала <span class="keyword">операционным системам</span> на базе <span class="keyword">монолитного ядра</span>, требуется очень аккуратно проектировать разбиение системы на компоненты, стараясь минимизировать взаимодействие между ними. Таким образом, основная сложность при создании микроядерных <span class="keyword">операционных систем</span> – необходимость очень аккуратного проектирования.</p><div  class="lecture_mark" id="mark_88"></div><h4 >Смешанные системы</h4><p  id="id_89">Все рассмотренные подходы к построению <span class="keyword">операционных систем</span> имеют свои достоинства и недостатки. В большинстве случаев современные <span class="keyword">операционные системы</span> используют различные комбинации этих подходов. Так, например, ядро <span class="keyword">операционной системы</span> Linux представляет собой монолитную систему с элементами <span class="keyword">микроядерной архитектуры</span>. При компиляции ядра можно разрешить динамическую загрузку и выгрузку очень многих компонентов ядра – так называемых модулей. В момент загрузки модуля его код загружается на уровне системы и связывается с остальной частью ядра. Внутри модуля могут использоваться любые экспортируемые ядром функции.</p><div  class="lecture_mark" id="mark_89"></div><p  id="id_90">Другим примером смешанного подхода может служить возможность запуска <span class="keyword">операционной системы</span> с <span class="keyword">монолитным ядром</span> под управлением микроядра. Так устроены 4.4BSD и MkLinux, основанные на микроядре Mach. Микроядро обеспечивает управление виртуальной памятью и работу низкоуровневых драйверов. Все остальные функции, в том числе взаимодействие с прикладными программами, осуществляется <span class="keyword">монолитным ядром</span>. Данный подход сформировался в результате попыток использовать преимущества <span class="keyword">микроядерной архитектуры</span>, сохраняя по возможности хорошо отлаженный код <span class="keyword">монолитного ядра</span>.</p><div  class="lecture_mark" id="mark_90"></div><p  id="id_91">Наиболее тесно элементы <span class="keyword">микроядерной архитектуры</span> и элементы <span class="keyword">монолитного ядра</span> переплетены в ядре Windows NT. Хотя Windows NT часто называют микроядерной <span class="keyword">операционной системой</span>, это не совсем так. Микроядро NT слишком велико (более 1 Мбайт), чтобы носить приставку "микро". Компоненты ядра Windows NT располагаются в вытесняемой памяти и взаимодействуют друг с другом путем передачи сообщений, как и положено в микроядерных <span class="keyword">операционных системах</span>. В то же время все компоненты ядра работают в одном адресном пространстве и активно используют общие структуры данных, что свойственно <span class="keyword">операционным системам</span> с <span class="keyword">монолитным ядром</span>. По мнению специалистов Microsoft, причина проста: чисто микроядерный дизайн коммерчески невыгоден, поскольку неэффективен.</p><div  class="lecture_mark" id="mark_91"></div><p  id="id_92">Таким образом, Windows NT можно с полным правом назвать гибридной <span class="keyword">операционной системой</span>.</p><div  class="lecture_mark" id="mark_92"></div><h3 >Классификация ОС</h3><p  id="id_93">Существует несколько схем классификации <span class="keyword">операционных систем</span>. Ниже приведена классификация по некоторым признакам с точки зрения пользователя.</p><div  class="lecture_mark" id="mark_93"></div><h4 >Реализация многозадачности</h4><p  id="id_94">По числу одновременно выполняемых задач <span class="keyword">операционные системы</span> можно разделить на два класса: </p><div  class="lecture_mark" id="mark_94"></div><ul  id="id_95"><li><span class="keyword">многозадачные</span> (Unix, OS/2, Windows);</li><li>однозадачные (например, MS-DOS).</li></ul><div  class="lecture_mark" id="mark_95"></div><p  id="id_98"><a name="keyword-context.14"></a><span class="keyword_def">Многозадачная ОС</span>, решая проблемы распределения ресурсов и конкуренции, полностью реализует мультипрограммный режим в соответствии с требованиями раздела "Основные понятия, концепции <span class="keyword">ОС</span>". </p><div  class="lecture_mark" id="mark_98"></div><p  id="id_99">Многозадачный режим, который воплощает в себе идею разделения времени, называется вытесняющим (preemptive). Каждой программе выделяется квант <span class="keyword">процессорного</span> времени, по истечении которого управление передается другой программе. Говорят, что первая программа будет вытеснена. В вытесняющем режиме работают пользовательские программы большинства коммерческих <span class="keyword">ОС</span>. </p><div  class="lecture_mark" id="mark_99"></div><p  id="id_100">В некоторых <span class="keyword">ОС</span> (Windows 3.11, например) пользовательская программа может монополизировать <span class="keyword">процессор</span>, то есть работать в невытесняющем режиме. Как правило, в большинстве систем не подлежит вытеснению код собственно <span class="keyword">ОС</span>. Ответственные программы, в частности задачи реального времени, также не вытесняются. Более подробно об этом рассказано в лекции, посвященной планированию работы <span class="keyword">процессора</span>. </p><div  class="lecture_mark" id="mark_100"></div><p  id="id_101">По приведенным примерам можно судить о приблизительности классификации. Так, в <span class="keyword">ОС</span> MS-DOS можно организовать запуск дочерней задачи и наличие в памяти двух и более задач одновременно. Однако эта <span class="keyword">ОС</span> традиционно считается однозадачной, главным образом из-за отсутствия защитных механизмов и коммуникационных возможностей. </p><div  class="lecture_mark" id="mark_101"></div><h4 >Поддержка многопользовательского режима</h4><p  id="id_102">По числу одновременно работающих пользователей <span class="keyword">ОС</span> можно разделить на: </p><div  class="lecture_mark" id="mark_102"></div><ul  id="id_103"><li>однопользовательские (MS-DOS, Windows 3.x); </li><li><span class="keyword">многопользовательские</span> (Windows NT, Unix). </li></ul><div  class="lecture_mark" id="mark_103"></div><p  id="id_106"><a name="keyword-context.15"></a>Наиболее существенное отличие между этими <span class="keyword">ОС</span> заключается в наличии у <span class="keyword_def">многопользовательских систем</span> механизмов защиты персональных данных каждого пользователя.</p><div  class="lecture_mark" id="mark_106"></div><h4 >Многопроцессорная обработка</h4><p  id="id_107">Вплоть до недавнего времени вычислительные системы имели один центральный <span class="keyword">процессор</span>. <a name="keyword-context.16"></a>В результате требований к повышению производительности появились <span class="keyword_def">многопроцессорные системы</span>, состоящие из двух и более <span class="keyword">процессоров</span> общего назначения, осуществляющих параллельное выполнение команд. Поддержка мультипроцессирования является важным свойством <span class="keyword">ОС</span> и приводит к усложнению всех алгоритмов управления ресурсами. Многопроцессорная обработка реализована в таких <span class="keyword">ОС</span>, как Linux, Solaris, Windows NT, и ряде других.</p><div  class="lecture_mark" id="mark_107"></div><p  id="id_108"><span class="keyword">Многопроцессорные ОС</span> разделяют на симметричные и асимметричные. В симметричных <span class="keyword">ОС</span> на каждом <span class="keyword">процессоре</span> функционирует одно и то же ядро, и задача может быть выполнена на любом <span class="keyword">процессоре</span>, то есть обработка полностью децентрализована. При этом каждому из <span class="keyword">процессоров</span> доступна вся память.</p><div  class="lecture_mark" id="mark_108"></div><p  id="id_109">В асимметричных <span class="keyword">ОС</span><span class="keyword"> процессоры</span> неравноправны. Обычно существует главный <span class="keyword">процессор</span> (master) и подчиненные (slave), загрузку и характер работы которых определяет главный <span class="keyword">процессор</span>.</p><div  class="lecture_mark" id="mark_109"></div><h4 >Системы реального времени</h4><p  id="id_110">В разряд <span class="keyword">многозадачных ОС</span>, наряду с <span class="keyword">пакетными системами</span> и <span class="keyword">системами разделения времени</span>, включаются также <span class="keyword_def">системы реального времени</span>, не упоминавшиеся до сих пор.</p><div  class="lecture_mark" id="mark_110"></div><p  id="id_111"><a name="keyword-context.17"></a>Они используются для управления различными техническими объектами или технологическими процессами. Такие системы характеризуются предельно допустимым временем реакции на внешнее событие, в течение которого должна быть выполнена программа, управляющая объектом. Система должна обрабатывать поступающие данные быстрее, чем они могут поступать, причем от нескольких источников одновременно.<span class="keyword"></span></p><div  class="lecture_mark" id="mark_111"></div><p  id="id_112">Столь жесткие ограничения сказываются на архитектуре <span class="keyword">систем реального времени</span>, например, в них может отсутствовать виртуальная память, поддержка которой дает непредсказуемые задержки в выполнении программ. (См. также разделы, связанные с планированием процессов и реализацией виртуальной памяти.)</p><div  class="lecture_mark" id="mark_112"></div><p  id="id_113">Приведенная классификация <span class="keyword">ОС</span> не является исчерпывающей. Более подробно особенности применения современных <span class="keyword">ОС</span> рассмотрены в [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#23">Олифер, 2001</a>]. </p><div  class="lecture_mark" id="mark_113"></div><h3 >Заключение</h3><p  id="id_114">Мы рассмотрели различные взгляды на то, что такое <span class="keyword">операционная система</span>; изучили историю развития <span class="keyword">операционных систем</span>; выяснили, какие функции обычно выполняют <span class="keyword">операционные системы</span>; наконец, разобрались в том, какие существуют подходы к построению <span class="keyword">операционных систем</span>. Следующую лекцию мы посвятим выяснению понятия "процесс" и вопросам планирования процессов.</p><div  class="lecture_mark" id="mark_114"></div><h3 >Приложение 1.</h3><h4 >Некоторые сведения об архитектуре компьютера</h4><p  id="id_115">Основными аппаратными компонентами компьютера являются: основная память, центральный <span class="keyword">процессор</span> и периферийные устройства. Для обмена данными между собой эти компоненты соединены группой проводов, называемой магистралью (см. <a href="">рис.1.5</a>).</p><div  class="lecture_mark" id="mark_115"></div><p  align="left" id="id_116"><a name="image.1.5"></a><div><img src="1. Введение_files/1-500000.gif" alt="Некоторые компоненты компьютера" width="338" height="99"></div><br><b>Рис. 1.5.</b> 
        Некоторые компоненты компьютера</p><div  class="lecture_mark" id="mark_116"></div><p  id="id_117">Основная память используется для запоминания программ и данных в двоичном виде и организована в виде упорядоченного массива ячеек, каждая из которых имеет уникальный цифровой адрес. Как правило, размер ячейки составляет один байт. Типовые операции над основной памятью – считывание и запись содержимого ячейки с определенным адресом. </p><div  class="lecture_mark" id="mark_117"></div><p  id="id_118">Выполнение различных операций с данными осуществляется изолированной частью компьютера, называемой центральным <span class="keyword">процессором</span> (ЦП). ЦП также имеет ячейки для запоминания информации, называемые регистрами. Их разделяют на регистры общего назначения и специализированные регистры. В современных компьютерах емкость регистра обычно составляет 4–8 байт. Регистры общего назначения используются для временного хранения данных и результатов операций. Для обработки информации обычно организовывается передача данных из ячеек памяти в регистры общего назначения, выполнение операции центральным <span class="keyword">процессором</span> и передача результатов операции в основную память. </p><div  class="lecture_mark" id="mark_118"></div><p  id="id_119">Специализированные регистры используются для контроля работы <span class="keyword">процессора</span>. Наиболее важными являются: программный счетчик, регистр команд и регистр, содержащий информацию о состоянии программы.</p><div  class="lecture_mark" id="mark_119"></div><p  id="id_120">Программы хранятся в виде последовательности машинных команд, которые должен выполнять центральный <span class="keyword">процессор</span>. Каждая команда состоит из поля операции и полей операндов, то есть тех данных, над которыми выполняется данная операция. Весь набор машинных команд называется машинным языком.</p><div  class="lecture_mark" id="mark_120"></div><p  id="id_121">Выполнение программы осуществляется следующим образом. Машинная команда, на которую указывает программный счетчик, считывается из памяти и копируется в регистр команд. Здесь она декодируется, после чего исполняется. После выполнения команды программный счетчик указывает на следующую команду. Эти действия, называемые машинным циклом, затем повторяются.</p><div  class="lecture_mark" id="mark_121"></div><h4 >Взаимодействие с периферийными устройствами</h4><p  id="id_122">Периферийные устройства предназначены для ввода и вывода информации. Каждое устройство обычно имеет в своем составе специализированный компьютер, называемый контроллером или адаптером. Когда контроллер вставляется в разъем на материнской плате, он подключается к шине и получает уникальный номер (адрес). После этого контроллер осуществляет наблюдение за сигналами, идущими по шине, и отвечает на сигналы, адресованные ему. </p><div  class="lecture_mark" id="mark_122"></div><p  id="id_123">Любая операция ввода-вывода предполагает диалог между ЦП и контроллером устройства. Когда <span class="keyword">процессору</span> встречается команда, связанная с вводом-выводом, входящая в состав какой-либо программы, он выполняет ее, посылая сигналы контроллеру устройства. Это так называемый программируемый ввод-вывод.</p><div  class="lecture_mark" id="mark_123"></div><p  id="id_124">В свою очередь, любые изменения с внешними устройствами имеют следствием передачу сигнала от устройства к ЦП. С точки зрения ЦП это является асинхронным событием и требует его реакции. Для того чтобы обнаружить такое событие, между машинными циклами <span class="keyword">процессор</span> опрашивает специальный регистр, содержащий информацию о типе устройства, сгенерировавшего сигнал. Если сигнал имеет место, то ЦП выполняет специфичную для данного устройства программу, задача которой – отреагировать на это событие надлежащим образом (например, занести символ, введенный с клавиатуры, в специальный буфер). Такая программа называется программой обработки <span class="keyword">прерывания</span>, а само событие <span class="keyword">прерыванием</span>, поскольку оно нарушает плановую работу <span class="keyword">процессора</span>. После завершения обработки <span class="keyword">прерывания </span><span class="keyword">процессор</span> возвращается к выполнению программы. Эти действия компьютера называются вводом-выводом с использованием <span class="keyword">прерываний</span>.</p><div  class="lecture_mark" id="mark_124"></div><p  id="id_125">В современных компьютерах также имеется возможность непосредственного взаимодействия между контроллером и основной памятью, минуя ЦП, – так называемый механизм прямого доступа к памяти.</p><div  class="lecture_mark" id="mark_125"></div><table  border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td height="4"><img src="1. Введение_files/empty000.gif" width="1" height="4"></td></tr><tr><td class="orang"><img src="1. Введение_files/empty000.gif" width="1" height="1" border="0"></td></tr><tr><td height="8"><img src="1. Введение_files/empty000.gif" width="1" height="8"></td></tr></table>


         
        <a  name="footnote.1"></a><span  class="objectName"><sup>1)</sup></span>
         
        Реальная эволюция операционных систем происходила не так гладко и планомерно, как это представлено в данном обзоре. Так, например, первая система с разделением времени Joss была реализована еще на ламповой машине Joniac безо всякой аппаратной поддержки.


	</td>
	</tr>
	<tr><td height="8"><img src="1. Введение_files/empty000.gif" width="1" height="8"></td></tr>
	</table>
	<!-- /content -->

</td>
<td><img src="1. Введение_files/empty000.gif" width="8" height="1"></td>
</tr>
</table>
<!-- /bottom -->
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td class="orang" height="1"><img src="1. Введение_files/empty000.gif" width="1" height="1"></td></tr>
<td class="ltxt" align=center>&copy; INTUIT.ru, 2003-2008. Все права защищены.</td>
</tr>
</table>
<!-- /bottom -->

<script src="1. Введение_files/urchin00.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-3475067-1";
urchinTracker();
</script></body>
</html>


<!-- This document saved from http://www.intuit.ru/department/os/osintro/1/osintro_1.html -->
