<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>INTUIT.ru::Интернет-Университет Информационных Технологий</title>
<link href="4. Кооперация процессов и основные аспекты ее логической организации_files/printabl.css" type="text/css" rel="stylesheet">
</head>
<body leftmargin="6" topmargin="6" marginheight="6" marginwidth="6">


<div align="left">
<span style="color: #000000; font-weight: bold;">
&nbsp;&nbsp;
<span style="font-size:12pt;">Интернет-Университет Информационных Технологий</span>
</span>
</div>

&nbsp;&nbsp;
<span align="rright" style="color: #330066; text-decoration:underline;">http://www.INTUIT.ru</span>


<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td height="8" colspan=3><img src="4. Кооперация процессов и основные аспекты ее логической организации_files/empty000.gif" width="1" height="8"></td></tr>
<tr><td class="orang" height="1" colspan=3><img src="4. Кооперация процессов и основные аспекты ее логической организации_files/empty000.gif" width="1" height="1"></td></tr>
<tr><td height="8" colspan=3><img src="4. Кооперация процессов и основные аспекты ее логической организации_files/empty000.gif" width="1" height="8"></td></tr>
<tr valign="top">
<td><img src="4. Кооперация процессов и основные аспекты ее логической организации_files/empty000.gif" width="8" height="1"></td>
<td>
	<!-- content -->
	<table border="0" cellpadding="0" cellspacing="0" width="100%">
	<tr><td class="head">Основы операционных систем</td></tr>
<tr><td height="4"><img src="4. Кооперация процессов и основные аспекты ее логической организации_files/empty000.gif" width="1" height="4"></td></tr>
	<tr><td class="orang" height="1"><img src="4. Кооперация процессов и основные аспекты ее логической организации_files/empty000.gif" width="1" height="1"></td></tr>
	<tr><td height="8"><img src="4. Кооперация процессов и основные аспекты ее логической организации_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td><span class="headsub">


4. Лекция:

 Кооперация процессов
и основные аспекты ее логической организации: версия для печати и PDA</span>

<br>
<span class="rtxt">Одной из функций операционной системы является обеспечение 
санкционированного взаимодействия процессов. Лекция посвящена основам
логической организации такого взаимодействия. Рассматривается расширение 
понятия процесс – нить исполнения (thread).
</span>

</td></tr>

	<tr><td height="8"><img src="4. Кооперация процессов и основные аспекты ее логической организации_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td class="orang" height="1"><img src="4. Кооперация процессов и основные аспекты ее логической организации_files/empty000.gif" width="1" height="1"></td></tr>
	<tr><td height="8"><img src="4. Кооперация процессов и основные аспекты ее логической организации_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td>


<h3 ></h3><p  id="id_1">Взаимодействие процессов в вычислительной системе напоминает жизнь в
коммунальной квартире. Постоянное ожидание в очереди к местам общего
пользования (процессору) и ежедневная борьба за ресурсы (кто опять
занял все конфорки на плите?). Для нормального функционирования
процессов операционная система старается максимально обособить их
друг от друга. Каждый процесс имеет собственное адресное пространство
(каждая семья должна жить в отдельной комнате), нарушение которого,
как правило, приводит к аварийной остановке процесса (вызов милиции).
Каждому процессу по возможности предоставляются свои дополнительные
ресурсы (каждая семья предпочитает иметь собственный холодильник).
Тем не менее для решения некоторых задач (приготовление праздничного
стола на всю квартиру) процессы могут объединять свои усилия. В
настоящей лекции описываются причины взаимодействия процессов,
способы их взаимодействия и возникающие при этом проблемы (попробуйте
отремонтировать общую квартиру так, чтобы жильцы не перессорились
друг с другом).</p><div  class="lecture_mark" id="mark_1"></div><h3 >Взаимодействующие процессы</h3><p  id="id_2">Для достижения поставленной цели различные процессы (возможно, даже
принадлежащие разным пользователям) могут исполняться
псевдопараллельно на одной вычислительной системе или параллельно на
разных вычислительных системах, взаимодействуя между собой.</p><div  class="lecture_mark" id="mark_2"></div><p  id="id_3">Для чего процессам нужно заниматься совместной деятельностью? Какие
существуют причины для их <span class="keyword">кооперации</span>?</p><div  class="lecture_mark" id="mark_3"></div><ul  id="id_4"><li>Повышение скорости работы. Пока один процесс ожидает наступления
некоторого события (например, окончания операции ввода-вывода),
другие могут заниматься полезной работой, направленной на решение
общей задачи. В многопроцессорных вычислительных системах программа
разбивается на отдельные кусочки, каждый из которых будет исполняться
на своем процессоре.</li><li>Совместное использование данных. Различные процессы могут, к
примеру, работать с одной и той же динамической базой данных или с
разделяемым файлом, совместно изменяя их содержимое.</li><li>Модульная конструкция какой-либо системы. Типичным примером может
служить микроядерный способ построения операционной системы, когда
различные ее части представляют собой отдельные <span class="keyword">процессы</span>,
взаимодействующие путем передачи <span class="keyword">сообщений</span> через микроядро.</li><li>Наконец, это может быть необходимо просто для удобства работы
пользователя, желающего, например, редактировать и отлаживать
программу одновременно. В этой ситуации процессы редактора и
отладчика должны уметь взаимодействовать друг с другом.</li></ul><div  class="lecture_mark" id="mark_4"></div><p  id="id_9">Процессы не могут взаимодействовать, не общаясь, то есть не
обмениваясь информацией. "Общение" процессов обычно приводит к
изменению их поведения в зависимости от полученной информации. Если
деятельность процессов остается неизменной при любой принятой ими
информации, то это означает, что они на самом деле в "общении" не
нуждаются. <a name="keyword-context.1"></a>Процессы, которые влияют на поведение друг друга путем
обмена информацией, принято называть <b>кооперативными</b> или
<span class="keyword">взаимодействующими процессами</span>, в отличие от <span class="keyword">независимых процессов</span>,  не
оказывающих друг на друга никакого воздействия.</p><div  class="lecture_mark" id="mark_9"></div><p  id="id_10">Различные процессы в вычислительной системе изначально представляют
собой обособленные сущности. Работа одного процесса не должна
приводить к нарушению работы другого процесса. Для этого, в
частности, разделены их адресные пространства и системные ресурсы, и
для обеспечения корректного взаимодействия процессов требуются
специальные средства и действия операционной системы. Нельзя просто
поместить значение, вычисленное в одном процессе, в область памяти,
соответствующую переменной в другом процессе, не предприняв
каких-либо дополнительных усилий. Давайте рассмотрим основные аспекты
организации совместной работы процессов.</p><div  class="lecture_mark" id="mark_10"></div><h3 >Категории средств обмена информацией</h3><p  id="id_11">Процессы могут взаимодействовать друг с другом, только обмениваясь
информацией. По объему передаваемой информации и степени возможного
воздействия на поведение другого процесса все средства такого обмена
можно разделить на три категории.</p><div  class="lecture_mark" id="mark_11"></div><ul  id="id_12"><li><span class="keyword_def">Сигнальные</span>. <a name="keyword-context.2"></a>Передается минимальное количество информации – один
бит, "да" или "нет".<span class="keyword"></span> Используются, как правило, для извещения
процесса о наступлении какого-либо события. Степень воздействия на
поведение процесса, получившего информацию, минимальна. Все зависит
от того, знает ли он, что означает полученный сигнал, надо ли на него
реагировать и каким образом. Неправильная реакция на сигнал или его
игнорирование могут привести к трагическим последствиям. Вспомним
профессора Плейшнера из кинофильма "Семнадцать мгновений весны".
Сигнал тревоги – цветочный горшок на подоконнике – был ему передан,
но профессор проигнорировал его. И к чему это привело?</li><li><span class="keyword_def">Канальные</span>. <a name="keyword-context.3"></a>"Общение" процессов происходит через линии связи,
предоставленные операционной системой, и напоминает общение людей по
телефону, с помощью записок, писем или объявлений. Объем передаваемой
информации в единицу времени ограничен пропускной способностью линий
связи.<span class="keyword"></span> С увеличением количества информации возрастает и возможность
влияния на поведение другого процесса.</li><li><span class="keyword_def">Разделяемая память</span>. <a name="keyword-context.4"></a>Два или более процессов могут совместно
использовать некоторую область адресного пространства. Созданием
<span class="keyword">разделяемой памяти</span> занимается операционная система (если, конечно, ее
об этом попросят). "Общение" процессов напоминает совместное
проживание студентов в одной комнате общежития. Возможность обмена
информацией максимальна, как, впрочем, и влияние на поведение другого
процесса, но требует повышенной осторожности (если вы переложили на
другое место вещи вашего соседа по комнате, а часть из них еще и
выбросили). Использование <span class="keyword">разделяемой памяти</span> для передачи/получения
информации осуществляется с помощью средств обычных языков
программирования, в то время как <span class="keyword">сигнальным</span> и <span class="keyword">канальным средствам
коммуникации</span> для этого необходимы специальные системные вызовы.
<span class="keyword">Разделяемая память</span> представляет собой наиболее быстрый способ
взаимодействия процессов в одной вычислительной системе.</li></ul><div  class="lecture_mark" id="mark_12"></div><h3 >Логическая организация механизма передачи информации</h3><p  id="id_16">При рассмотрении любого из средств коммуникации нас будет
интересовать не их физическая реализация (общая шина данных,
прерывания, аппаратно <span class="keyword">разделяемая память</span> и т. д.), а логическая,
определяющая в конечном счете механизм их использования. Некоторые
важные аспекты логической реализации являются общими для всех
категорий средств связи, некоторые относятся к отдельным категориям.
Давайте кратко охарактеризуем основные вопросы, требующие разъяснения
при изучении того или иного способа обмена информацией.</p><div  class="lecture_mark" id="mark_16"></div><h4 >Как устанавливается связь?</h4><p  id="id_17">Могу ли я использовать средство связи непосредственно для обмена
информацией сразу после создания процесса или первоначально
необходимо предпринять определенные действия для инициализации
обмена? Например, для использования общей памяти различными
процессами потребуется специальное обращение к операционной системе,
которая выделит необходимую область адресного пространства. Но для
передачи сигнала от одного процесса к другому никакая инициализация
не нужна. В то же время передача информации по линиям связи может
потребовать первоначального резервирования такой линии для процессов,
желающих обменяться информацией.</p><div  class="lecture_mark" id="mark_17"></div><p  id="id_18">К этому же вопросу тесно примыкает вопрос о способе адресации при
использовании средства связи. Если я передаю некоторую информацию, я
должен указать, куда я ее передаю. Если я желаю получить некоторую
информацию, то мне нужно знать, откуда я могу ее получить.</p><div  class="lecture_mark" id="mark_18"></div><p  id="id_19">Различают два способа адресации: <span class="keyword">прямую</span> и <span class="keyword">непрямую</span>. <a name="keyword-context.5"></a>В случае <span class="keyword">прямой
адресации</span> <span class="keyword">взаимодействующие процессы</span> непосредственно общаются друг с
другом, при каждой операции обмена данными явно указывая имя или
номер процесса, которому информация предназначена или от которого она
должна быть получена. <a name="keyword-context.6"></a>Если и процесс, от которого данные исходят, и
процесс, принимающий данные, указывают имена своих партнеров по
взаимодействию, то такая схема адресации называется 
<span class="keyword_def">симметричной прямой адресацией</span>. <b>Ни один другой процесс не может вмешаться в
процедуру симметричного прямого общения двух процессов, перехватить
посланные или подменить ожидаемые данные.</b> <a name="keyword-context.7"></a>Если только один из
<span class="keyword">взаимодействующих процессов</span>, например передающий, указывает имя
своего партнера по <span class="keyword">кооперации</span>, а второй процесс в качестве возможного
партнера рассматривает любой процесс в системе, например ожидает
получения информации от произвольного источника, то такая схема
адресации называется <span class="keyword_def">асимметричной прямой адресацией</span>.</p><div  class="lecture_mark" id="mark_19"></div><p  id="id_20"><a name="keyword-context.8"></a>При <span class="keyword_def">непрямой адресации</span> данные помещаются передающим процессом в
некоторый промежуточный объект для хранения данных, имеющий свой
адрес, откуда они могут быть затем изъяты каким-либо другим
процессом. Примером такого объекта может служить обычная доска
объявлений или рекламная газета. При этом передающий процесс не
знает, как именно идентифицируется процесс, который получит
информацию, а принимающий процесс не имеет представления об
идентификаторе процесса, от которого он должен ее получить.</p><div  class="lecture_mark" id="mark_20"></div><p  id="id_21">При использовании <span class="keyword">прямой адресации</span> связь между процессами в
классической операционной системе устанавливается автоматически, без
дополнительных инициализирующих действий. Единственное, что нужно для
использования средства связи, – это знать, как идентифицируются
процессы, участвующие в обмене данными.</p><div  class="lecture_mark" id="mark_21"></div><p  id="id_22">При использовании <span class="keyword">непрямой адресации</span> инициализация средства связи
может и не требоваться. Информация, которой должен обладать процесс
для взаимодействия с другими процессами, – это некий идентификатор
промежуточного объекта для хранения данных, если он, конечно, не
является единственным и неповторимым в вычислительной системе для
всех процессов.</p><div  class="lecture_mark" id="mark_22"></div><h4 >Информационная валентность процессов и средств связи</h4><p  id="id_23">Следующий важный вопрос – это вопрос об информационной валентности
связи. Слово "валентность" здесь использовано по аналогии с химией.
Сколько процессов может быть одновременно ассоциировано с конкретным
средством связи? Сколько таких средств связи может быть задействовано
между двумя процессами?</p><div  class="lecture_mark" id="mark_23"></div><p  id="id_24">Понятно, что при <span class="keyword">прямой адресации</span> только одно фиксированное средство
связи может быть задействовано для обмена данными между двумя
процессами, и только эти два процесса могут быть ассоциированы с ним.
При <span class="keyword">непрямой адресации</span> может существовать более двух процессов,
использующих один и тот же объект для данных, и более одного объекта
может быть использовано двумя процессами.</p><div  class="lecture_mark" id="mark_24"></div><p  id="id_25">К этой же группе вопросов следует отнести и вопрос о направленности
связи. Является ли связь однонаправленной или двунаправленной? Под
однонаправленной связью мы будем понимать связь, при которой каждый
процесс, ассоциированный с ней, может использовать средство связи
либо только для приема информации, либо только для ее передачи. При
двунаправленной связи каждый процесс, участвующий в общении, может
использовать связь и для приема, и для передачи данных. <a name="keyword-context.9"></a><a name="keyword-context.10"></a><a name="keyword-context.11"></a>В
коммуникационных системах принято называть однонаправленную связь
<span class="keyword_def">симплексной</span><span class="keyword"></span>, двунаправленную связь с поочередной передачей информации
в разных направлениях – <span class="keyword_def">полудуплексной</span>, а двунаправленную связь с
возможностью одновременной передачи информации в разных направлениях
– <span class="keyword_def">дуплексной</span>. <span class="keyword">Прямая</span> и <span class="keyword">непрямая адресация</span> не имеет непосредственного
отношения к направленности связи.</p><div  class="lecture_mark" id="mark_25"></div><h4 >Особенности передачи информации с помощью линий связи</h4><p  id="id_26">Как уже говорилось выше, передача информации между процессами
посредством линий связи является достаточно безопасной по сравнению с
использованием <span class="keyword">разделяемой памяти</span> и более информативной по сравнению
с <span class="keyword">сигнальными средствами коммуникации</span>. Кроме того, <span class="keyword">разделяемая память</span>
не может быть использована для связи процессов, функционирующих на
различных вычислительных системах. Возможно, именно поэтому каналы
связи из средств коммуникации процессов получили наибольшее
распространение. Коснемся некоторых вопросов, связанных с логической
реализацией <span class="keyword">канальных средств коммуникации</span>.</p><div  class="lecture_mark" id="mark_26"></div><h5 >Буферизация</h5><p  id="id_27">Может ли линия связи сохранять информацию, переданную одним
процессом, до ее получения другим процессом или помещения в
промежуточный объект? Каков объем этой информации? Иными словами,
речь идет о том, обладает ли канал связи <b>буфером</b> и каков объем этого
буфера. Здесь можно выделить три принципиальных варианта.</p><div  class="lecture_mark" id="mark_27"></div><ol  id="id_28"><li>Буфер нулевой емкости или отсутствует. Никакая информация не может
сохраняться на линии связи. В этом случае процесс, посылающий
информацию, должен ожидать, пока процесс, принимающий информацию, не
соблаговолит ее получить, прежде чем заниматься своими дальнейшими
делами (в реальности этот случай никогда не реализуется).</li><li>Буфер ограниченной емкости. Размер буфера равен n, то есть линия
связи не может хранить до момента получения более чем n единиц
информации. Если в момент передачи данных в буфере хватает места, то
передающий процесс не должен ничего ожидать. Информация просто
копируется в буфер. Если же в момент передачи данных буфер заполнен
или места недостаточно, то необходимо задержать работу процесса
отправителя до появления в буфере свободного пространства.</li><li>Буфер неограниченной емкости. Теоретически это возможно, но
практически вряд ли реализуемо. Процесс, посылающий информацию,
никогда не ждет окончания ее передачи и приема другим процессом.</li></ol><div  class="lecture_mark" id="mark_28"></div><p  id="id_32">При использовании <span class="keyword">канального средства связи</span> с <span class="keyword">непрямой адресацией</span> под
емкостью буфера обычно понимается количество информации, которое
может быть помещено в промежуточный объект для хранения данных.</p><div  class="lecture_mark" id="mark_32"></div><h5 >Поток ввода/вывода и сообщения</h5><p  id="id_33">Существует две модели передачи данных по каналам связи – <span class="keyword">поток
ввода-вывода</span> и <span class="keyword">сообщения</span>. При передаче данных с помощью потоковой
модели операции передачи/приема информации вообще не интересуются
содержимым данных. Процесс, прочитавший 100 байт из линии связи, не
знает и не может знать, были ли они переданы одновременно, т. е.
одним куском или порциями по 20 байт, пришли они от одного процесса
или от разных. Данные представляют собой простой поток байтов, без
какой-либо их интерпретации со стороны системы. Примерами потоковых
каналов связи могут служить <span class="keyword">pipe</span> и <span class="keyword">FIFO</span>, описанные ниже.</p><div  class="lecture_mark" id="mark_33"></div><p  id="id_34">Одним из наиболее простых способов передачи информации между
процессами по линиям связи является передача данных через <span class="keyword">pipe</span>
(канал, трубу или, как его еще называют в литературе, конвейер).
Представим себе, что у нас есть некоторая труба в вычислительной
системе, в один из концов которой процессы могут "сливать"
информацию, а из другого конца принимать полученный <span class="keyword">поток</span>. Такой
способ реализует <span class="keyword">потоковую модель ввода/вывода</span>. Информацией о
расположении трубы в операционной системе обладает только процесс,
создавший ее. Этой информацией он может поделиться исключительно со
своими наследниками – процессами-детьми и их потомками. Поэтому
использовать <span class="keyword">pipe</span> для связи между собой могут только родственные
процессы, имеющие общего предка, создавшего данный канал связи.</p><div  class="lecture_mark" id="mark_34"></div><p  id="id_35">Если разрешить процессу, создавшему трубу, сообщать о ее местонахождении в
системе другим процессам, сделав вход и выход трубы каким-либо
образом видимыми для всех остальных, например, зарегистрировав ее в
операционной системе под определенным именем, мы получим объект,
который принято называть <span class="keyword_def">FIFO</span> или <span class="keyword_def">именованный pipe</span>. Именованный <span class="keyword">pipe</span>
может использоваться для организации связи между любыми процессами в
системе.</p><div  class="lecture_mark" id="mark_35"></div><p  id="id_36">В модели <span class="keyword">сообщений</span> процессы налагают на передаваемые данные некоторую
структуру. Весь поток информации они разделяют на отдельные
<span class="keyword">сообщения</span>, вводя между данными, по крайней мере, границы <span class="keyword">сообщений</span>.
Примером границ <span class="keyword">сообщений</span> являются точки между предложениями в
сплошном тексте или границы абзаца. Кроме того, к передаваемой
информации могут быть присоединены указания на то, кем конкретное
<span class="keyword">сообщение</span> было послано и для кого оно предназначено. Примером
указания отправителя могут служить подписи под эпиграфами в книге.
Все <span class="keyword">сообщения</span> могут иметь одинаковый фиксированный размер или могут
быть переменной длины. В вычислительных системах используются
разнообразные средства связи для передачи <span class="keyword">сообщений</span>: очереди
<span class="keyword">сообщений</span>, sockets (гнезда) и т. д. Часть из них мы рассмотрим
подробнее в дальнейшем, в частности очереди <span class="keyword">сообщений</span> будут
рассмотрены в лекции 6, а гнезда (иногда их еще называют по
транслитерации английского названия – сокеты) в лекции 14.</p><div  class="lecture_mark" id="mark_36"></div><p  id="id_37">И потоковые линии связи, и каналы <span class="keyword">сообщений</span> всегда имеют буфер
конечной длины. Когда мы будем говорить о емкости буфера для потоков
данных, мы будем измерять ее в байтах. Когда мы будем говорить о
емкости буфера для <span class="keyword">сообщений</span>, мы будем измерять ее в <span class="keyword">сообщениях</span>.</p><div  class="lecture_mark" id="mark_37"></div><h4 >Надежность средств связи</h4><p  id="id_38">Одним из существенных вопросов при рассмотрении всех категорий
средств связи является вопрос об их надежности. Мы все знаем, как
бывает тяжело расслышать собеседника по вечно трещащему телефону или
разобрать, о чем сообщается в телеграмме: "Прибду пыездом в
вонедельник 33 июня в 25.34. Пама".</p><div  class="lecture_mark" id="mark_38"></div><p  id="id_39">Мы будем называть способ коммуникации надежным, если при обмене
данными выполняются четыре условия.</p><div  class="lecture_mark" id="mark_39"></div><ol  id="id_40"><li>Не происходит потери информации.</li><li>Не происходит повреждения информации.</li><li>Не появляется лишней информации.</li><li>Не нарушается порядок данных в процессе обмена.</li></ol><div  class="lecture_mark" id="mark_40"></div><p  id="id_45">Очевидно, что передача данных через <span class="keyword">разделяемую память</span> является
надежным способом связи. То, что мы сохранили в <span class="keyword">разделяемой памяти</span>,
будет считано другими процессами в первозданном виде, если, конечно,
не произойдет сбоя в питании компьютера. Для других средств
коммуникации, как видно из приведенных выше примеров, это не всегда
верно.</p><div  class="lecture_mark" id="mark_45"></div><p  id="id_46">Каким образом в вычислительных системах пытаются бороться с
ненадежностью коммуникаций? Давайте рассмотрим возможные варианты на
примере обмена данными через линию связи с помощью <span class="keyword">сообщений</span>. Для
обнаружения повреждения информации будем снабжать каждое передаваемое
<span class="keyword">сообщение</span> некоторой контрольной суммой, вычисленной по посланной
информации. При приеме <span class="keyword">сообщения</span> контрольную сумму будем вычислять
заново и проверять ее соответствие пришедшему значению. Если данные
не повреждены (контрольные суммы совпадают), то подтвердим
правильность их получения. Если данные повреждены (контрольные суммы
не совпадают), то сделаем вид, что <span class="keyword">сообщение</span> к нам не поступило.
Вместо контрольной суммы можно использовать специальное кодирование
передаваемых данных с помощью кодов, исправляющих ошибки. Такое
кодирование позволяет при числе искажений информации, не превышающем
некоторого значения, восстановить первоначальные неискаженные данные.
Если по прошествии некоторого интервала времени подтверждение
правильности полученной информации не придет на передающий конец
линии связи, будем считать информацию утерянной и пошлем ее повторно.
Для того чтобы избежать двойного получения одной и той же информации,
на приемном конце линии связи должен осуществляться соответствующий контроль. Для
гарантии правильного порядка получения <span class="keyword">сообщений</span> будем их нумеровать.
При приеме <span class="keyword">сообщения</span> с номером, не соответствующим ожидаемому,
поступаем с ним как с утерянным и ждем <span class="keyword">сообщения</span> с правильным
номером.</p><div  class="lecture_mark" id="mark_46"></div><p  id="id_47">Подобные действия могут быть возложены:</p><div  class="lecture_mark" id="mark_47"></div><ul  id="id_48"><li>на операционную систему;</li><li>на процессы, обменивающиеся данными;</li><li>совместно на систему и процессы, разделяя их ответственность.
Операционная система может обнаруживать ошибки при передаче данных и
извещать об этом <span class="keyword">взаимодействующие процессы</span> для принятия ими решения
о дальнейшем поведении.</li></ul><div  class="lecture_mark" id="mark_48"></div><h4 >Как завершается связь?</h4><p  id="id_52">Наконец, важным вопросом при изучении средств обмена данными является
вопрос прекращения обмена. Здесь нужно выделить два аспекта:
требуются ли от процесса какие-либо специальные действия по
прекращению использования средства коммуникации и влияет ли такое
прекращение на поведение других процессов. Для способов связи,
которые не подразумевали никаких инициализирующих действий, обычно
ничего специального для окончания взаимодействия предпринимать не
надо. Если же установление связи требовало некоторой инициализации,
то, как правило, при ее завершении бывает необходимо выполнить ряд
операций, например сообщить операционной системе об освобождении
выделенного связного ресурса.</p><div  class="lecture_mark" id="mark_52"></div><p  id="id_53">Если кооперативные процессы прекращают взаимодействие согласованно,
то такое прекращение не влияет на их дальнейшее поведение. Иная
картина наблюдается при несогласованном окончании связи одним из
процессов. Если какой-либо из <span class="keyword">взаимодействующих процессов</span>, не
завершивших общение, находится в этот момент в состоянии ожидания
получения данных либо попадает в такое состояние позже, то
операционная система обязана предпринять некоторые действия для того,
чтобы исключить вечное блокирование этого процесса. Обычно это либо
прекращение работы ожидающего процесса, либо его извещение о том, что
связи больше нет (например, с помощью передачи заранее определенного
сигнала).</p><div  class="lecture_mark" id="mark_53"></div><h3 >Нити исполнения</h3><p  id="id_54">Рассмотренные выше аспекты логической реализации относятся к
средствам связи, ориентированным на организацию взаимодействия
различных процессов. Однако усилия, направленные на ускорение решения
задач в рамках классических операционных систем, привели к появлению
совершенно иных механизмов, к изменению самого понятия "процесс".</p><div  class="lecture_mark" id="mark_54"></div><p  id="id_55">В свое время внедрение идеи мультипрограммирования позволило повысить
пропускную способность компьютерных систем, т. е. уменьшить среднее
время ожидания результатов работы процессов. Но любой отдельно взятый
процесс в мультипрограммной системе никогда не может быть выполнен
быстрее, чем при работе в однопрограммном режиме на том же
вычислительном комплексе. Тем не менее, если алгоритм решения задачи
обладает определенным внутренним параллелизмом, мы могли бы ускорить
его работу, организовав взаимодействие нескольких процессов.
Рассмотрим следующий пример. Пусть у нас есть следующая программа на
псевдоязыке программирования:</p><div  class="lecture_mark" id="mark_55"></div><div  class="example"><pre>
Ввести массив a
Ввести массив b
Ввести массив c
a = a + b
c = a + c
Вывести массив c
</pre></div><p  id="id_57">При выполнении такой программы в рамках одного процесса этот процесс
четырежды будет блокироваться, ожидая окончания операций
ввода-вывода. Но наш алгоритм обладает внутренним параллелизмом.
Вычисление суммы массивов <span class="texample">a + b</span> можно было бы выполнять параллельно с
ожиданием окончания операции ввода массива <span class="texample">c</span>.</p><div  class="lecture_mark" id="mark_57"></div><div  class="example"><pre>
Ввести массив a 	
Ожидание окончания операции ввода	
Ввести массив b 	
Ожидание окончания операции ввода	
Ввести массив с	
Ожидание окончания операции ввода	a = a + b
c = a + c	
Вывести массив с	
Ожидание окончания операции вывода
</pre></div><p  id="id_61">Такое совмещение операций по времени можно было бы реализовать,
используя два <span class="keyword">взаимодействующих процесса</span>. Для простоты будем
полагать, что средством коммуникации между ними служит <span class="keyword">разделяемая
память</span>. Тогда наши процессы могут выглядеть следующим образом.</p><div  class="lecture_mark" id="mark_61"></div><div  class="example"><pre>
   Процесс 1                    Процесс 2

Ввести массив a                 Ожидание ввода
Ожидание окончания              массивов a и b
  операции ввода
Ввести массив b
Ожидание окончания
  операции ввода
Ввести массив с
Ожидание окончания              a = a + b
  операции ввода
c = a + c
Вывести массив с
Ожидание окончания
  операции вывода
</pre></div><p  id="id_63">Казалось бы, мы предложили конкретный способ ускорения решения
задачи. Однако в действительности дело обстоит не так просто. Второй
процесс должен быть создан, оба процесса должны сообщить операционной
системе, что им необходима память, которую они могли бы разделить с
другим процессом, и, наконец, нельзя забывать о переключении
контекста. Поэтому реальное поведение процессов будет выглядеть
примерно так.</p><div  class="lecture_mark" id="mark_63"></div><div  class="example"><pre>
Процесс 1                      Процесс 2

Создать процесс 2
           Переключение контекста
                               Выделение общей
                               памяти

                               Ожидание ввода 
                               a и b
           Переключение контекста
Выделение общей памяти
Ввести массив a
Ожидание окончания
  операции ввода
Ввести массив b
Ожидание окончания
  операции ввода
Ввести массив с
Ожидание окончания
  операции ввода
           Переключение контекста
                                a = a + b
           Переключение контекста
c = a + c
Вывести массив с
Ожидание окончания
  операции вывода
</pre></div><p  id="id_65">Очевидно, что мы можем не только не выиграть во времени при решении
задачи, но даже и проиграть, так как временные потери на создание
процесса, выделение общей памяти и переключение контекста могут
превысить выигрыш, полученный за счет совмещения операций.</p><div  class="lecture_mark" id="mark_65"></div><p  id="id_66">Для того чтобы реализовать нашу идею, введем новую абстракцию внутри
понятия "процесс" – <span class="keyword">нить исполнения</span> или просто <span class="keyword">нить</span> (в англоязычной
литературе используется термин <span class="keyword">thread</span>). <span class="keyword">Нити процесса</span> разделяют его
программный код, глобальные переменные и системные ресурсы, но каждая
<span class="keyword">нить</span> имеет собственный программный счетчик, свое содержимое регистров
и свой стек. Теперь процесс представляется как совокупность
взаимодействующих <span class="keyword">нитей</span> и выделенных ему ресурсов. Процесс,
содержащий всего одну <span class="keyword">нить исполнения</span>, идентичен процессу в том
смысле, который мы употребляли ранее. Для таких процессов мы в
дальнейшем будем использовать термин "традиционный процесс". Иногда
<span class="keyword">нити</span> называют облегченными процессами или мини-процессами, так как во
многих отношениях они подобны традиционным процессам. <span class="keyword">Нити</span>, как и
процессы, могут порождать нити-потомки, правда, только внутри своего
процесса, и переходить из одного состояния в другое. Состояния <span class="keyword">нитей</span>
аналогичны состояниям традиционных процессов. Из состояния <b>рождение</b>
процесс приходит содержащим всего одну <span class="keyword">нить исполнения</span>. Другие <span class="keyword">нити
процесса</span> будут являться потомками этой нити-прародительницы. Мы можем
считать, что процесс находится в состоянии <b>готовность</b>, если хотя бы
одна из его <span class="keyword">нитей</span> находится в состоянии <b>готовность</b> и ни одна из <span class="keyword">нитей</span>
не находится в состоянии <b>исполнение</b>. Мы можем считать, что процесс
находится в состоянии <b>исполнение</b>, если одна из его <span class="keyword">нитей</span> находится в
состоянии <b>исполнение</b>. Процесс будет находиться в состоянии <b>ожидание</b>,
если все его <span class="keyword">нити</span> находятся в состоянии <b>ожидание</b>. Наконец, процесс
находится в состоянии <b>закончил исполнение</b>, если все его <span class="keyword">нити</span>
находятся в состоянии <b>закончила исполнение</b>. Пока одна <span class="keyword">нить процесса</span>
заблокирована, другая <span class="keyword">нить</span> того же процесса может выполняться. <span class="keyword">Нити</span>
разделяют процессор так же, как это делали традиционные процессы, в
соответствии с рассмотренными алгоритмами планирования.</p><div  class="lecture_mark" id="mark_66"></div><p  id="id_67">Поскольку <span class="keyword">нити</span> одного процесса разделяют существенно больше ресурсов,
чем различные процессы, то операции создания новой <span class="keyword">нити</span> и
переключения контекста между <span class="keyword">нитями</span> одного процесса занимают
значительно меньше времени, чем аналогичные операции для процессов в
целом. Предложенная нами схема совмещения работы в терминах <span class="keyword">нитей</span>
одного процесса получает право на существование.</p><div  class="lecture_mark" id="mark_67"></div><div  class="example"><pre>
Нить 1 	                  Нить 2 

Создать нить 2	 	 			
        Переключение контекста нитей 	
                          Ожидание ввода a и b
        Переключение контекста нитей 
Ввести массив a 	 	 
Ожидание окончания 
  операции ввода
Ввести массив b
Ожидание окончания 
  операции ввода
Ввести массив с
Ожидание окончания 
  операции ввода
        Переключение контекста нитей
                          a = a + b
        Переключение контекста нитей 
c = a + c	 	 
Вывести массив с	
Ожидание окончания 
  операции вывода	
</pre></div><p  id="id_69">Различают операционные системы, поддерживающие <span class="keyword">нити</span> на уровне ядра и
на уровне библиотек. Все сказанное выше справедливо для операционных
систем, поддерживающих <span class="keyword">нити</span> на уровне ядра. В них планирование
использования процессора происходит в терминах <span class="keyword">нитей</span>, а управление
памятью и другими системными ресурсами остается в терминах процессов.
В операционных системах, поддерживающих <span class="keyword">нити</span> на уровне библиотек
пользователей, и планирование процессора, и управление системными
ресурсами осуществляются в терминах процессов. Распределение
использования процессора по <span class="keyword">нитям</span> в рамках выделенного процессу
временного интервала осуществляется средствами библиотеки. В подобных
системах блокирование одной <span class="keyword">нити</span> приводит к блокированию всего
процесса, ибо ядро операционной системы не имеет представления о
существовании <span class="keyword">нитей</span>. По сути дела, в таких вычислительных системах
просто имитируется наличие <span class="keyword">нитей исполнения</span>.</p><div  class="lecture_mark" id="mark_69"></div><p  id="id_70">Далее в этой части книги для простоты изложения мы будем использовать
термин "процесс", хотя все сказанное будет относиться и к <span class="keyword">нитям
исполнения</span>.</p><div  class="lecture_mark" id="mark_70"></div><h3 >Заключение</h3><p  id="id_71">Для достижения поставленной цели различные процессы могут исполняться
псевдопараллельно на одной вычислительной системе или параллельно на
разных вычислительных системах, взаимодействуя между собой. Причинами
для совместной деятельности процессов обычно являются: необходимость
ускорения решения задачи, совместное использование обновляемых
данных, удобство работы или модульный принцип построения программных
комплексов. Процессы, которые влияют на поведение друг друга путем
обмена информацией, называют кооперативными или <span class="keyword">взаимодействующими
процессами</span>, в отличие от <span class="keyword">независимых процессов</span>, не оказывающих друг
на друга никакого воздействия и ничего не знающих о взаимном
существовании в вычислительной системе.</p><div  class="lecture_mark" id="mark_71"></div><p  id="id_72">Для обеспечения корректного обмена информацией операционная система
должна предоставить процессам специальные средства связи. По объему
передаваемой информации и степени возможного воздействия на поведение
процесса, получившего информацию, их можно разделить на три
категории: <span class="keyword">сигнальные</span>, <span class="keyword">канальные</span> и <span class="keyword">разделяемую память</span>. Через
<span class="keyword">канальные средства коммуникации</span> информация может передаваться в виде
потока данных или в виде <span class="keyword">сообщений</span> и накапливаться в буфере
определенного размера. Для инициализации "общения" процессов и его
прекращения могут потребоваться специальные действия со стороны
операционной системы. Процессы, связываясь друг с другом, могут
использовать <span class="keyword">непрямую</span>, <span class="keyword">прямую симметричную</span> 
и <span class="keyword">прямую асимметричную
схемы адресации</span>. Существуют одно- и двунаправленные средства передачи
информации. Средства коммуникации обеспечивают надежную связь, если
при общении процессов не происходит потери и повреждения информации,
не появляется лишней информации, не нарушается порядок данных.</p><div  class="lecture_mark" id="mark_72"></div><p  id="id_73">Усилия, направленные на ускорение решения задач в рамках классических
операционных систем, привели к появлению новой абстракции внутри
понятия "процесс" – <span class="keyword">нити исполнения</span> или просто <span class="keyword">нити</span>. <span class="keyword">Нити</span> процесса
разделяют его программный код, глобальные переменные и системные
ресурсы, но каждая <span class="keyword">нить</span> имеет собственный программный счетчик, свое
содержимое регистров и свой стек. Теперь процесс представляется как
совокупность взаимодействующих <span class="keyword">нитей</span> и выделенных ему ресурсов. <span class="keyword">Нити</span>
могут порождать новые <span class="keyword">нити</span> внутри своего процесса, они имеют
состояния, аналогичные состояниям процесса, и могут переводиться
операционной системой из одного состояния в другое. В системах,
поддерживающих <span class="keyword">нити</span> на уровне ядра, планирование использования
процессора осуществляется в терминах <span class="keyword">нитей исполнения</span>, а управление
остальными системными ресурсами – в терминах процессов. Накладные
расходы на создание новой <span class="keyword">нити</span> и на переключение контекста между
<span class="keyword">нитями</span> одного процесса существенно меньше, чем на те же самые
действия для процессов, что позволяет на однопроцессорной
вычислительной системе ускорять решение задач с помощью организации
работы нескольких взаимодействующих <span class="keyword">нитей</span>. </p><div  class="lecture_mark" id="mark_73"></div>


	</td>
	</tr>
	<tr><td height="8"><img src="4. Кооперация процессов и основные аспекты ее логической организации_files/empty000.gif" width="1" height="8"></td></tr>
	</table>
	<!-- /content -->

</td>
<td><img src="4. Кооперация процессов и основные аспекты ее логической организации_files/empty000.gif" width="8" height="1"></td>
</tr>
</table>
<!-- /bottom -->
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td class="orang" height="1"><img src="4. Кооперация процессов и основные аспекты ее логической организации_files/empty000.gif" width="1" height="1"></td></tr>
<td class="ltxt" align=center>&copy; INTUIT.ru, 2003-2008. Все права защищены.</td>
</tr>
</table>
<!-- /bottom -->

<script src="4. Кооперация процессов и основные аспекты ее логической организации_files/urchin00.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-3475067-1";
urchinTracker();
</script></body>
</html>


<!-- This document saved from http://www.intuit.ru/department/os/osintro/4/osintro_4.html -->
