<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>INTUIT.ru::Интернет-Университет Информационных Технологий</title>
<link href="11. Файлы с точки зрения пользователя_files/printabl.css" type="text/css" rel="stylesheet">
</head>
<body leftmargin="6" topmargin="6" marginheight="6" marginwidth="6">


<div align="left">
<span style="color: #000000; font-weight: bold;">
&nbsp;&nbsp;
<span style="font-size:12pt;">Интернет-Университет Информационных Технологий</span>
</span>
</div>

&nbsp;&nbsp;
<span align="rright" style="color: #330066; text-decoration:underline;">http://www.INTUIT.ru</span>


<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td height="8" colspan=3><img src="11. Файлы с точки зрения пользователя_files/empty000.gif" width="1" height="8"></td></tr>
<tr><td class="orang" height="1" colspan=3><img src="11. Файлы с точки зрения пользователя_files/empty000.gif" width="1" height="1"></td></tr>
<tr><td height="8" colspan=3><img src="11. Файлы с точки зрения пользователя_files/empty000.gif" width="1" height="8"></td></tr>
<tr valign="top">
<td><img src="11. Файлы с точки зрения пользователя_files/empty000.gif" width="8" height="1"></td>
<td>
	<!-- content -->
	<table border="0" cellpadding="0" cellspacing="0" width="100%">
	<tr><td class="head">Основы операционных систем</td></tr>
<tr><td height="4"><img src="11. Файлы с точки зрения пользователя_files/empty000.gif" width="1" height="4"></td></tr>
	<tr><td class="orang" height="1"><img src="11. Файлы с точки зрения пользователя_files/empty000.gif" width="1" height="1"></td></tr>
	<tr><td height="8"><img src="11. Файлы с точки зрения пользователя_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td><span class="headsub">


11. Лекция:

 Файлы с точки зрения пользователя: версия для печати и PDA</span>

<br>
<span class="rtxt">В настоящей лекции вводится понятие и рассматриваются основные функции и интерфейс файловой системы.
</span>

</td></tr>

	<tr><td height="8"><img src="11. Файлы с точки зрения пользователя_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td class="orang" height="1"><img src="11. Файлы с точки зрения пользователя_files/empty000.gif" width="1" height="1"></td></tr>
	<tr><td height="8"><img src="11. Файлы с точки зрения пользователя_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td>


<h3 >Введение</h3><p  id="id_1">История систем управления данными во <span class="keyword">внешней памяти</span> начинается еще с магнитных лент, но современный облик они приобрели с появлением магнитных дисков. До этого каждая прикладная программа сама решала проблемы именования данных и их структуризации во <span class="keyword">внешней памяти</span>. Это затрудняло поддержание на внешнем носителе нескольких архивов долговременно хранящейся информации. Историческим шагом стал переход к использованию централизованных систем управления <span class="keyword">файлами</span>. Система управления <span class="keyword">файлами</span> берет на себя распределение <span class="keyword">внешней памяти</span>, отображение имен <span class="keyword">файлов</span> в адреса <span class="keyword">внешней памяти</span> и обеспечение доступа к данным.</p><div  class="lecture_mark" id="mark_1"></div><p  id="id_2"><b>Файловая система</b> - это часть операционной системы, назначение которой состоит в том, чтобы организовать эффективную работу с данными, хранящимися во <span class="keyword">внешней памяти</span>, и обеспечить пользователю удобный интерфейс при работе с такими данными. Организовать хранение информации на магнитном диске непросто. Это требует, например, хорошего знания устройства контроллера диска, особенностей работы с его регистрами. Непосредственное взаимодействие с диском - прерогатива компонента системы ввода-вывода ОС, называемого драйвером диска. Для того чтобы избавить пользователя компьютера от сложностей взаимодействия с аппаратурой, была придумана ясная абстрактная модель файловой системы. Операции записи или чтения <span class="keyword">файла</span> концептуально проще, чем низкоуровневые операции работы с устройствами.</p><div  class="lecture_mark" id="mark_2"></div><p  id="id_3"><a name="keyword-context.1"></a>Основная идея использования <span class="keyword">внешней памяти</span> состоит в следующем. ОС делит память на блоки фиксированного размера, например, 4096 байт. <span class="keyword">Файл</span>, обычно представляющий собой неструктурированную последовательность однобайтовых записей, хранится в виде последовательности блоков (не обязательно смежных); каждый блок хранит целое число записей. В некоторых ОС (MS-DOS) адреса блоков, содержащих данные <span class="keyword">файла</span>, могут быть организованы в связный список и вынесены в отдельную таблицу в памяти. В других ОС (Unix) адреса блоков данных <span class="keyword">файла</span> хранятся в отдельном блоке <span class="keyword">внешней памяти</span> (так называемом индексе или индексном узле). Этот прием, называемый <span class="keyword_def">индексацией</span>, является наиболее распространенным для приложений, требующих произвольного доступа к записям <span class="keyword">файлов</span>. Индекс 
<span class="keyword">файла</span> состоит из списка элементов, каждый из которых содержит номер блока в <span class="keyword">файле</span> и сведения о местоположении данного блока. Считывание очередного байта осуществляется с так называемой <b>текущей</b> позиции, которая характеризуется смещением от начала <span class="keyword">файла</span>. Зная размер блока, легко вычислить номер блока, содержащего текущую позицию. Адрес же нужного блока диска можно затем извлечь из индекса <span class="keyword">файла</span>. Базовой операцией, выполняемой по отношению к <span class="keyword">файлу</span>, является чтение блока с диска и перенос его в буфер, находящийся в основной памяти.</p><div  class="lecture_mark" id="mark_3"></div><p  id="id_4">Файловая система позволяет при помощи системы справочников (<span class="keyword">каталогов</span>, <span class="keyword">директорий</span>) связать уникальное имя <span class="keyword">файла</span> с блоками вторичной памяти, содержащими данные <span class="keyword">файла</span>. Иерархическая структура <span class="keyword">каталогов</span>, используемая для управления <span class="keyword">файлами</span>, может служить другим примером индексной структуры. В этом случае <span class="keyword">каталоги</span> или папки играют роль индексов, каждый из которых содержит ссылки на свои подкаталоги. С этой точки зрения вся файловая система компьютера представляет собой большой индексированный <span class="keyword">файл</span>. Помимо собственно <span class="keyword">файлов</span> и структур данных, используемых для управления <span class="keyword">файлами</span> (<span class="keyword">каталоги</span>, дескрипторы <span class="keyword">файлов</span>, различные 
	таблицы распределения <span class="keyword">внешней памяти</span>), понятие "файловая система" включает программные средства, реализующие различные <span class="keyword">операции над файлами</span>.</p><div  class="lecture_mark" id="mark_4"></div><p  id="id_5">Перечислим <b>основные функции</b> файловой системы.</p><div  class="lecture_mark" id="mark_5"></div><ol  id="id_6"><li>Идентификация <span class="keyword">файлов</span>. Связывание имени <span class="keyword">файла</span> с выделенным ему пространством <span class="keyword">внешней памяти</span>. </li><li>Распределение <span class="keyword">внешней памяти</span> между <span class="keyword">файлами</span>. Для работы с конкретным <span class="keyword">файлом</span> пользователю не требуется иметь информацию о местоположении этого <span class="keyword">файла</span> на внешнем носителе информации. Например, для того чтобы загрузить документ в редактор с жесткого диска, нам не нужно знать, на какой стороне какого магнитного диска, на каком цилиндре и в каком секторе находится данный документ.</li><li>Обеспечение надежности и отказоустойчивости. Стоимость информации может во много раз превышать стоимость компьютера.</li><li>Обеспечение защиты от несанкционированного доступа.</li><li>Обеспечение совместного <span class="keyword">доступа к файлам</span>, так чтобы пользователю не приходилось прилагать специальных усилий по обеспечению синхронизации доступа.</li><li>Обеспечение высокой производительности.</li></ol><div  class="lecture_mark" id="mark_6"></div><p  id="id_13"><a name="keyword-context.2"></a>Иногда говорят, что <span class="keyword_def">файл</span> - это поименованный набор связанной информации, записанной во вторичную память. Для большинства пользователей файловая система - наиболее видимая часть ОС. Она предоставляет механизм для онлайнового хранения и доступа как к данным, так и к программам для всех пользователей системы. <a name="keyword-context.3"></a>С точки зрения пользователя, <span class="keyword_def">файл</span> - единица <span class="keyword">внешней памяти</span>, то есть данные, записанные на диск, должны быть в составе какого-нибудь <span class="keyword">файла</span>. </p><div  class="lecture_mark" id="mark_13"></div><p  id="id_14">Важный аспект организации файловой системы - учет стоимости операций взаимодействия с вторичной памятью. Процесс считывания блока диска состоит из позиционирования считывающей головки над дорожкой, содержащей требуемый блок, ожидания, пока требуемый блок сделает оборот и окажется под головкой, и собственно считывания блока. Для этого требуется значительное время (десятки миллисекунд). В современных компьютерах обращение к диску осуществляется примерно в 100 000  раз медленнее, чем обращение к оперативной памяти. Таким образом, критерием вычислительной сложности алгоритмов, работающих с <span class="keyword">внешней памятью</span>, является количество обращений к диску.</p><div  class="lecture_mark" id="mark_14"></div><p  id="id_15">В данной лекции рассматриваются вопросы структуры, именования, <span class="keyword">защиты файлов</span>; операции, которые разрешается производить над <span class="keyword">файлами</span>; организация файлового архива (полного дерева справочников). Проблемы выделения дискового пространства, обеспечения производительной работы файловой системы и ряд других вопросов, интересующих разработчиков системы, вы найдете в следующей лекции.</p><div  class="lecture_mark" id="mark_15"></div><h3 >Общие сведения о файлах</h3><h4 >Имена файлов </h4><p  id="id_16"><span class="keyword">Файлы</span> представляют собой абстрактные объекты. Их задача - хранить информацию, скрывая от пользователя детали работы с устройствами. Когда процесс создает <span class="keyword">файл</span>, он дает ему имя. После завершения процесса <span class="keyword">файл</span> продолжает существовать и через свое имя может быть доступен другим процессам.</p><div  class="lecture_mark" id="mark_16"></div><p  id="id_17">Правила именования <span class="keyword">файлов</span> зависят от ОС. Многие ОС поддерживают имена из <b>двух частей</b> (имя+расширение), например <span class="texample">progr.c</span> (<span class="keyword">файл</span>, содержащий текст программы на языке Си) или <span class="texample">autoexec.bat</span> (<span class="keyword">файл</span>, содержащий команды интерпретатора командного языка). Тип расширения <span class="keyword">файла</span> позволяет ОС организовать работу с ним различных прикладных программ в соответствии с заранее оговоренными соглашениями. Обычно ОС накладывают некоторые ограничения, как на используемые в имени символы, так и на длину имени <span class="keyword">файла</span>. В соответствии со стандартом POSIX, популярные ОС оперируют удобными для пользователя длинными именами (до 255 символов).</p><div  class="lecture_mark" id="mark_17"></div><h4 >Типы файлов</h4><p  id="id_20">Важный аспект организации файловой системы и ОС - следует ли поддерживать и распознавать <span class="keyword">типы файлов</span>. Если да, то это может помочь правильному функционированию ОС, например не допустить вывода на принтер бинарного <span class="keyword">файла</span>. </p><div  class="lecture_mark" id="mark_20"></div><p  id="id_21">Основные <span class="keyword">типы файлов</span>: регулярные (обычные) <span class="keyword">файлы</span> и <span class="keyword">директории</span> (справочники, <span class="keyword">каталоги</span>). Обычные <span class="keyword">файлы</span> содержат пользовательскую информацию. <a name="keyword-context.4"></a><span class="keyword_def">Директории</span> - системные <span class="keyword">файлы</span>, поддерживающие структуру файловой системы. В <span class="keyword">каталоге</span> содержится перечень входящих в него <span class="keyword">файлов</span> и устанавливается соответствие между <span class="keyword">файлами</span> и их характеристиками (<span class="keyword">атрибутами</span>). Мы будем рассматривать <span class="keyword">директории</span> ниже.</p><div  class="lecture_mark" id="mark_21"></div><p  id="id_22">Напомним, что хотя внутри подсистемы управления <span class="keyword">файлами</span> обычный <span class="keyword">файл</span> представляется в виде набора блоков <span class="keyword">внешней памяти</span>, для пользователей обеспечивается представление <span class="keyword">файла</span> в виде линейной последовательности байтов. Такое представление позволяет использовать абстракцию <span class="keyword">файла</span> при работе с внешними устройствами, при организации межпроцессных взаимодействий и т. д. Так, например, клавиатура обычно рассматривается как текстовый <span class="keyword">файл</span>, из которого компьютер получает данные в символьном формате. Поэтому иногда к <span class="keyword">файлам</span> приписывают другие объекты ОС, например специальные символьные <span class="keyword">файлы</span> и специальные блочные <span class="keyword">файлы</span>, именованные каналы и сокеты, имеющие файловый интерфейс. Эти объекты рассматриваются в других разделах данного курса.</p><div  class="lecture_mark" id="mark_22"></div><p  id="id_23">Далее речь пойдет главным образом об <b>обычных файлах</b>. </p><div  class="lecture_mark" id="mark_23"></div><p  id="id_24">Обычные (или регулярные) <span class="keyword">файлы</span> реально представляют собой набор блоков (возможно, пустой) на устройстве <span class="keyword">внешней памяти</span>, на котором поддерживается файловая система. Такие <span class="keyword">файлы</span> могут содержать как текстовую информацию (обычно в формате ASCII), так и произвольную двоичную (бинарную) информацию.</p><div  class="lecture_mark" id="mark_24"></div><p  id="id_25">Текстовые <span class="keyword">файлы</span> содержат символьные строки, которые можно распечатать, увидеть на экране или редактировать обычным текстовым редактором. </p><div  class="lecture_mark" id="mark_25"></div><p  id="id_26">Другой <span class="keyword">тип файлов</span> - нетекстовые, или бинарные, <span class="keyword">файлы</span>. Обычно они имеют некоторую внутреннюю структуру. Например, исполняемый <span class="keyword">файл</span> в ОС Unix имеет пять секций: заголовок, текст, данные, биты реаллокации и символьную таблицу. ОС выполняет <span class="keyword">файл</span>, только если он имеет нужный формат. Другим примером бинарного <span class="keyword">файла</span> может быть архивный <span class="keyword">файл</span>. Типизация <span class="keyword">файлов</span> не слишком строгая.</p><div  class="lecture_mark" id="mark_26"></div><p  id="id_27">Обычно прикладные программы, работающие с <span class="keyword">файлами</span>, распознают <span class="keyword">тип файла</span> по его имени в соответствии с общепринятыми соглашениями. Например, <span class="keyword">файлы</span> с расширениями <span class="texample">.c</span>, <span class="texample">.pas</span>, <span class="texample">.txt</span> - ASCII-файлы, <span class="keyword">файлы</span> с расширениями <span class="texample">.exe</span> - выполнимые, <span class="keyword">файлы</span> с расширениями <span class="texample">.obj</span>, <span class="texample">.zip</span> - бинарные и т. д. </p><div  class="lecture_mark" id="mark_27"></div><h4 >Атрибуты файлов</h4><p  id="id_34"><a name="keyword-context.5"></a>Кроме имени ОС часто связывают с каждым <span class="keyword">файлом</span> и другую информацию, например дату модификации, размер и т. д. Эти другие характеристики <span class="keyword">файлов</span> называются <span class="keyword_def">атрибутами</span>. Список <span class="keyword">атрибутов</span> в разных ОС может варьироваться. Обычно он содержит следующие элементы: основную информацию (имя, <span class="keyword">тип файла</span>), адресную информацию (устройство, начальный адрес, размер), информацию об управлении доступом (владелец, допустимые операции) и информацию об использовании (даты создания, последнего чтения, модификации и др.).</p><div  class="lecture_mark" id="mark_34"></div><p  id="id_35">Список <span class="keyword">атрибутов</span> обычно хранится в структуре <span class="keyword">директорий</span> (см. следующую лекцию) или других структурах, обеспечивающих доступ к данным <span class="keyword">файла</span>.</p><div  class="lecture_mark" id="mark_35"></div><h3 >Организация файлов и доступ к ним</h3><p  id="id_36">Программист воспринимает <span class="keyword">файл</span> в виде набора однородных записей. Запись - это наименьший элемент данных, который может быть обработан как единое целое прикладной программой при обмене с внешним устройством. Причем в большинстве ОС размер записи равен одному байту. В то время как приложения оперируют записями, физический обмен с устройством осуществляется большими единицами (обычно блоками). Поэтому записи объединяются в блоки для вывода и разблокируются - для ввода. Вопросы распределения блоков <span class="keyword">внешней памяти</span> между <span class="keyword">файлами</span> рассматриваются в следующей лекции.</p><div  class="lecture_mark" id="mark_36"></div><p  id="id_37">ОС поддерживают несколько вариантов структуризации <span class="keyword">файлов</span>.</p><div  class="lecture_mark" id="mark_37"></div><h4 >Последовательный файл</h4><p  id="id_38"><a name="keyword-context.6"></a>Простейший вариант - так называемый <span class="keyword_def">последовательный файл</span>. То есть <span class="keyword">файл</span> является последовательностью записей. Поскольку записи, как правило, однобайтовые, <span class="keyword">файл</span> представляет собой <b>неструктурированную последовательность байтов</b>. </p><div  class="lecture_mark" id="mark_38"></div><p  id="id_39">Обработка подобных <span class="keyword">файлов</span> предполагает последовательное чтение записей от начала <span class="keyword">файла</span>, причем конкретная запись определяется ее положением в <span class="keyword">файле</span>. Такой способ доступа называется последовательным (модель ленты). Если в качестве носителя <span class="keyword">файла</span> используется магнитная лента, то так и делается. Текущая позиция считывания может быть возвращена к началу <span class="keyword">файла</span> (rewind).</p><div  class="lecture_mark" id="mark_39"></div><h4 >Файл прямого доступа</h4><p  id="id_40">В реальной практике <span class="keyword">файлы</span> хранятся на устройствах прямого (random) доступа, например на дисках, поэтому содержимое <span class="keyword">файла</span> может быть разбросано по разным блокам диска, которые можно считывать в произвольном порядке. Причем номер блока однозначно определяется позицией внутри <span class="keyword">файла</span>.</p><div  class="lecture_mark" id="mark_40"></div><p  id="id_41">Здесь имеется в виду относительный номер, специфицирующий данный блок среди блоков диска, принадлежащих <span class="keyword">файлу</span>. О связи относительного номера блока с абсолютным его номером на диске рассказывается в следующей лекции.</p><div  class="lecture_mark" id="mark_41"></div><p  id="id_42">Естественно, что в этом случае для доступа к середине <span class="keyword">файла</span> просмотр всего <span class="keyword">файла</span> с самого начала не обязателен. Для специфицирования места, с которого надо начинать чтение, используются два способа: с начала или с текущей позиции, которую дает операция seek. <a name="keyword-context.7"></a><span class="keyword">Файл</span>, байты которого могут быть считаны в произвольном порядке, называется <span class="keyword_def">файлом прямого доступа</span>.</p><div  class="lecture_mark" id="mark_42"></div><p  id="id_43">Таким образом, <span class="keyword">файл</span>, состоящий из однобайтовых записей на устройстве прямого доступа, - наиболее распространенный способ организации <span class="keyword">файла</span>. Базовыми операциями для такого рода <span class="keyword">файлов</span> являются считывание или запись символа в текущую позицию. В большинстве языков высокого уровня предусмотрены операторы посимвольной пересылки данных в <span class="keyword">файл</span> или из него.</p><div  class="lecture_mark" id="mark_43"></div><p  id="id_44">Подобную логическую структуру имеют <span class="keyword">файлы</span> во многих файловых системах, например в файловых системах ОС Unix и MS-DOS. ОС не осуществляет никакой интерпретации содержимого <span class="keyword">файла</span>. Эта схема обеспечивает максимальную гибкость и универсальность. С помощью базовых системных вызовов (или функций библиотеки ввода/вывода) пользователи могут как угодно структурировать <span class="keyword">файлы</span>. В частности, многие СУБД хранят свои базы данных в обычных <span class="keyword">файлах</span>. </p><div  class="lecture_mark" id="mark_44"></div><h4 >Другие формы организации файлов</h4><p  id="id_45">Известны как другие формы организации <span class="keyword">файла</span>, так и другие способы <span class="keyword">доступа</span> к ним, которые использовались в ранних ОС, а также применяются сегодня в больших мэйнфреймах (mainframe), ориентированных на коммерческую обработку данных.</p><div  class="lecture_mark" id="mark_45"></div><p  id="id_46">Первый шаг в структурировании - хранение <span class="keyword">файла</span> в виде <b>последовательности записей фиксированной длины</b>, каждая из которых имеет внутреннюю структуру. Операция чтения производится над записью, а операция записи переписывает или добавляет запись целиком. Ранее использовались записи по 80 байт (это соответствовало числу позиций в перфокарте) или по 132 символа (ширина принтера). В ОС CP/M <span class="keyword">файлы</span> были последовательностями 128-символьных записей. С введением CRT-терминалов данная идея утратила популярность.</p><div  class="lecture_mark" id="mark_46"></div><p  id="id_47">Другой способ представления <span class="keyword">файлов</span> - <b>последовательность записей переменной длины</b>, каждая из которых содержит ключевое поле в фиксированной позиции внутри записи (см. <a href="">рис. 11.1</a>). Базисная операция в данном случае - считать запись с каким-либо значением ключа. Записи могут располагаться в <span class="keyword">файле</span> последовательно (например, отсортированные по значению ключевого поля) или в более сложном порядке. Метод доступа по значению ключевого поля к записям <span class="keyword">последовательного файла</span> называется <b>индексно-последовательным</b>.</p><div  class="lecture_mark" id="mark_47"></div><p  align="left" id="id_48"><a name="image.11.1"></a><div><img src="11. Файлы с точки зрения пользователя_files/11-10000.gif" alt="Файл как последовательность записей переменной длины" width="420" height="94"></div><br><b>Рис. 11.1.</b> 
        Файл как последовательность записей переменной длины</p><div  class="lecture_mark" id="mark_48"></div><p  id="id_49">В некоторых системах ускорение <span class="keyword">доступа к файлу</span> обеспечивается конструированием <b>индекса </b> <span class="keyword">файла</span>. Индекс обычно хранится на том же устройстве, что и сам <span class="keyword">файл</span>, и состоит из списка элементов, каждый из которых содержит идентификатор записи, за которым следует указание о местоположении данной записи. Для поиска записи вначале происходит обращение к индексу, где находится указатель на нужную запись. Такие <span class="keyword">файлы</span> называются <b>индексированными</b>, а метод <span class="keyword">доступа</span> к ним - <b>доступ с использованием индекса</b>.</p><div  class="lecture_mark" id="mark_49"></div><p  id="id_50">Предположим, у нас имеется большой несортированный <span class="keyword">файл</span>, содержащий разнообразные сведения о студентах, состоящие из записей с несколькими полями, и возникает задача организации быстрого поиска по одному из полей, например по фамилии студента. <a href="">Рис. 11.2</a> иллюстрирует решение данной проблемы - организацию метода <span class="keyword">доступа к файлу</span> с использованием индекса.</p><div  class="lecture_mark" id="mark_50"></div><p  align="left" id="id_51"><a name="image.11.2"></a><div><img src="11. Файлы с точки зрения пользователя_files/11-20000.gif" alt="Пример организации индекса для последовательного файла" width="422" height="208"></div><br><b>Рис. 11.2.</b> 
        Пример организации индекса для последовательного файла</p><div  class="lecture_mark" id="mark_51"></div><p  id="id_52">Следует отметить, что почти всегда главным фактором увеличения скорости доступа является <b>избыточность</b> данных.</p><div  class="lecture_mark" id="mark_52"></div><p  id="id_53">Способ выделения дискового пространства при помощи индексных узлов, применяемый в ряде ОС (Unix и некоторых других, см. следующую лекцию), может служить другим примером организации индекса.</p><div  class="lecture_mark" id="mark_53"></div><p  id="id_54">В этом случае ОС использует древовидную организацию блоков, при которой блоки, составляющие <span class="keyword">файл</span>, являются листьями дерева, а каждый внутренний узел содержит указатели на множество блоков <span class="keyword">файла</span>. Для больших <span class="keyword">файлов</span> индекс может быть слишком велик. В этом случае создают индекс для индексного <span class="keyword">файла</span> (блоки промежуточного уровня или блоки косвенной адресации).</p><div  class="lecture_mark" id="mark_54"></div><h3 >Операции над файлами</h3><p  id="id_55">Операционная система должна предоставить в распоряжение пользователя набор операций для работы с <span class="keyword">файлами</span>, реализованных через системные вызовы. Чаще всего при работе с <span class="keyword">файлом</span> пользователь выполняет не одну, а несколько операций. Во-первых, нужно найти данные <span class="keyword">файла</span> и его <span class="keyword">атрибуты</span> по символьному имени, во-вторых, считать необходимые <span class="keyword">атрибуты файла</span> в отведенную область оперативной памяти и проанализировать права пользователя на выполнение требуемой операции. Затем следует выполнить операцию, после чего освободить занимаемую данными <span class="keyword">файла</span> область памяти. Рассмотрим в качестве примера основные файловые операции ОС Unix [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#30">Таненбаум, 2002</a>].</p><div  class="lecture_mark" id="mark_55"></div><ul  id="id_56"><li>Создание <span class="keyword">файла</span>, не содержащего данных. Смысл данного вызова - объявить, что <span class="keyword">файл</span> существует, и присвоить ему ряд <span class="keyword">атрибутов</span>. При этом выделяется место для <span class="keyword">файла</span> на диске и вносится запись в <span class="keyword">каталог</span>.</li><li>Удаление <span class="keyword">файла</span> и освобождение занимаемого им дискового пространства.</li><li>Открытие <span class="keyword">файла</span>. Перед использованием <span class="keyword">файла</span> процесс должен его открыть. Цель данного системного вызова - разрешить системе проанализировать <span class="keyword">атрибуты файла</span> и проверить права доступа к нему, а также считать в оперативную память список адресов блоков <span class="keyword">файла</span> для быстрого доступа к его данным. Открытие <span class="keyword">файла</span> является процедурой создания <b>дескриптора</b> или управляющего блока <span class="keyword">файла</span>. Дескриптор (описатель) <span class="keyword">файла</span> хранит всю информацию о нем. Иногда, в соответствии с парадигмой, принятой в языках программирования, под дескриптором понимается альтернативное имя <span class="keyword">файла</span> или указатель на описание <span class="keyword">файла</span> в таблице открытых <span class="keyword">файлов</span>, используемый при последующей работе с <span class="keyword">файлом
</span>. Например, на языке Cи операция открытия <span class="keyword">файла</span> <span class="texample"> fd=open(pathname,flags,modes);</span> возвращает дескриптор <span class="texample">fd</span>, который может быть задействован при выполнении операций чтения (<span class="texample">read(fd,buffer,count);</span> ) или записи.</li><li>Закрытие <span class="keyword">файла</span>. Если работа с <span class="keyword">файлом</span> завершена, его <span class="keyword">атрибуты</span> и адреса блоков на диске больше не нужны. В этом случае <span class="keyword">файл</span> нужно закрыть, чтобы освободить место во внутренних таблицах файловой системы.</li><li>Позиционирование. Дает возможность специфицировать место внутри <span class="keyword">файла</span>, откуда будет производиться считывание (или запись) данных, то есть задать <b>текущую</b> позицию.</li><li>Чтение данных из <span class="keyword">файла</span>. Обычно это делается с текущей позиции. Пользователь должен задать объем считываемых данных и предоставить для них буфер в оперативной памяти.</li><li>Запись данных в <span class="keyword">файл</span> с текущей позиции. Если текущая позиция находится в конце <span class="keyword">файла</span>, его размер увеличивается, в противном случае запись осуществляется на место имеющихся данных, которые, таким образом, теряются.</li></ul><div  class="lecture_mark" id="mark_56"></div><p  id="id_67">Есть и другие операции, например переименование <span class="keyword">файла</span>, получение <span class="keyword">атрибутов файла</span> и т. д.</p><div  class="lecture_mark" id="mark_67"></div><p  id="id_68">Существует два способа выполнить последовательность действий над <span class="keyword">файлами</span> [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#23">Олифер, 2001</a>].</p><div  class="lecture_mark" id="mark_68"></div><p  id="id_69">В первом случае для каждой операции выполняются как универсальные, так и уникальные действия (схема stateless). Например, последовательность операций может быть такой: <span class="texample">open</span>, <span class="texample">read1</span>, <span class="texample">close</span>, ... <span class="texample">open</span>, <span class="texample">read2</span>, <span class="texample">close</span>, ... <span class="texample">open</span>, <span class="texample">read3</span>, <span class="texample">close</span>.</p><div  class="lecture_mark" id="mark_69"></div><p  id="id_79">Альтернативный способ - это когда универсальные действия выполняются в начале и в конце последовательности операций, а для каждой промежуточной операции выполняются только уникальные действия. В этом случае последовательность вышеприведенных операций будет выглядеть так: <span class="texample">open</span>, <span class="texample">read1</span>, ... <span class="texample">read2</span>, ... <span class="texample">read3</span>, <span class="texample">close</span>.</p><div  class="lecture_mark" id="mark_79"></div><p  id="id_85">Большинство ОС использует второй способ, более экономичный и быстрый. Первый способ более устойчив к сбоям, поскольку результаты каждой операции становятся независимыми от результатов предыдущей операции; поэтому он иногда применяется в распределенных файловых системах (например, Sun NFS).</p><div  class="lecture_mark" id="mark_85"></div><h3 >Директории. Логическая структура файлового архива</h3><p  id="id_86">Количество <span class="keyword">файлов</span> на компьютере может быть большим. Отдельные системы хранят тысячи <span class="keyword">файлов</span>, занимающие сотни гигабайтов дискового пространства. Эффективное управление этими данными подразумевает наличие в них четкой логической структуры. Все современные файловые системы поддерживают многоуровневое именование <span class="keyword">файлов</span> за счет наличия во <span class="keyword">внешней памяти</span> дополнительных <span class="keyword">файлов</span> со специальной структурой - <span class="keyword">каталогов</span> (или <span class="keyword">директорий</span>). </p><div  class="lecture_mark" id="mark_86"></div><p  id="id_87">Каждый <span class="keyword">каталог</span> содержит список <span class="keyword">каталогов</span> и/или <span class="keyword">файлов</span>, содержащихся в данном <span class="keyword">каталоге</span>. <span class="keyword">Каталоги</span> имеют один и тот же внутренний формат, где каждому <span class="keyword">файлу</span> соответствует одна запись в <span class="keyword">файле</span> <span class="keyword"> директории</span> (см., например, <a href="">рис.11.3</a>).</p><div  class="lecture_mark" id="mark_87"></div><p  id="id_88">Число <span class="keyword">директорий</span> зависит от системы. В ранних ОС имелась только одна корневая <span class="keyword">директория</span>, затем появились <span class="keyword">директории</span> для пользователей (по одной <span class="keyword">директории</span> на пользователя). В современных ОС используется произвольная структура дерева <span class="keyword">директорий</span>.</p><div  class="lecture_mark" id="mark_88"></div><p  align="left" id="id_89"><a name="image.11.3"></a><div><img src="11. Файлы с точки зрения пользователя_files/11-30000.gif" alt="Директории" width="421" height="137"></div><br><b>Рис. 11.3.</b> 
        Директории</p><div  class="lecture_mark" id="mark_89"></div><p  id="id_90">Таким образом, <span class="keyword">файлы</span> на диске образуют иерархическую древовидную структуру (см. <a href="">рис. 11.4</a>).</p><div  class="lecture_mark" id="mark_90"></div><p  align="left" id="id_91"><a name="image.11.4"></a><div><img src="11. Файлы с точки зрения пользователя_files/11-40000.gif" alt="Древовидная структура файловой системы" width="419" height="231"></div><br><b>Рис. 11.4.</b> 
        Древовидная структура файловой системы</p><div  class="lecture_mark" id="mark_91"></div><p  id="id_92">Существует несколько эквивалентных способов изображения дерева. Структура перевернутого дерева, приведенного на <a href="">рис. 11.4</a>, наиболее распространена. Верхнюю вершину называют корнем. Если элемент дерева не может иметь потомков, он называется терминальной вершиной или листом (в данном случае является <span class="keyword">файлом</span>). Нелистовые вершины - справочники или <span class="keyword">каталоги</span> содержат списки листовых и нелистовых вершин. Путь от корня к <span class="keyword">файлу</span> <b> однозначно</b> определяет <span class="keyword">файл</span>. </p><div  class="lecture_mark" id="mark_92"></div><p  id="id_93">Подобные древовидные структуры являются графами, не имеющими циклов. Можно считать, что ребра графа направлены вниз, а корень - вершина, не имеющая входящих ребер. Как мы увидим в следующей лекции, связывание <span class="keyword">файлов</span>, которое практикуется в ряде операционных систем, приводит к образованию циклов в графе.</p><div  class="lecture_mark" id="mark_93"></div><p  id="id_94">Внутри одного <span class="keyword">каталога</span> имена листовых <span class="keyword">файлов</span> уникальны. Имена <span class="keyword">файлов</span>, находящихся в разных <span class="keyword">каталогах</span>, могут совпадать. Для того чтобы однозначно определить <span class="keyword">файл</span> по его имени (избежать коллизии имен), принято именовать <span class="keyword">файл</span> так называемым <b>абсолютным или полным именем (pathname)</b>, состоящим из списка имен вложенных <span class="keyword">каталогов</span>, по которому можно найти путь от корня к <span class="keyword">файлу</span> плюс имя <span class="keyword">файла</span> в <span class="keyword">каталоге</span>, непосредственно содержащем данный <span class="keyword">файл</span>. То есть полное имя включает цепочку имен - путь к <span class="keyword">файлу</span>, например <span class="texample">/usr/games/doom</span>. Такие имена уникальны. Компоненты пути разделяют различными символами: "/" (слэш) в Unix или обратными слэшем в MS-DOS (в Multics - "&gt;"). Таким образом, использование древовидных <span class="keyword">каталогов</span> минимизирует сложность назначения уникальных имен.</p><div  class="lecture_mark" id="mark_94"></div><p  id="id_96">Указывать полное имя не всегда удобно, поэтому применяют другой способ задания имени - <b>относительный</b> путь к <span class="keyword">файлу</span>. Он использует концепцию рабочей или текущей <span class="keyword">директории</span>, которая обычно входит в состав атрибутов процесса, работающего с данным <span class="keyword">файлом</span>. Тогда на <span class="keyword">файлы</span> в такой <span class="keyword">директории</span> можно ссылаться только по имени, при этом поиск <span class="keyword">файла</span> будет осуществляться в рабочем <span class="keyword">каталоге</span>. Это удобнее, но, по существу, то же самое, что и абсолютная форма.</p><div  class="lecture_mark" id="mark_96"></div><p  id="id_97">Для получения <span class="keyword">доступа к файлу</span> и локализации его блоков система должна выполнить навигацию по <span class="keyword">каталогам</span>. Рассмотрим для примера путь <span class="texample">/usr/linux/progr.c</span>. Алгоритм одинаков для всех иерархических систем. Сначала в фиксированном месте на диске находится корневая <span class="keyword">директория</span>. Затем находится компонент пути <span class="texample">usr</span>, т. е. в корневой <span class="keyword">директории</span> ищется <span class="keyword">файл</span> <span class="texample"> /usr</span>. Исследуя этот <span class="keyword">файл</span>, система понимает, что данный <span class="keyword">файл</span> является <span class="keyword">каталогом</span>, и блоки его данных рассматривает как список <span class="keyword">файлов</span> и ищет следующий компонент <span class="texample">linux</span> в нем. Из строки для <span class="texample">linux</span> находится <span class="keyword">файл</span>, соответствующий компоненту <span class="texample">usr/linux/</span>. Затем находится компонент <span class="texample">progr.c</span>, который открывается, заносится в таблицу открытых <span class="keyword">файлов</span> и сохраняется в ней до закрытия <span class="keyword">файла</span>. </p><div  class="lecture_mark" id="mark_97"></div><p  id="id_105">Отклонение от типовой обработки компонентов <span class="texample">pathname</span> может возникнуть в том случае, когда этот компонент является не обычным <span class="keyword">каталогом</span> с соответствующим ему индексным узлом и списком <span class="keyword">файлов</span>, а служит точкой связывания (принято говорить "точкой монтирования") двух файловых архивов. Этот случай рассмотрен в следующей лекции.</p><div  class="lecture_mark" id="mark_105"></div><p  id="id_107">Многие прикладные программы работают с <span class="keyword">файлами</span>, находящимися в текущей <span class="keyword">директории</span>, не указывая явным образом ее имени. Это дает пользователю возможность произвольным образом именовать <span class="keyword">каталоги</span>, содержащие различные программные пакеты. Для реализации этой возможности в большинстве ОС, поддерживающих иерархическую структуру <span class="keyword">директорий</span>, используется обозначение "<span class="texample">.</span>" - для текущей <span class="keyword">директории</span> и "<span class="texample">..</span>" - для родительской.</p><div  class="lecture_mark" id="mark_107"></div><h4 >Разделы диска. Организация доступа к архиву файлов.</h4><p  id="id_110">Задание пути к <span class="keyword">файлу</span> в файловых системах некоторых ОС отличается тем, с чего начинается эта цепочка имен.</p><div  class="lecture_mark" id="mark_110"></div><p  id="id_111">В современных ОС принято разбивать диски на <b>логические диски</b> (это низкоуровневая операция), иногда называемые <b>разделами</b> (partitions). Бывает, что, наоборот, объединяют несколько физических дисков в один логический диск (например, это можно сделать в ОС Windows NT). Поэтому в дальнейшем изложении мы будем игнорировать проблему физического выделения пространства для <span class="keyword">файлов</span> и считать, что каждый раздел представляет собой отдельный (виртуальный) диск. Диск содержит иерархическую древовидную структуру, состоящую из набора <span class="keyword">файлов</span>, каждый из которых является хранилищем данных пользователя, и <span class="keyword">каталогов</span> или <span class="keyword">директорий</span> (то есть <span class="keyword">файлов</span>, которые содержат перечень других <span class="keyword">файлов</span>, входящих в состав <span class="keyword">каталога</span>), необходимых для хранения информации о <span class="keyword">файлах</span> системы. </p><div  class="lecture_mark" id="mark_111"></div><p  id="id_112">В некоторых системах управления <span class="keyword">файлами</span> требуется, чтобы каждый архив <span class="keyword">файлов</span> целиком располагался на одном диске (разделе диска). В этом случае полное имя <span class="keyword">файла</span> начинается с имени дискового устройства, на котором установлен соответствующий диск (буквы диска). Например, <span class="texample">c:\util\nu\ndd.exe</span>. Такой способ именования используется в файловых системах DEC и Microsoft.</p><div  class="lecture_mark" id="mark_112"></div><p  id="id_114">В других системах (Multics) вся совокупность <span class="keyword">файлов</span> и <span class="keyword">каталогов</span> представляет собой единое дерево. Сама система, выполняя поиск <span class="keyword">файлов</span> по имени, начиная с корня, требовала установки необходимых дисков.</p><div  class="lecture_mark" id="mark_114"></div><p  id="id_115">В ОС Unix предполагается наличие нескольких архивов <span class="keyword">файлов</span>, каждый на своем разделе, один из которых считается корневым. После запуска системы можно <b>"смонтировать"</b> корневую файловую систему и ряд изолированных файловых систем в одну общую файловую систему.</p><div  class="lecture_mark" id="mark_115"></div><p  id="id_116">Технически это осуществляется с помощью создания в корневой файловой системе специальных пустых <span class="keyword">каталогов</span> (см. также следующую лекцию). Специальный системный вызов mount ОС Unix позволяет подключить к одному из этих пустых <span class="keyword">каталогов</span> корневой <span class="keyword">каталог</span> указанного архива <span class="keyword">файлов</span>. После монтирования общей файловой системы именование <span class="keyword">файлов</span> производится так же, как если бы она с самого начала была централизованной. Задачей ОС является беспрепятственный проход точки монтирования при получении <span class="keyword">доступа к файлу</span> по цепочке имен. Если учесть, что обычно монтирование файловой системы производится при загрузке системы, пользователи ОС Unix обычно и не задумываются о происхождении общей файловой системы.</p><div  class="lecture_mark" id="mark_116"></div><h3 >Операции над директориями</h3><p  id="id_117">Как и в случае с <span class="keyword">файлами</span>, система обязана обеспечить пользователя набором операций, необходимых для работы с <span class="keyword">директориями</span>, реализованных через системные вызовы. Несмотря на то что <span class="keyword">директории</span> - это <span class="keyword">файлы</span>, логика работы с ними отличается от логики работы с обычными <span class="keyword">файлами</span> и определяется природой этих объектов, предназначенных для поддержки структуры файлового архива. Совокупность системных вызовов для управления <span class="keyword">директориями</span> зависит от особенностей конкретной ОС. Напомним, что <span class="keyword">операции над каталогами</span> являются прерогативой ОС, то есть пользователь не может, например, выполнить запись в <span class="keyword">каталог</span> начиная с текущей позиции. Рассмотрим в качестве примера некоторые системные вызовы, необходимые для работы с 
	<span class="keyword">каталогами</span> [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#30">Таненбаум, 2002</a>].</p><div  class="lecture_mark" id="mark_117"></div><ul  id="id_118"><li>Создание <span class="keyword">директории</span>. Вновь созданная <span class="keyword">директория</span> включает записи с именами '<span class="texample">.</span>' и '<span class="texample">..</span>', однако считается пустой.</li><li>Удаление <span class="keyword">директории</span>. Удалена может быть только пустая <span class="keyword">директория</span>.</li><li>Открытие <span class="keyword">директории</span> для последующего чтения. Hапример, чтобы перечислить <span class="keyword">файлы</span>, входящие в <span class="keyword">директорию</span>, процесс должен открыть <span class="keyword">директорию</span> и считать имена всех <span class="keyword">файлов</span>, которые она включает.</li><li>Закрытие <span class="keyword">директории</span> после ее чтения для освобождения места во внутренних системных таблицах.</li><li>Поиск. Данный системный вызов возвращает содержимое текущей записи в открытой <span class="keyword">директории</span>. Вообще говоря, для этих целей может использоваться системный вызов <span class="texample">Read</span>, но в этом случае от программиста потребуется знание внутренней структуры <span class="keyword">директории</span>. </li><li>Получение списка <span class="keyword">файлов</span> в <span class="keyword">каталоге</span>.</li><li>Переименование. Имена <span class="keyword">директорий</span> можно менять, как и имена <span class="keyword">файлов</span>.</li><li>Создание <span class="keyword">файла</span>. При создании нового <span class="keyword">файла</span> необходимо добавить в <span class="keyword">каталог</span> соответствующий элемент.</li><li>Удаление <span class="keyword">файла</span>. Удаление из <span class="keyword">каталога</span> соответствующего элемента. Если удаляемый <span class="keyword">файл</span> присутствует только в одной <span class="keyword">директории</span>, то он вообще удаляется из файловой системы, в противном случае система ограничивается только удалением специфицируемой записи.</li></ul><div  class="lecture_mark" id="mark_118"></div><p  id="id_131">Очевидно, что создание и удаление <span class="keyword">файлов</span> предполагает также выполнение соответствующих файловых операций. Имеется еще ряд других системных вызовов, например связанных с защитой информации.</p><div  class="lecture_mark" id="mark_131"></div><h3 >Защита файлов</h3><p  id="id_132">Общие проблемы безопасности ОС рассмотрены в лекциях 15-16. Информация в компьютерной системе должна быть защищена как от физического <b>разрушения</b> (reliability), так и от несанкционированного <b>доступа</b> (protection).</p><div  class="lecture_mark" id="mark_132"></div><p  id="id_133">Здесь мы коснемся отдельных аспектов защиты, связанных с контролем <span class="keyword">доступа к файлам</span>. </p><div  class="lecture_mark" id="mark_133"></div><h4 >Контроль доступа к файлам </h4><p  id="id_134">Наличие в системе многих пользователей предполагает организацию контролируемого <span class="keyword">доступа к файлам</span>. Выполнение любой <span class="keyword">операции над файлом</span> должно быть разрешено только в случае наличия у пользователя соответствующих привилегий. Обычно контролируются следующие операции: чтение, запись и выполнение. Другие операции, например копирование <span class="keyword">файлов</span> или их переименование, также могут контролироваться. Однако они чаще реализуются через перечисленные. Так, операцию копирования <span class="keyword">файлов</span> можно представить как операцию чтения и последующую операцию записи.</p><div  class="lecture_mark" id="mark_134"></div><h4 >Списки прав доступа</h4><p  id="id_135">Hаиболее общий подход к <span class="keyword">защите файлов</span> от несанкционированного использования - сделать доступ зависящим от идентификатора пользователя, то есть связать с каждым <span class="keyword">файлом</span> или <span class="keyword">директорией</span> <b> список прав доступа</b> (access control list), где перечислены имена пользователей и типы разрешенных для них способов <span class="keyword">доступа к файлу</span>. Любой запрос на выполнение операции сверяется с таким списком. Основная проблема реализации данного способа - список может быть длинным. Чтобы разрешить всем пользователям читать <span class="keyword">файл</span>, необходимо всех их внести в список. У такой техники есть два нежелательных следствия.</p><div  class="lecture_mark" id="mark_135"></div><ul  id="id_136"><li>Конструирование подобного списка может оказаться сложной задачей, особенно если мы не знаем заранее пользователей системы.</li><li>Запись в <span class="keyword">директории</span> должна иметь переменный размер (включать список потенциальных пользователей).</li></ul><div  class="lecture_mark" id="mark_136"></div><p  id="id_139">Для решения этих проблем создают классификации пользователей, например, в ОС Unix все пользователи разделены на три группы.</p><div  class="lecture_mark" id="mark_139"></div><ul  id="id_140"><li><b>Владелец</b> (Owner).</li><li><b>Группа</b> (Group). Hабор пользователей, разделяющих <span class="keyword">файл</span> и нуждающихся в типовом способе доступа к нему.</li><li><b>Остальные</b> (Univers).</li></ul><div  class="lecture_mark" id="mark_140"></div><p  id="id_144">Это позволяет реализовать конденсированную версию списка прав доступа. В рамках такой ограниченной классификации задаются только три поля (по одному для каждой группы) для каждой контролируемой операции. В итоге в Unix операции чтения, записи и исполнения контролируются при помощи 9 бит (rwxrwxrwx).</p><div  class="lecture_mark" id="mark_144"></div><h3 >Заключение</h3><p  id="id_145">Итак, файловая система представляет собой набор <span class="keyword">файлов</span>, <span class="keyword">директорий</span> и операций над ними. Имена, структуры <span class="keyword">файлов</span>, способы доступа к ним и их <span class="keyword">атрибуты</span> - важные аспекты организации файловой системы. Обычно <span class="keyword">файл</span> представляет собой неструктурированную последовательность байтов. Главная задача файловой системы - связать символьное имя <span class="keyword">файла</span> с данными на диске. Большинство современных ОС поддерживает иерархическую систему <span class="keyword">каталогов</span> или <span class="keyword">директорий</span> с возможным вложением <span class="keyword">директорий</span>. Безопасность файловой системы, базирующаяся на ведении списков прав доступа, - одна из важнейших концепций ОС.</p><div  class="lecture_mark" id="mark_145"></div>


	</td>
	</tr>
	<tr><td height="8"><img src="11. Файлы с точки зрения пользователя_files/empty000.gif" width="1" height="8"></td></tr>
	</table>
	<!-- /content -->

</td>
<td><img src="11. Файлы с точки зрения пользователя_files/empty000.gif" width="8" height="1"></td>
</tr>
</table>
<!-- /bottom -->
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td class="orang" height="1"><img src="11. Файлы с точки зрения пользователя_files/empty000.gif" width="1" height="1"></td></tr>
<td class="ltxt" align=center>&copy; INTUIT.ru, 2003-2008. Все права защищены.</td>
</tr>
</table>
<!-- /bottom -->

<script src="11. Файлы с точки зрения пользователя_files/urchin00.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-3475067-1";
urchinTracker();
</script></body>
</html>


<!-- This document saved from http://www.intuit.ru/department/os/osintro/11/osintro_11.html -->
