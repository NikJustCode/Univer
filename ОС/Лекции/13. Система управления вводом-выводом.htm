<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>INTUIT.ru::Интернет-Университет Информационных Технологий</title>
<link href="13. Система управления вводом-выводом_files/printabl.css" type="text/css" rel="stylesheet">
</head>
<body leftmargin="6" topmargin="6" marginheight="6" marginwidth="6">


<div align="left">
<span style="color: #000000; font-weight: bold;">
&nbsp;&nbsp;
<span style="font-size:12pt;">Интернет-Университет Информационных Технологий</span>
</span>
</div>

&nbsp;&nbsp;
<span align="rright" style="color: #330066; text-decoration:underline;">http://www.INTUIT.ru</span>


<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td height="8" colspan=3><img src="13. Система управления вводом-выводом_files/empty000.gif" width="1" height="8"></td></tr>
<tr><td class="orang" height="1" colspan=3><img src="13. Система управления вводом-выводом_files/empty000.gif" width="1" height="1"></td></tr>
<tr><td height="8" colspan=3><img src="13. Система управления вводом-выводом_files/empty000.gif" width="1" height="8"></td></tr>
<tr valign="top">
<td><img src="13. Система управления вводом-выводом_files/empty000.gif" width="8" height="1"></td>
<td>
	<!-- content -->
	<table border="0" cellpadding="0" cellspacing="0" width="100%">
	<tr><td class="head">Основы операционных систем</td></tr>
<tr><td height="4"><img src="13. Система управления вводом-выводом_files/empty000.gif" width="1" height="4"></td></tr>
	<tr><td class="orang" height="1"><img src="13. Система управления вводом-выводом_files/empty000.gif" width="1" height="1"></td></tr>
	<tr><td height="8"><img src="13. Система управления вводом-выводом_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td><span class="headsub">


13. Лекция:

 Система управления вводом-выводом: версия для печати и PDA</span>

<br>
<span class="rtxt">В лекции рассматриваются основные физические и логические принципы организации ввода-вывода в вычислительных системах.
</span>

</td></tr>

	<tr><td height="8"><img src="13. Система управления вводом-выводом_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td class="orang" height="1"><img src="13. Система управления вводом-выводом_files/empty000.gif" width="1" height="1"></td></tr>
	<tr><td height="8"><img src="13. Система управления вводом-выводом_files/empty000.gif" width="1" height="8"></td></tr>
	<tr><td>


<p  id="id_1">Функционирование любой вычислительной системы обычно сводится к выполнению двух видов работы: обработке информации и операций по осуществлению ее ввода-вывода. Поскольку в рамках модели, принятой в данном курсе, все, что выполняется в вычислительной системе, организовано как набор процессов, эти два вида работы выполняются процессами. Процессы занимаются обработкой информации и выполнением операций ввода-вывода. </p><div  class="lecture_mark" id="mark_1"></div><p  id="id_2">Содержание понятий "обработка информации" и "операции ввода-вывода" зависит от того, с какой точки зрения мы смотрим на них. С точки зрения программиста, под "обработкой информации" понимается выполнение команд процессора над данными, лежащими в памяти независимо от уровня иерархии – в регистрах, кэше, оперативной или вторичной памяти. Под "операциями ввода-вывода" программист понимает обмен данными между памятью и устройствами, внешними по отношению к памяти и процессору, такими как магнитные ленты, диски, монитор, клавиатура, таймер. С точки зрения операционной системы "обработкой информации" являются только операции, совершаемые процессором над данными, находящимися в памяти на уровне иерархии не ниже, чем оперативная память. Все остальное относится к "операциям ввода-вывода". Чтобы выполнять операции над данными, временно расположенными во вторичной памяти, операционная система, сначала производит их подкачку в оперативную память, и лишь затем процессор совершает необходимые действия.</p><div  class="lecture_mark" id="mark_2"></div><p  id="id_3">Объяснение того, что именно делает процессор при обработке информации, как он решает задачу и какой алгоритм выполняет, не входит в задачи нашего курса. Это скорее относится к курсу "Алгоритмы и структуры данных", с которого обычно начинается изучение информатики. Как операционная система управляет обработкой информации, мы разобрали ранее, в деталях описав два состояния процессов – <b>исполнение</b> (а что его описывать то?) и <b>готовность</b> (очереди планирования и т. д.), а также правила, по которым осуществляется перевод процессов из одного состояния в другое (алгоритмы планирования процессов). </p><div  class="lecture_mark" id="mark_3"></div><p  id="id_4">Данная лекция будет посвящена второму виду работы вычислительной системы – операциям ввода-вывода. Мы разберем, что происходит в компьютере при выполнении операций ввода-вывода, и как операционная система управляет их выполнением. При этом для простоты будем считать, что объем оперативной памяти в вычислительной системе достаточно большой, т. е. все процессы полностью располагаются в оперативной памяти, и поэтому понятие "операция ввода-вывода" с точки зрения операционной системы и с точки зрения пользователя означает одно и то же. Такое предположение не снижает общности нашего рассмотрения, так как подкачка информации из вторичной памяти в оперативную память и обратно обычно строится по тому же принципу, что и все операции ввода-вывода.</p><div  class="lecture_mark" id="mark_4"></div><p  id="id_5">Прежде чем говорить о работе операционной системы при осуществлении операций ввода-вывода, нам придется вспомнить некоторые сведения из курса "Архитектура современных ЭВМ и язык Ассемблера", чтобы понять, как осуществляется передача информации между оперативной памятью и внешним устройством и почему для подключения к вычислительной системе новых устройств ее не требуется перепроектировать.</p><div  class="lecture_mark" id="mark_5"></div><h3 >Физические принципы организации ввода-вывода</h3><p  id="id_6">Существует много разнообразных устройств, которые могут взаимодействовать с процессором и памятью: таймер, жесткие диски, клавиатура, дисплеи, мышь, модемы и т. д., вплоть до устройств отображения и ввода информации в авиационно-космических тренажерах. Часть этих устройств может быть встроена внутрь корпуса компьютера, часть – вынесена за его пределы и общаться с компьютером через различные линии связи: кабельные, оптоволоконные, радиорелейные, спутниковые и т. д. Конкретный набор устройств и способы их подключения определяются целями функционирования вычислительной системы, желаниями и финансовыми возможностями пользователя. Несмотря на все многообразие устройств, управление их работой и обмен информацией с ними строятся на относительно небольшом наборе принципов, которые мы постараемся разобрать в этом разделе.</p><div  class="lecture_mark" id="mark_6"></div><h4 >Общие сведения об архитектуре компьютера </h4><p  id="id_7"><a name="keyword-context.1"></a>В простейшем случае процессор, память и многочисленные внешние устройства связаны большим количеством электрических соединений – <b>линий</b>, которые в совокупности принято называть <span class="keyword_def">локальной магистралью</span> компьютера. Внутри <span class="keyword">локальной магистрали</span> линии, служащие для передачи сходных сигналов и предназначенные для выполнения сходных функций, принято группировать в <b>шины</b>. При этом понятие шины включает в себя не только набор проводников, но и набор жестко заданных протоколов, определяющий перечень сообщений, который может быть передан с помощью электрических сигналов по этим проводникам. В современных компьютерах выделяют как минимум три шины:</p><div  class="lecture_mark" id="mark_7"></div><ul  id="id_8"><li><a name="keyword-context.2"></a><span class="keyword_def">шину данных</span>, состоящую из линий данных и служащую для передачи информации между процессором и памятью, процессором и устройствами ввода-вывода, памятью и внешними устройствами; </li><li><a name="keyword-context.3"></a><span class="keyword_def">адресную шину</span>, состоящую из линий адреса и служащую для задания адреса ячейки памяти или указания устройства ввода-вывода, участвующих в обмене информацией;</li><li><a name="keyword-context.4"></a><span class="keyword_def">шину управления</span>, состоящую из линий управления <span class="keyword">локальной магистралью</span> и линий ее состояния, определяющих поведение <span class="keyword">локальной магистрали</span>. В некоторых архитектурных решениях линии состояния выносятся из этой шины в отдельную шину состояния.</li></ul><div  class="lecture_mark" id="mark_8"></div><p  id="id_12">Количество линий, входящих в состав шины, принято называть <b>разрядностью</b> (<b>шириной</b>) этой шины. Ширина <span class="keyword">адресной шины</span>, например, определяет максимальный размер оперативной памяти, которая может быть установлена в вычислительной системе. Ширина <span class="keyword">шины данных</span> определяет максимальный объем информации, которая за один раз может быть получена или передана по этой шине.</p><div  class="lecture_mark" id="mark_12"></div><p  id="id_13">Операции обмена информацией осуществляются при одновременном участии всех шин. Рассмотрим, к примеру, действия, которые должны быть выполнены для передачи информации из процессора в память. В простейшем случае необходимо выполнить три действия.</p><div  class="lecture_mark" id="mark_13"></div><ol  id="id_14"><li>На <span class="keyword">адресной шине</span> процессор должен выставить сигналы, соответствующие адресу ячейки памяти, в которую будет осуществляться передача информации.</li><li>На <span class="keyword">шину данных</span> процессор должен выставить сигналы, соответствующие информации, которая должна быть записана в память.</li><li>После выполнения действий 1 и 2 на <span class="keyword">шину управления</span> выставляются сигналы, соответствующие операции записи и работе с памятью, что приведет к занесению необходимой информации по нужному адресу.</li></ol><div  class="lecture_mark" id="mark_14"></div><p  id="id_18">Естественно, что приведенные выше действия являются необходимыми, но недостаточными при рассмотрении работы конкретных процессоров и микросхем памяти. Конкретные архитектурные решения могут требовать дополнительных действий: например, выставления на <span class="keyword">шину управления</span> сигналов частичного использования <span class="keyword">шины данных</span> (для передачи меньшего количества информации, чем позволяет ширина этой шины); выставления сигнала готовности магистрали после завершения записи в память, разрешающего приступить к новой операции, и т. д. Однако общие принципы выполнения операции записи в память остаются неизменными. </p><div  class="lecture_mark" id="mark_18"></div><p  id="id_19">В то время как память легко можно представить себе в виде последовательности пронумерованных адресами ячеек, локализованных внутри одной микросхемы или набора микросхем, к устройствам ввода-вывода подобный подход неприменим. <a name="keyword-context.5"></a>Внешние устройства разнесены пространственно и могут подключаться к <span class="keyword">локальной магистрали</span> в одной точке или множестве точек, получивших название <span class="keyword_def">портов ввода-вывода</span>. Тем не менее, точно так же, как ячейки памяти взаимно однозначно отображались в адресное пространство памяти, <span class="keyword">порты ввода-вывода</span> можно взаимно однозначно отобразить в другое адресное пространство – <span class="keyword">адресное пространство ввода-вывода</span>. При этом каждый <span class="keyword">порт ввода-вывода</span> получает свой номер или адрес в этом пространстве. В некоторых случаях, когда адресное пространство памяти (размер которого определяется шириной <span class="keyword">адресной шины</span>) задействовано не полностью (остались адреса, которым не соответствуют физические ячейки памяти) и протоколы работы с внешним устройством совместимы с протоколами работы с памятью, часть <span class="keyword">портов ввода
-вывода</span> может быть отображена непосредственно в адресное пространство памяти (так, например, поступают с видеопамятью дисплеев), правда, тогда эти порты уже не принято называть портами. Надо отметить, что при отображении портов в адресное пространство памяти для организации доступа к ним в полной мере могут быть задействованы существующие механизмы защиты памяти без организации специальных защитных устройств.</p><div  class="lecture_mark" id="mark_19"></div><p  id="id_20">В ситуации прямого отображения <span class="keyword">портов ввода-вывода</span> в адресное пространство памяти действия, необходимые для записи информации и управляющих команд в эти порты или для чтения данных из них и их состояний, ничем не отличаются от действий, производимых для передачи информации между оперативной памятью и процессором, и для их выполнения применяются те же самые команды. Если же порт отображен в <span class="keyword">адресное пространство ввода-вывода</span>, то процесс обмена информацией инициируется специальными командами ввода-вывода и включает в себя несколько другие действия. Например, для передачи данных в порт необходимо выполнить следующее.</p><div  class="lecture_mark" id="mark_20"></div><ul  id="id_21"><li>На <span class="keyword">адресной шине</span> процессор должен выставить сигналы, соответствующие адресу порта, в который будет осуществляться передача информации, в <span class="keyword">адресном пространстве ввода-вывода</span>.</li><li>На <span class="keyword">шину данных</span> процессор должен выставить сигналы, соответствующие информации, которая должна быть передана в порт.</li><li>После выполнения действий 1 и 2 на <span class="keyword">шину управления</span> выставляются сигналы, соответствующие операции записи и работе с устройствами ввода-вывода (переключение адресных пространств!), что приведет к передаче необходимой информации в нужный порт.</li></ul><div  class="lecture_mark" id="mark_21"></div><p  id="id_25">Существенное отличие памяти от устройств ввода-вывода заключается в том, что занесение информации в память является окончанием операции записи, в то время как занесение информации в порт зачастую представляет собой инициализацию реального совершения операции ввода-вывода. <a name="keyword-context.6"></a>Что именно должны делать устройства, приняв информацию через свой порт, и каким именно образом они должны поставлять информацию для чтения из порта, определяется электронными схемами устройств, получившими название <span class="keyword_def">контроллеров</span>. <span class="keyword">Контроллер</span> может непосредственно управлять отдельным устройством (например, контроллер диска), а может управлять несколькими устройствами, связываясь с их <span class="keyword">контроллерами</span> посредством специальных шин ввода-вывода (шина IDE, шина SCSI и т. д.).</p><div  class="lecture_mark" id="mark_25"></div><p  id="id_26">Современные вычислительные системы могут иметь разнообразную архитектуру, множество шин и магистралей, мосты для перехода информации от одной шины к другой и т. п. Для нас сейчас важными являются только следующие моменты.</p><div  class="lecture_mark" id="mark_26"></div><ul  id="id_27"><li>Устройства ввода-вывода подключаются к системе через порты.</li><li>Могут существовать два адресных пространства: пространство памяти и <span class="keyword">пространство ввода-вывода</span>.</li><li>Порты, как правило, отображаются в <span class="keyword">адресное пространство ввода-вывода</span> и иногда – непосредственно в адресное пространство памяти.</li><li>Использование того или иного адресного пространства определяется типом команды, выполняемой процессором, или типом ее операндов.</li><li>Физическим управлением устройством ввода-вывода, передачей информации через порт и выставлением некоторых сигналов на магистрали занимается <span class="keyword">контроллер устройства</span>.</li></ul><div  class="lecture_mark" id="mark_27"></div><p  id="id_33">Именно единообразие подключения внешних устройств к вычислительной системе является одной из составляющих идеологии, позволяющих добавлять новые устройства без перепроектирования всей системы.</p><div  class="lecture_mark" id="mark_33"></div><h4 >Структура контроллера устройства </h4><p  id="id_34"><span class="keyword">Контроллеры устройств</span> ввода-вывода весьма различны как по своему внутреннему строению, так и по исполнению (от одной микросхемы до специализированной вычислительной системы со своим процессором, памятью и т. д.), поскольку им приходится управлять совершенно разными приборами. Не вдаваясь в детали этих различий, мы выделим некоторые общие черты <span class="keyword">контроллеров</span>, необходимые им для взаимодействия с вычислительной системой. <a name="keyword-context.7"></a>Обычно каждый <span class="keyword">контроллер</span> имеет по крайней мере четыре внутренних регистра, называемых <span class="keyword_def">регистрами состояния</span>, <b>управления</b>, <b>входных данных</b> и <b>выходных данных</b>. Для доступа к содержимому этих регистров вычислительная система может использовать один или несколько портов, что для нас не существенно. Для простоты изложения будем считать, что каждому регистру соответствует свой порт. </p><div  class="lecture_mark" id="mark_34"></div><p  id="id_35"><a name="keyword-context.8"></a><span class="keyword">Регистр состояния</span> содержит биты, значение которых определяется состоянием устройства ввода-вывода и которые доступны только для чтения вычислительной системой. Эти биты индицируют завершение выполнения текущей команды на устройстве (<b>бит занятости</b>), наличие очередного данного в <span class="keyword">регистре выходных данных</span> (<b>бит готовности данных</b>), возникновение ошибки при выполнении команды (<b>бит ошибки</b>) и т. д. </p><div  class="lecture_mark" id="mark_35"></div><p  id="id_36"><a name="keyword-context.9"></a><span class="keyword_def">Регистр управления</span> получает данные, которые записываются вычислительной системой для инициализации устройства ввода-вывода или выполнения очередной команды, а также изменения режима работы устройства. Часть битов в этом регистре может быть отведена под код выполняемой команды, часть битов будет кодировать режим работы устройства, бит <b>готовности команды</b> свидетельствует о том, что можно приступить к ее выполнению. </p><div  class="lecture_mark" id="mark_36"></div><p  id="id_37"><a name="keyword-context.10"></a><span class="keyword_def">Регистр выходных данных</span> служит для помещения в него данных для чтения вычислительной системой, а <span class="keyword_def">регистр входных данных</span> предназначен для помещения в него информации, которая должна быть выведена на устройство. Обычно емкость этих регистров не превышает ширину линии данных (а чаще всего меньше ее), хотя некоторые контроллеры могут использовать в качестве регистров очередь FIFO для <span class="keyword">буферизации</span> поступающей информации.</p><div  class="lecture_mark" id="mark_37"></div><p  id="id_38">Разумеется, набор регистров и составляющих их битов приблизителен, он призван послужить нам моделью для описания процесса передачи информации от вычислительной системы к внешнему устройству и обратно, но в том или ином виде он обычно присутствует во всех <span class="keyword">контроллерах устройств</span>.</p><div  class="lecture_mark" id="mark_38"></div><h4 >Опрос устройств и прерывания. 
Исключительные ситуации и системные вызовы </h4><p  id="id_39">Построив модель контроллера и представляя себе, что скрывается за словами "прочитать информацию из порта" и "записать информацию в порт", мы готовы к рассмотрению процесса взаимодействия устройства и процессора. Как и в предыдущих случаях, примером нам послужит команда записи, теперь уже записи или вывода данных на внешнее устройство. В нашей модели для вывода информации, помещающейся в <span class="keyword">регистр входных данных</span>, без проверки успешности вывода процессор и контроллер должны связываться следующим образом.</p><div  class="lecture_mark" id="mark_39"></div><ol  id="id_40"><li>Процессор в цикле читает информацию из порта <span class="keyword">регистра состояний</span> и проверяет значение <b>бита занятости</b>. Если <b>бит занятости</b> установлен, то это означает, что устройство еще не завершило предыдущую операцию, и процессор уходит на новую итерацию цикла. Если <b>бит занятости</b> сброшен, то устройство готово к выполнению новой операции, и процессор переходит на следующий шаг. </li><li>Процессор записывает код команды вывода в порт <span class="keyword">регистра управления</span>. </li><li>Процессор записывает данные в порт <span class="keyword">регистра входных данных</span>. </li><li>Процессор устанавливает <b>бит готовности команды</b>. В следующих шагах процессор не задействован.</li><li>Когда контроллер замечает, что <b>бит готовности команды</b> установлен, он устанавливает <b>бит занятости</b>. </li><li>Контроллер анализирует код команды в <span class="keyword">регистре управления</span> и обнаруживает, что это команда вывода. Он берет данные из <span class="keyword">регистра входных данных</span> и инициирует выполнение команды.</li><li>После завершения операции контроллер обнуляет <b>бит готовности команды</b>. </li><li>При успешном завершении операции контроллер обнуляет <b>бит ошибки</b> в <span class="keyword">регистре состояния</span>, при неудачном завершении команды – устанавливает его.</li><li>Контроллер сбрасывает <b>бит занятости</b>. </li></ol><div  class="lecture_mark" id="mark_40"></div><p  id="id_50">При необходимости вывода новой порции информации все эти шаги повторяются. Если процессор интересует, корректно или некорректно была выведена информация, то после шага 4 он должен в цикле считывать информацию из порта <span class="keyword">регистра состояний</span> до тех пор, пока не будет сброшен <b>бит занятости</b> устройства, после чего проанализировать состояние <b>бита ошибки</b>.</p><div  class="lecture_mark" id="mark_50"></div><p  id="id_51">Как видим, на первом шаге (и, возможно, после шага 4) процессор ожидает освобождения устройства, непрерывно опрашивая значение <b>бита занятости</b>. Такой способ взаимодействия процессора и контроллера получил название <span class="keyword">polling</span> или, в русском переводе, <b>способа опроса устройств</b>. Если скорости работы процессора и устройства ввода-вывода примерно равны, то это не приводит к существенному уменьшению полезной работы, совершаемой процессором. Если же скорость работы устройства существенно меньше скорости процессора, то указанная техника резко снижает производительность системы и необходимо применять другой архитектурный подход.</p><div  class="lecture_mark" id="mark_51"></div><p  id="id_52">Для того чтобы процессор не дожидался состояния готовности устройства ввода-вывода в цикле, а мог выполнять в это время другую работу, необходимо, чтобы устройство само умело сигнализировать процессору о своей готовности. <a name="keyword-context.11"></a>Технический механизм, который позволяет внешним устройствам оповещать процессор о завершении команды вывода или команды ввода, получил название механизма <span class="keyword_def">прерываний</span>. </p><div  class="lecture_mark" id="mark_52"></div><p  id="id_53">В простейшем случае для реализации механизма <span class="keyword">прерываний</span> необходимо к имеющимся у нас шинам <span class="keyword">локальной магистрали</span> добавить еще одну линию, соединяющую процессор и устройства ввода-вывода – линию <span class="keyword">прерываний</span>. По завершении выполнения операции внешнее устройство выставляет на эту линию специальный сигнал, по которому процессор после выполнения очередной команды (или после завершения очередной итерации при выполнении цепочечных команд, т. е. команд, повторяющихся циклически со сдвигом по памяти) изменяет свое поведение. Вместо выполнения очередной команды из потока команд он частично сохраняет содержимое своих регистров и переходит на выполнение программы обработки <span class="keyword">прерывания</span>, расположенной по заранее оговоренному адресу. При наличии только одной линии <span class="keyword">прерываний</span> процессор при выполнении этой программы должен опросить 
состояние всех устройств ввода-вывода, чтобы определить, от какого именно устройства пришло <span class="keyword">прерывание</span> (<span class="keyword">polling</span>   <span class="keyword">прерываний</span>!), выполнить необходимые 
действия (например, вывести в это устройство очередную порцию информации или перевести соответствующий процесс из состояния <b>ожидание</b> в состояние <b>готовность</b>) и сообщить устройству, что <span class="keyword">прерывание</span> обработано (снять <span class="keyword">прерывание</span>).</p><div  class="lecture_mark" id="mark_53"></div><p  id="id_54">В большинстве современных компьютеров процессор стараются полностью освободить от необходимости опроса внешних устройств, в том числе и от определения с помощью опроса устройства, сгенерировавшего сигнал <span class="keyword">прерывания</span>. Устройства сообщают о своей готовности процессору не напрямую, а через специальный <span class="keyword">контроллер прерываний</span>, при этом для общения с процессором он может использовать не одну линию, а целую шину <span class="keyword">прерываний</span>. Каждому устройству присваивается свой номер <span class="keyword">прерывания</span>, который при возникновении <span class="keyword">прерывания</span>   <span class="keyword">контроллер прерывания</span> заносит в свой <span class="keyword">регистр состояния</span> и, возможно, после распознавания процессором сигнала <span class="keyword">прерывания</span> и получения от него специального запроса выставляет на шину <span class="keyword">прерываний</span> или <span class="keyword">шину данных</span> для чтения процессором. Номер <span class="keyword">прерывания</span> обычно служит индексом в специальной таблице <span class="keyword">прерываний</span>, хранящейся по адресу, задаваемому при инициализации вычислительной системы, и содержащей адреса программ обработки <span class="keyword">прерываний</span> – <b>векторы</b>   <span class="keyword">прерываний</span>. Для распределения 
устройств по номерам <span class="keyword">прерываний</span> 
необходимо, чтобы от каждого устройства к <span class="keyword">контроллеру прерываний</span> шла специальная линия, соответствующая одному номеру <span class="keyword">прерывания</span>. При наличии множества устройств такое подключение становится невозможным, и на один проводник (один номер <span class="keyword">прерывания</span>) подключается несколько устройств. В этом случае процессор при обработке <span class="keyword">прерывания</span> все равно вынужден заниматься опросом устройств для определения устройства, выдавшего <span class="keyword">прерывание</span>, но в существенно меньшем объеме. Обычно при установке в систему нового устройства ввода-вывода требуется аппаратно или программно определить, каким будет номер <span class="keyword">прерывания</span>, вырабатываемый этим устройством.</p><div  class="lecture_mark" id="mark_54"></div><p  id="id_55">Рассматривая кооперацию процессов и взаимоисключения, мы говорили о существовании критических секций внутри ядра операционной системы, при выполнении которых необходимо исключить всякие <span class="keyword">прерывания</span> от внешних устройств. Для запрещения <span class="keyword">прерываний</span>, а точнее, для невосприимчивости процессора к внешним <span class="keyword">прерываниям</span> обычно существуют специальные команды, которые могут маскировать (запрещать) все или некоторые из <span class="keyword">прерываний</span> устройств ввода-вывода. В то же время определенные кризисные ситуации в вычислительной системе (например, неустранимый сбой в работе оперативной памяти) должны требовать ее немедленной реакции. Такие ситуации вызывают <span class="keyword">прерывания</span>, которые невозможно замаскировать или запретить и которые поступают в процессор по специальной линии шины <span class="keyword">прерываний</span>, называемой линией немаскируемых 

<span class="keyword">прерываний</span> (NMI – Non-Maskable Interrupt).</p><div  class="lecture_mark" id="mark_55"></div><p  id="id_56">Не все внешние устройства являются одинаково важными с точки зрения вычислительной системы ("все животные равны, но некоторые равнее других"). Соответственно, некоторые <span class="keyword">прерывания</span> являются более существенными, чем другие. <span class="keyword">Контроллер прерываний</span> обычно позволяет устанавливать приоритеты для <span class="keyword">прерываний</span> от внешних устройств. При почти одновременном возникновении <span class="keyword">прерываний</span> от нескольких устройств (во время выполнения одной и той же команды процессора) процессору сообщается номер наиболее приоритетного <span class="keyword">прерывания</span> для его обслуживания в первую очередь. Менее приоритетное <span class="keyword">прерывание</span> при этом не пропадает, о нем процессору будет доложено после обработки более приоритетного <span class="keyword">прерывания</span>. Более того, при обработке возникшего <span class="keyword">прерывания</span> процессор может получить сообщение о возникновении <span class="keyword">прерывания</span> с более высоким приоритетом и переключиться на его обработку. </p><div  class="lecture_mark" id="mark_56"></div><p  id="id_57">Механизм обработки <span class="keyword">прерываний</span>, по которому процессор прекращает выполнение команд в обычном режиме и, частично сохранив свое состояние, отвлекается на выполнение других действий, оказался настолько удобен, что зачастую разработчики процессоров используют его и для других целей. Хотя эти случаи и не относятся к операциям ввода-вывода, мы вынуждены упомянуть их здесь, для того чтобы их не путали с <span class="keyword">прерываниями</span>. Похожим образом процессор обрабатывает <span class="keyword">исключительные ситуации</span> и <span class="keyword">программные прерывания</span>.</p><div  class="lecture_mark" id="mark_57"></div><p  id="id_58">Для внешних <span class="keyword">прерываний</span> характерны следующие особенности.</p><div  class="lecture_mark" id="mark_58"></div><ul  id="id_59"><li>Внешнее <span class="keyword">прерывание</span> обнаруживается процессором между выполнением команд (или между итерациями в случае выполнения цепочечных команд).</li><li>Процессор при переходе на обработку <span class="keyword">прерывания</span> сохраняет часть своего состояния перед выполнением <b>следующей</b> команды.</li><li><span class="keyword">Прерывания</span> происходят <b>асинхронно</b> с работой процессора и <b>непредсказуемо</b>, программист никоим образом не может предугадать, в каком именно месте работы программы произойдет <span class="keyword">прерывание</span>.</li></ul><div  class="lecture_mark" id="mark_59"></div><p  id="id_63">Исключительные ситуации возникают во время выполнения процессором команды. К их числу относятся ситуации переполнения, деления на ноль, обращения к отсутствующей странице памяти и т. д. Для <span class="keyword">исключительных ситуаций</span> характерно следующее. </p><div  class="lecture_mark" id="mark_63"></div><ul  id="id_64"><li><span class="keyword">Исключительные ситуации</span> обнаруживаются процессором во время выполнения команд.</li><li>Процессор при переходе на выполнение обработки <span class="keyword">исключительной ситуации</span> сохраняет часть своего состояния перед выполнением текущей команды.</li><li><span class="keyword">Исключительные ситуации</span> возникают <b>синхронно</b> с работой процессора, но <b>непредсказуемо</b> для программиста, если только тот специально не заставил процессор делить некоторое число на ноль.</li></ul><div  class="lecture_mark" id="mark_64"></div><p  id="id_68"><span class="keyword">Программные прерывания</span> возникают после выполнения специальных команд, как правило, для выполнения привилегированных действий внутри системных вызовов. <span class="keyword">Программные прерывания</span> имеют следующие свойства.</p><div  class="lecture_mark" id="mark_68"></div><ul  id="id_69"><li><span class="keyword">Программное прерывание</span> происходит в результате выполнения специальной команды.</li><li>Процессор при выполнении <span class="keyword">программного прерывания</span> сохраняет свое состояние перед выполнением <b>следующей</b> команды.</li><li><span class="keyword">Программные прерывания</span>, естественно, возникают синхронно с работой процессора и <b>абсолютно предсказуемы</b> программистом.</li></ul><div  class="lecture_mark" id="mark_69"></div><p  id="id_73">Надо сказать, что реализация похожих механизмов обработки внешних <span class="keyword">прерываний</span>, <span class="keyword">исключительных ситуаций</span> и <span class="keyword">программных прерываний</span> лежит целиком на совести разработчиков процессоров. Существуют вычислительные системы, где все три ситуации обрабатываются по-разному.</p><div  class="lecture_mark" id="mark_73"></div><h4 >Прямой доступ к памяти (Direct Memory Access – DMA)</h4><p  id="id_74">Использование механизма <span class="keyword">прерываний</span> позволяет разумно загружать процессор в то время, когда устройство ввода-вывода занимается своей работой. Однако запись или чтение большого количества информации из <span class="keyword">адресного пространства ввода-вывода</span> (например, с диска) приводят к большому количеству операций ввода-вывода, которые должен выполнять процессор. Для освобождения процессора от операций последовательного вывода данных из оперативной памяти или последовательного ввода в нее был предложен механизм <span class="keyword">прямого доступа</span> внешних устройств к памяти – ПДП или Direct Memory Access – DMA. Давайте кратко рассмотрим, как работает этот механизм.</p><div  class="lecture_mark" id="mark_74"></div><p  id="id_75">Для того чтобы какое-либо устройство, кроме процессора, могло записать информацию в память или прочитать ее из памяти, необходимо чтобы это устройство могло забрать у процессора управление <span class="keyword">локальной магистралью</span> для выставления соответствующих сигналов на шины адреса, данных и управления. Для централизации эти обязанности обычно возлагаются не на каждое устройство в отдельности, а на специальный контроллер – контроллер <span class="keyword">прямого доступа к памяти</span>. Контроллер <span class="keyword">прямого доступа к памяти</span> имеет несколько спаренных линий – каналов DMA, которые могут подключаться к различным устройствам. Перед началом использования <span class="keyword">прямого доступа к памяти</span> этот контроллер необходимо запрограммировать, записав в его порты информацию о том, какой канал или каналы предполагается задействовать, какие операции они будут совершать, какой адрес памяти является начальным для передачи информации и какое количество информации должно быть передано. Получив по одной из линий – каналов DMA, сигнал запроса на передачу данных от внешнего устройства, контроллер по <span class="keyword">шине управления</span> сообщает процессору о желании взять на себя управление <span class="keyword">локальной магистралью</span>. Процессор, возможно, через некоторое время, необходимое для завершения его действий с магистралью, передает управление ею контроллеру DMA, известив его специальным сигналом. Контроллер DMA выставляет на <span class="keyword">адресную шину</span> адрес памяти для передачи очередной порции информации и по второй линии канала <span class="keyword">прямого доступа к памяти</span> сообщает устройству о готовности магистрали к передаче данных. После этого, используя <span class="keyword">шину данных</span> и <span class="keyword">шину управления</span>, контроллер DMA, устройство ввода-вывода и память осуществляют процесс обмена информацией. Затем контроллер <span class="keyword">прямого доступа 
к памяти</span> извещает процессор о своем отказе от управления магистралью, и тот берет руководящие функции на себя. При передаче большого количества данных весь процесс повторяется циклически. </p><div  class="lecture_mark" id="mark_75"></div><p  id="id_76">При <span class="keyword">прямом доступе к памяти</span> процессор и контроллер DMA по очереди управляют <span class="keyword">локальной магистралью</span>. Это, конечно, несколько снижает производительность процессора, так как при выполнении некоторых команд или при чтении очередной порции команд во внутренний кэш он должен поджидать освобождения магистрали, но в целом производительность вычислительной системы существенно возрастает. </p><div  class="lecture_mark" id="mark_76"></div><p  id="id_77">При подключении к системе нового устройства, которое умеет использовать <span class="keyword">прямой доступ к памяти</span>, обычно необходимо программно или аппаратно задать номер канала DMA, к которому будет приписано устройство. В отличие от <span class="keyword">прерываний</span>, где один номер <span class="keyword">прерывания</span> мог соответствовать нескольким устройствам, каналы DMA всегда находятся в монопольном владении устройств.</p><div  class="lecture_mark" id="mark_77"></div><h4 >Логические принципы организации ввода-вывода </h4><p  id="id_78">Рассмотренные в предыдущем разделе физические механизмы взаимодействия устройств ввода-вывода с вычислительной системой позволяют понять, почему разнообразные внешние устройства легко могут быть добавлены в существующие компьютеры. Все, что необходимо сделать пользователю при подключении нового устройства, – это отобразить порты устройства в соответствующее адресное пространство, определить, какой номер будет соответствовать <span class="keyword">прерыванию</span>, генерируемому устройством, и, если нужно, закрепить за устройством некоторый канал DMA. Для нормального функционирования hardware этого будет достаточно. Однако мы до сих пор ничего не сказали о том, как должна быть построена подсистема управления вводом-выводом в операционной системе для легкого и безболезненного добавления новых устройств и какие функции вообще обычно на нее возлагаются. </p><div  class="lecture_mark" id="mark_78"></div><h5 >Структура системы ввода-вывода</h5><p  id="id_79">Если поручить неподготовленному пользователю сконструировать систему ввода-вывода, способную работать со всем множеством внешних устройств, то, скорее всего, он окажется в ситуации, в которой находились биологи и зоологи до появления трудов Линнея [<a target="_blank" href="http://www.intuit.ru/department/os/osintro/popup.lit.html#6">Linnaes, 1789</a>]. Все устройства разные, отличаются по выполняемым функциям и своим характеристикам, и кажется, что принципиально невозможно создать систему, которая без больших постоянных переделок позволяла бы охватывать все многообразие видов. Вот перечень лишь нескольких направлений (далеко не полный), по которым различаются устройства.</p><div  class="lecture_mark" id="mark_79"></div><ul  id="id_80"><li>Скорость обмена информацией может варьироваться в диапазоне от нескольких байтов в секунду (клавиатура) до нескольких гигабайтов в секунду (сетевые карты).</li><li>Одни устройства могут использоваться несколькими процессами параллельно (являются разделяемыми), в то время как другие требуют монопольного захвата процессом.</li><li>Устройства могут запоминать выведенную информацию для ее последующего ввода или не обладать этой функцией. Устройства, запоминающие информацию, в свою очередь, могут дифференцироваться по формам доступа к сохраненной информации: обеспечивать к ней последовательный доступ в жестко заданном порядке или уметь находить и передавать только необходимую порцию данных.</li><li>Часть устройств умеет передавать данные только по одному байту последовательно (<span class="keyword">символьные устройства</span>), а часть устройств умеет передавать блок байтов как единое целое (<span class="keyword">блочные устройства</span>). </li><li>Существуют устройства, предназначенные только для ввода информации, устройства, предназначенные только для вывода информации, и устройства, которые могут выполнять и ввод, и вывод.</li></ul><div  class="lecture_mark" id="mark_80"></div><p  id="id_86">В области технического обеспечения удалось выделить несколько основных принципов взаимодействия внешних устройств с вычислительной системой, т. е. создать единый интерфейс для их подключения, возложив все специфические действия на контроллеры самих устройств. Тем самым конструкторы вычислительных систем переложили все хлопоты, связанные с подключением внешней аппаратуры, на разработчиков самой аппаратуры, заставляя их придерживаться определенного стандарта.</p><div  class="lecture_mark" id="mark_86"></div><p  id="id_87">Похожий подход оказался продуктивным и в области программного подключения устройств ввода-вывода. Подобно тому как Линнею удалось заложить основы систематизации знаний о растительном и животном мире, разделив все живое в природе на относительно небольшое число классов и отрядов, мы можем разделить устройства на относительно небольшое число типов, отличающихся по набору операций, которые могут быть ими выполнены, считая все остальные различия несущественными. Мы можем затем специфицировать интерфейсы между ядром операционной системы, осуществляющим некоторую общую политику ввода-вывода, и программными частями, непосредственно управляющими устройствами, для каждого из таких типов. Более того, разработчики операционных систем получают возможность освободиться от написания и тестирования этих специфических программных частей, получивших название <b>драйверов</b>, передав эту деятельность производителям самих внешних устройств. Фактически мы приходим к использованию принципа уровневого или слоеного построения системы управления вводом-выводом для операционной системы (см. <a href="">рис. 13.1</a>). </p><div  class="lecture_mark" id="mark_87"></div><p  id="id_88">Два нижних уровня этой слоеной системы составляет hardware: сами устройства, непосредственно выполняющие операции, и их контроллеры, служащие для организации совместной работы устройств и остальной вычислительной системы. <a name="keyword-context.12"></a><a name="keyword-context.13"></a>Следующий уровень составляют <span class="keyword_def">драйверы устройств ввода-вывода</span>, скрывающие от разработчиков операционных систем особенности функционирования конкретных приборов и обеспечивающие четко определенный интерфейс между hardware и вышележащим уровнем – уровнем <span class="keyword_def">базовой подсистемы ввода-вывода</span>, которая, в свою очередь, предоставляет механизм взаимодействия между драйверами и программной частью вычислительной системы в целом. </p><div  class="lecture_mark" id="mark_88"></div><p  align="left" id="id_89"><a name="image.13.1"></a><div><img src="13. Система управления вводом-выводом_files/13-10000.gif" alt="Структура системы ввода-вывода" width="548" height="373"></div><br><b>Рис. 13.1.</b> 
        Структура системы ввода-вывода</p><div  class="lecture_mark" id="mark_89"></div><p  id="id_90">В последующих разделах мы подробнее рассмотрим организацию и функции набора <span class="keyword">драйверов</span> и <span class="keyword">базовой подсистемы ввода-вывода</span>.</p><div  class="lecture_mark" id="mark_90"></div><h4 >Систематизация внешних устройств и интерфейс между 
базовой подсистемой ввода-вывода и драйверами </h4><p  id="id_91">Как и система видов Линнея, система типов устройств является далеко не полной и не строго выдержанной. Устройства обычно принято разделять по преобладающему типу интерфейса на следующие виды:</p><div  class="lecture_mark" id="mark_91"></div><ul  id="id_92"><li>символьные (клавиатура, модем, терминал и т. п.);</li><li>блочные (магнитные и оптические диски и ленты, и т. д.);</li><li>сетевые (сетевые карты);</li><li>все остальные (таймеры, графические дисплеи, телевизионные устройства, видеокамеры и т. п.);</li></ul><div  class="lecture_mark" id="mark_92"></div><p  id="id_97">Такое деление является весьма условным. В одних операционных системах сетевые устройства могут не выделяться в отдельную группу, в некоторых других – отдельные группы составляют звуковые устройства и видеоустройства и т. д. Некоторые группы в свою очередь могут разбиваться на подгруппы: подгруппа жестких дисков, подгруппа мышек, подгруппа принтеров. Нас такие детали не интересуют. Мы не ставим перед собой цель осуществить систематизацию всех возможных устройств, которые могут быть подключены к вычислительной системе. Единственное, для чего нам понадобится эта классификация, так это для иллюстрации того положения, что устройства могут быть разделены на группы по выполняемым ими функциям, и для понимания функций драйверов, и интерфейса между ними и <span class="keyword">базовой подсистемой ввода-вывода</span>.</p><div  class="lecture_mark" id="mark_97"></div><p  id="id_98">Для этого мы рассмотрим только две группы устройств: <span class="keyword">символьные</span> и <span class="keyword">блочные</span>. Как уже упоминалось в предыдущем разделе, <a name="keyword-context.14"></a><span class="keyword_def">символьные устройства</span> – это устройства, которые умеют передавать данные только последовательно, байт за байтом, а <a name="keyword-context.15"></a><span class="keyword_def">блочные устройства</span> – это устройства, которые могут передавать блок байтов как единое целое.</p><div  class="lecture_mark" id="mark_98"></div><p  id="id_99">К <span class="keyword">символьным устройствам</span> обычно относятся устройства ввода информации, которые спонтанно генерируют входные данные: клавиатура, мышь, модем, джойстик. К ним же относятся и устройства вывода информации, для которых характерно представление данных в виде линейного потока: принтеры, звуковые карты и т. д. По своей природе <span class="keyword">символьные устройства</span> обычно умеют совершать две общие операции: ввести символ (байт) и вывести символ (байт) – <span class="texample">get</span> и <span class="texample">put</span>.</p><div  class="lecture_mark" id="mark_99"></div><p  id="id_102">Для <span class="keyword">блочных устройств</span>, таких как магнитные и оптические диски, ленты и т. п. естественными являются операции чтения и записи блока информации – <span class="texample">read</span> и <span class="texample">write</span>, а также, для устройств прямого доступа, операция поиска требуемого блока информации – <span class="texample">seek</span>.</p><div  class="lecture_mark" id="mark_102"></div><p  id="id_106">Драйверы <span class="keyword">символьных</span> и <span class="keyword">блочных устройств</span> должны предоставлять <span class="keyword">базовой подсистеме ввода-вывода</span> функции для осуществления описанных общих операций. Помимо общих операций, некоторые устройства могут выполнять операции специфические, свойственные только им – например, звуковые карты умеют увеличивать или уменьшать среднюю громкость звучания, дисплеи умеют изменять свою разрешающую способность. Для выполнения таких специфических действий в интерфейс между <span class="keyword">драйвером</span> и <span class="keyword">базовой подсистемой ввода-вывода</span> обычно входит еще одна функция, позволяющая непосредственно передавать драйверу устройства произвольную команду с произвольными параметрами, что позволяет задействовать любую возможность драйвера без изменения интерфейса. В операционной системе Unix такая функция получила название <span class="texample">ioctl</span> (от input-output control).</p><div  class="lecture_mark" id="mark_106"></div><p  id="id_108">Помимо функций <span class="texample">read</span>, <span class="texample">write</span>, <span class="texample">seek</span> (для <span class="keyword">блочных устройств</span>), <span class="texample">get</span>, <span class="texample">put</span> (для <span class="keyword">символьных устройств</span>) и <span class="texample">ioctl</span>, в состав интерфейса обычно включают еще следующие функции.</p><div  class="lecture_mark" id="mark_108"></div><ul  id="id_115"><li>Функцию инициализации или повторной инициализации работы драйвера и устройства – <span class="texample">open</span>.</li><li>Функцию временного завершения работы с устройством (может, например, вызывать отключение устройства) – <span class="texample">close</span>.</li><li>Функцию опроса состояния устройства (если по каким-либо причинам работа с устройством производится методом опроса его состояния, например, в операционных системах Windows NT и Windows 9x так построена работа с принтерами через параллельный порт) – <span class="texample">poll</span>.</li><li>Функцию остановки драйвера, которая вызывается при остановке операционной системы или выгрузке драйвера из памяти, <span class="texample">halt</span>.</li></ul><div  class="lecture_mark" id="mark_115"></div><p  id="id_124">Существует еще ряд действий, выполнение которых может быть возложено на драйвер, но поскольку, как правило, это действия <span class="keyword">базовой подсистемы ввода-вывода</span>, мы поговорим о них в следующем разделе. Приведенные выше названия функций, конечно, являются условными и могут меняться от одной операционной системы к другой, но действия, выполняемые драйверами, характерны для большинства операционных систем, и соответствующие функции присутствуют в интерфейсах к ним.</p><div  class="lecture_mark" id="mark_124"></div><h4 >Функции базовой подсистемы ввода-вывода </h4><p  id="id_125"><span class="keyword">Базовая подсистема ввода-вывода</span> служит посредником между процессами вычислительной системы и набором драйверов. Системные вызовы для выполнения операций ввода-вывода трансформируются ею в вызовы функций необходимого драйвера устройства. Однако обязанности <span class="keyword">базовой подсистемы</span> не сводятся к выполнению только действий трансляции общего системного вызова в обращение к частной функции драйвера. <span class="keyword">Базовая подсистема</span> предоставляет вычислительной системе такие услуги, как поддержка <span class="keyword">блокирующихся</span>, <span class="keyword">неблокирующихся</span> и <span class="keyword">асинхронных системных вызовов</span>, <span class="keyword">буферизация</span> и <span class="keyword">кэширование</span> входных и выходных данных, 
осуществление spooling'a и монопольного захвата внешних устройств, обработка ошибок и <span class="keyword">прерываний</span>, возникающих при операциях ввода-вывода, планирование последовательности запросов на выполнение этих операций. Давайте остановимся на этих услугах подробнее.</p><div  class="lecture_mark" id="mark_125"></div><h5 >Блокирующиеся, неблокирующиеся и асинхронные 
системные вызовы</h5><p  id="id_126">Все системные вызовы, связанные с осуществлением операций ввода-вывода, можно разбить на три группы по способам реализации взаимодействия процесса и устройства ввода-вывода.</p><div  class="lecture_mark" id="mark_126"></div><ul  id="id_127"><li>К первой, наиболее привычной для большинства программистов группе относятся <span class="keyword">блокирующиеся системные вызовы</span>. Как следует из самого названия, применение такого вызова приводит к блокировке инициировавшего его процесса, т. е. процесс переводится операционной системой из состояния <b>исполнение</b> в состояние <b>ожидание</b>. Завершив выполнение всех операций ввода-вывода, предписанных системным вызовом, операционная система переводит процесс из состояния <b>ожидание</b> в состояние <b>готовность</b>. После того как процесс будет снова выбран для <b>исполнения</b>, в нем произойдет окончательный возврат из системного вызова. Типичным для применения такого системного вызова является случай, когда процессу необходимо получить от устройства строго определенное количество данных, без которых он не может выполнять работу далее.</li><li>Ко второй группе относятся <span class="keyword">неблокирующиеся системные вызовы</span>. Их название не совсем точно отражает суть дела. В простейшем случае процесс, применивший <span class="keyword">неблокирующийся вызов</span>, не переводится в состояние <b>ожидание</b> вообще. Системный вызов возвращается немедленно, выполнив предписанные ему операции ввода-вывода полностью, частично или не выполнив совсем, в зависимости от текущей ситуации (состояния устройства, наличия данных и т. д.). В более сложных ситуациях процесс может блокироваться, но условием его разблокирования является завершение всех необходимых операций или окончание некоторого промежутка времени. Типичным случаем применения <span class="keyword">неблокирующегося системного вызова</span> может являться периодическая проверка на поступление информации с клавиатуры при выполнении трудоемких расчетов.</li><li>К третьей группе относятся <span class="keyword">асинхронные системные вызовы</span>. Процесс, использовавший <span class="keyword">асинхронный системный вызов</span>, никогда в нем не блокируется. Системный вызов инициирует выполнение необходимых операций ввода-вывода и немедленно возвращается, после чего процесс продолжает свою регулярную деятельность. Об окончании завершения операции ввода-вывода операционная система впоследствии информирует процесс изменением значений некоторых переменных, передачей ему сигнала или сообщения или каким-либо иным способом. Необходимо четко понимать разницу между <span class="keyword">неблокирующимися</span> и <span class="keyword">асинхронными вызовами</span>. <span class="keyword">Неблокирующийся системный вызов</span> для выполнения операции <span class="texample">read</span> вернется немедленно, но может прочитать запрошенное количество байтов, меньшее 
количество или вообще ничего. <span class="keyword">Асинхронный системный вызов</span> для этой операции также вернется немедленно, но требуемое количество байтов рано или поздно будет прочитано в полном объеме.</li></ul><div  class="lecture_mark" id="mark_127"></div><h5 >Буферизация и кэширование </h5><p  id="id_132">Под <b>буфером</b> обычно понимается некоторая область памяти для запоминания информации при обмене данных между двумя устройствами, двумя процессами или процессом и устройством. Обмен информацией между двумя процессами относится к области кооперации процессов, и мы подробно рассмотрели его организацию в соответствующей лекции. Здесь нас будет интересовать использование буферов в том случае, когда одним из участников обмена является внешнее устройство. Существует три причины, приводящие к использованию буферов в <span class="keyword">базовой подсистеме ввода-вывода</span>.</p><div  class="lecture_mark" id="mark_132"></div><ul  id="id_133"><li>Первая причина <span class="keyword">буферизации</span> – это разные скорости приема и передачи информации, которыми обладают участники обмена. Рассмотрим, например, случай передачи потока данных от клавиатуры к модему. Скорость, с которой поставляет информацию клавиатура, определяется скоростью набора текста человеком и обычно существенно меньше скорости передачи данных модемом. Для того чтобы не занимать модем на все время набора текста, делая его недоступным для других процессов и устройств, целесообразно накапливать введенную информацию в буфере или нескольких буферах достаточного размера и отсылать ее через модем после заполнения буферов. </li><li>Вторая причина <span class="keyword">буферизации</span> – это разные объемы данных, которые могут быть приняты или получены участниками обмена единовременно. Возьмем другой пример. Пусть информация поставляется модемом и записывается на жесткий диск. Помимо обладания разными скоростями совершения операций, модем и жесткий диск представляют собой устройства разного типа. Модем является <span class="keyword">символьным устройством</span> и выдает данные байт за байтом, в то время как диск является <span class="keyword">блочным устройством</span> и для проведения операции записи для него требуется накопить необходимый блок данных в буфере. Здесь также можно применять более одного буфера. После заполнения первого буфера модем начинает заполнять второй, одновременно с записью первого на жесткий диск. Поскольку скорость работы жесткого диска в тысячи раз больше, чем скорость работы модема, к моменту заполнения второго буфера операция записи первого будет завершена, и 

модем снова сможет заполнять первый буфер одновременно с записью второго на диск. </li><li>Третья причина <span class="keyword">буферизации</span> связана с необходимостью копирования информации из приложений, осуществляющих ввод-вывод, в буфер ядра операционной системы и обратно. Допустим, что некоторый пользовательский процесс пожелал вывести информацию из своего адресного пространства на внешнее устройство. Для этого он должен выполнить системный вызов с обобщенным названием write, передав в качестве параметров адрес области памяти, где расположены данные, и их объем. Если внешнее устройство временно занято, то возможна ситуация, когда к моменту его освобождения содержимое нужной области окажется испорченным (например, при использовании асинхронной формы системного вызова). Чтобы избежать возникновения подобных ситуаций, проще всего в начале работы системного вызова скопировать необходимые данные в буфер ядра операционной системы, постоянно находящийся в оперативной памяти, и выводить их на устройство из этого буфера.</li></ul><div  class="lecture_mark" id="mark_133"></div><p  id="id_137">Под словом <b>кэш</b> (cache – "тайник, запас"), этимологию которого мы не будем здесь рассматривать, обычно понимают область быстрой памяти, содержащую копию данных, расположенных где-либо в более медленной памяти, предназначенную для ускорения работы вычислительной системы. Мы с вами сталкивались с этим понятием при рассмотрении иерархии памяти. В <span class="keyword">базовой подсистеме ввода-вывода</span> не следует смешивать два понятия, <span class="keyword">буферизацию</span> и <span class="keyword">кэширование</span>, хотя зачастую для выполнения этих функций отводится одна и та же область памяти. Буфер часто содержит единственный набор данных, существующий в системе, в то время как кэш по определению содержит копию данных, существующих где-нибудь еще. Например, буфер, используемый базовой подсистемой для копирования данных из пользовательского пространства процесса при выводе на диск, может в свою очередь применяться как кэш для этих данных, если операции модификации и повторного чтения данного блока выполняются достаточно часто.</p><div  class="lecture_mark" id="mark_137"></div><p  id="id_138">Функции <span class="keyword">буферизации</span> и <span class="keyword">кэширования</span> не обязательно должны быть локализованы в <span class="keyword">базовой подсистеме ввода-вывода</span>. Они могут быть частично реализованы в драйверах и даже в <span class="keyword">контроллерах устройств</span>, скрытно по отношению к <span class="keyword">базовой подсистеме</span>.</p><div  class="lecture_mark" id="mark_138"></div><h5 >Spooling и захват устройств </h5><p  id="id_139">О понятии <b>spooling</b> мы говорили в первой лекции нашего курса, как о механизме, впервые позволившем совместить реальные операции ввода-вывода одного задания с выполнением другого задания. Теперь мы можем определить это понятие более точно. Под словом spool мы подразумеваем буфер, содержащий входные или выходные данные для устройства, на котором следует избегать чередования его использования (возникновения interleaving – см. раздел "Interleaving, race condition и взаимоисключения" лекции 5) различными процессами. Правда, в современных вычислительных системах spool для ввода данных практически не используется, а в основном предназначен для накопления выходной информации. </p><div  class="lecture_mark" id="mark_139"></div><p  id="id_140">Рассмотрим в качестве внешнего устройства принтер. Хотя принтер не может печатать информацию, поступающую одновременно от нескольких процессов, может оказаться желательным разрешить процессам совершать вывод на принтер параллельно. Для этого операционная система вместо передачи информации напрямую на принтер накапливает выводимые данные в буферах на диске, организованных в виде отдельного spool-файла для каждого процесса. После завершения некоторого процесса соответствующий ему spool-файл ставится в очередь для реальной печати. Механизм, обеспечивающий подобные действия, и получил название spooling.</p><div  class="lecture_mark" id="mark_140"></div><p  id="id_141">В некоторых операционных системах вместо использования spooling для устранения race condition применяется механизм монопольного захвата устройств процессами. Если устройство свободно, то один из процессов может получить его в монопольное распоряжение. При этом все другие процессы при попытке осуществления операций над этим устройством будут либо блокированы (переведены в состояние <b>ожидание</b>), либо получат информацию о невозможности выполнения операции до тех пор, пока процесс, захвативший устройство, не завершится или явно не сообщит операционной системе о своем отказе от его использования.</p><div  class="lecture_mark" id="mark_141"></div><p  id="id_142">Обеспечение spooling и механизма захвата устройств является прерогативой <span class="keyword">базовой подсистемы ввода-вывода</span>.</p><div  class="lecture_mark" id="mark_142"></div><h5 >Обработка прерываний и ошибок </h5><p  id="id_143">Если при работе с внешним устройством вычислительная система не пользуется методом опроса его состояния, а задействует механизм <span class="keyword">прерываний</span>, то при возникновении <span class="keyword">прерывания</span>, как мы уже говорили раньше, процессор, частично сохранив свое состояние, передает управление специальной программе обработки <span class="keyword">прерывания</span>. Мы уже рассматривали действия операционной системы над процессами, происходящими при возникновении <span class="keyword">прерывания</span>, в разделе "Переключение контекста" лекции 2, где после возникновения <span class="keyword">прерывания</span> осуществлялись следующие действия: сохранение контекста, обработка <span class="keyword">прерывания</span>, планирование использования процессора, восстановление контекста. Тогда мы обращали больше внимания на действия, связанные с сохранением и восстановлением контекста и планированием использования процессора. Теперь давайте подробнее остановимся на том, что скрывается за словами "обработка <span class="keyword">прерывания</span>".</p><div  class="lecture_mark" id="mark_143"></div><p  id="id_144">Одна и та же процедура обработки <span class="keyword">прерывания</span> может применяться для нескольких устройств ввода-вывода (например, если эти устройства используют одну линию <span class="keyword">прерываний</span>, идущую от них к <span class="keyword">контроллеру прерываний</span>), поэтому первое действие собственно программы обработки состоит в определении того, какое именно устройство выдало <span class="keyword">прерывание</span>. Зная устройство, мы можем выявить процесс, который инициировал выполнение соответствующей операции. Поскольку <span class="keyword">прерывание</span> возникает как при удачном, так и при неудачном ее выполнении, следующее, что мы должны сделать, – это определить успешность завершения операции, проверив значение <b>бита ошибки</b> в <span class="keyword">регистре состояния</span> устройства. В некоторых случаях операционная система может предпринять определенные действия, направленные на компенсацию 
возникшей ошибки. Например, в случае возникновения ошибки чтения с гибкого диска можно попробовать несколько раз повторить выполнение команды. Если компенсация ошибки невозможна, то операционная система впоследствии известит об этом процесс, запросивший выполнение операции, (например, специальным кодом возврата из системного вызова). Если этот процесс был заблокирован до выполнения завершившейся операции, то операционная система переводит его в состояние <b>готовность</b>. При наличии других неудовлетворенных запросов к освободившемуся устройству операционная система может инициировать выполнение следующего запроса, одновременно известив устройство, что <span class="keyword">прерывание</span> обработано. На этом, собственно, обработка <span class="keyword">прерывания</span> заканчивается, и система может приступать к планированию использования процессора.</p><div  class="lecture_mark" id="mark_144"></div><p  id="id_145">Действия по обработке <span class="keyword">прерывания</span> и компенсации возникающих ошибок могут быть частично переложены на плечи соответствующего драйвера. Для этого в состав интерфейса между <span class="keyword">драйвером</span> и <span class="keyword">базовой подсистемой ввода-вывода</span> добавляют еще одну функцию – функцию обработки <span class="keyword">прерывания</span>   <span class="texample">intr</span>.</p><div  class="lecture_mark" id="mark_145"></div><h5 >Планирование запросов </h5><p  id="id_147">При использовании <span class="keyword">неблокирующегося системного вызова</span> может оказаться, что нужное устройство уже занято выполнением некоторых операций. В этом случае <span class="keyword">неблокирующийся вызов</span> может немедленно вернуться, не выполнив запрошенных команд. При организации запроса на совершение операций ввода-вывода с помощью <span class="keyword">блокирующегося</span> или <span class="keyword">асинхронного вызова</span> занятость устройства приводит к необходимости постановки запроса в очередь к данному устройству. В результате с каждым устройством оказывается связан список неудовлетворенных запросов процессов, находящихся в состоянии <b>ожидания</b>, и запросов, выполняющихся в асинхронном режиме. Состояние <b>ожидание</b> расщепляется на набор очередей процессов, дожидающихся различных устройств ввода-вывода (или ожидающих изменения состояний различных объектов – семафоров, очередей сообщений, условных переменных в мониторах и т. д. – см. лекцию 6).</p><div  class="lecture_mark" id="mark_147"></div><p  id="id_148">После завершения выполнения текущего запроса операционная система (по ходу обработки возникшего <span class="keyword">прерывания</span>) должна решить, какой из запросов в списке должен быть удовлетворен следующим, и инициировать его исполнение. Точно так же, как для выбора очередного процесса на исполнение из списка готовых нам приходилось осуществлять краткосрочное планирование процессов, здесь нам необходимо осуществлять планирование применения устройств, пользуясь каким-либо алгоритмом этого планирования. Критерии и цели такого планирования мало отличаются от критериев и целей планирования процессов.</p><div  class="lecture_mark" id="mark_148"></div><p  id="id_149">Задача планирования использования устройства обычно возлагается на <span class="keyword">базовую подсистему ввода-вывода</span>, однако для некоторых устройств лучшие алгоритмы планирования могут быть тесно связаны с деталями их внутреннего функционирования. В таких случаях операция планирования переносится внутрь драйвера соответствующего устройства, так как эти детали скрыты от базовой подсистемы. Для этого в интерфейс драйвера добавляется еще одна специальная функция, которая осуществляет выбор очередного запроса, – функция <span class="texample">strategy</span>.</p><div  class="lecture_mark" id="mark_149"></div><p  id="id_151">В следующем разделе мы рассмотрим некоторые алгоритмы планирования, связанные с удовлетворением запросов, на примере жесткого диска.</p><div  class="lecture_mark" id="mark_151"></div><h4 >Алгоритмы планирования запросов к жесткому диску </h4><p  id="id_152">Прежде чем приступить к непосредственному изложению самих алгоритмов, давайте вспомним внутреннее устройство жесткого диска и определим, какие параметры запросов мы можем использовать для планирования.</p><div  class="lecture_mark" id="mark_152"></div><h5 >Строение жесткого диска и параметры планирования</h5><p  id="id_153">Современный жесткий магнитный диск представляет собой набор круглых пластин, находящихся на одной оси и покрытых с одной или двух сторон специальным магнитным слоем (см. <a href="">рис. 13.2</a>). Около каждой рабочей поверхности каждой пластины расположены магнитные головки для чтения и записи информации. Эти головки присоединены к специальному рычагу, который может перемещать весь блок головок над поверхностями пластин как единое целое. Поверхности пластин разделены на концентрические кольца, внутри которых, собственно, и может храниться информация. Набор концентрических колец на всех пластинах для одного положения головок (т. е. все кольца, равноудаленные от оси) образует цилиндр. Каждое кольцо внутри цилиндра получило название дорожки (по одной или две дорожки на каждую пластину). Все дорожки делятся на равное число секторов. Количество дорожек, цилиндров и секторов может варьироваться от одного жесткого диска к другому в достаточно широких пределах. Как правило, сектор является минимальным объемом информации, которая может быть прочитана с диска за один раз.</p><div  class="lecture_mark" id="mark_153"></div><p  id="id_154">При работе диска набор пластин вращается вокруг своей оси с высокой скоростью, подставляя по очереди под головки соответствующих дорожек все их сектора. Номер сектора, номер дорожки и номер цилиндра однозначно определяют положение данных на жестком диске и, наряду с типом совершаемой операции – чтение или запись, полностью характеризуют часть запроса, связанную с устройством, при обмене информацией в объеме одного сектора.</p><div  class="lecture_mark" id="mark_154"></div><p  align="left" id="id_155"><a name="image.13.2"></a><div><img src="13. Система управления вводом-выводом_files/13-20000.gif" alt="Схема жесткого диска" width="552" height="387"></div><br><b>Рис. 13.2.</b> 
        Схема жесткого диска</p><div  class="lecture_mark" id="mark_155"></div><p  id="id_156">При планировании использования жесткого диска естественным параметром планирования является время, которое потребуется для выполнения очередного запроса. Время, необходимое для чтения или записи определенного сектора на определенной дорожке определенного цилиндра, можно разделить на две составляющие: время обмена информацией между магнитной головкой и компьютером, которое обычно не зависит от положения данных и определяется скоростью их передачи (transfer speed), и время, необходимое для позиционирования головки над заданным сектором, – время позиционирования (positioning time). Время позиционирования, в свою очередь, состоит из времени, необходимого для перемещения головок на нужный цилиндр, – времени поиска (seek time) и времени, которое требуется для того, чтобы нужный сектор довернулся под головку, – задержки на вращение (rotational latency). Времена поиска пропорциональны разнице между номерами цилиндров предыдущего и планируемого запросов, и их легко сравнивать. Задержка на вращение определяется довольно сложными соотношениями между номерами цилиндров и секторов предыдущего и планируемого запросов и скоростями вращения диска и перемещения головок. Без знания соотношения этих скоростей сравнение становится невозможным. Поэтому естественно, что набор параметров планирования сокращается до времени поиска различных запросов, определяемого текущим положением головки и номерами требуемых цилиндров, а разницей в задержках на вращение пренебрегают.</p><div  class="lecture_mark" id="mark_156"></div><h5 >Алгоритм First Come First Served (FCFS) </h5><p  id="id_157">Простейшим алгоритмом, к которому мы уже должны были привыкнуть, является <a name="keyword-context.16"></a>алгоритм <span class="keyword_def">First Come First Served (FCFS)</span> – первым пришел, первым обслужен. Все запросы организуются в очередь FIFO и обслуживаются в порядке поступления. Алгоритм прост в реализации, но может приводить к достаточно длительному общему времени обслуживания запросов. Рассмотрим пример. Пусть у нас на диске из 100 цилиндров (от 0 до 99) есть следующая очередь запросов: 23, 67, 55, 14, 31, 7, 84, 10 и головки в начальный момент находятся на 63-м цилиндре. Тогда положение головок будет меняться следующим образом:</p><div  class="lecture_mark" id="mark_157"></div><div  class="example"><pre>
63<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">23<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">67<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">55<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">14<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">31<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">7<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">84<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">10
</pre></div><p  id="id_159">и всего головки переместятся на 329 цилиндров. Неэффективность алгоритма хорошо иллюстрируется двумя последними перемещениями с 7 цилиндра через весь диск на 84 цилиндр и затем опять через весь диск на цилиндр 10. Простая замена порядка двух последних перемещений (7<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">10<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">84) позволила бы существенно сократить общее время обслуживания запросов. Поэтому давайте перейдем к рассмотрению другого алгоритма.</p><div  class="lecture_mark" id="mark_159"></div><h5 >Алгоритм Short Seek Time First (SSTF) </h5><p  id="id_160">Как мы убедились, достаточно разумным является первоочередное обслуживание запросов, данные для которых лежат рядом с текущей позицией головок, а уж затем далеко отстоящих. Алгоритм <span class="keyword">Short Seek Time First (SSTF)</span> – короткое время поиска первым – как раз и исходит из этой позиции. Для очередного обслуживания будем выбирать запрос, данные для которого лежат наиболее близко к текущему положению магнитных головок. Естественно, что при наличии равноудаленных запросов решение о выборе между ними может приниматься исходя из различных соображений, например по алгоритму <span class="keyword">FCFS</span>. Для предыдущего примера алгоритм даст такую последовательность положений головок:</p><div  class="lecture_mark" id="mark_160"></div><div  class="example"><pre>
63<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">67<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">55<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">31<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">23<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">14<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">10<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">7<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">84
</pre></div><p  id="id_162">и всего головки переместятся на 141 цилиндр. Заметим, что наш алгоритм похож на алгоритм SJF планирования процессов, если за аналог оценки времени очередного CPU burst процесса выбирать расстояние между текущим положением головки и положением, необходимым для удовлетворения запроса. И точно так же, как алгоритм SJF, он может приводить к длительному откладыванию выполнения какого-либо запроса. Необходимо вспомнить, что запросы в очереди могут появляться в любой момент времени. Если у нас все запросы, кроме одного, постоянно группируются в области с большими номерами цилиндров, то этот один запрос может находиться в очереди неопределенно долго. </p><div  class="lecture_mark" id="mark_162"></div><p  id="id_163">Точный алгоритм SJF являлся оптимальным для заданного набора процессов с заданными временами CPU burst. Очевидно, что алгоритм <span class="keyword">SSTF</span> не является оптимальным. Если мы перенесем обслуживание запроса 67-го цилиндра в промежуток между запросами 7-го и 84-го цилиндров, мы уменьшим общее время обслуживания. Это наблюдение приводит нас к идее целого семейства других алгоритмов – алгоритмов сканирования.</p><div  class="lecture_mark" id="mark_163"></div><h5 >Алгоритмы сканирования (SCAN, C-SCAN, LOOK, C-LOOK) </h5><p  id="id_164"><a name="keyword-context.17"></a>В простейшем из алгоритмов сканирования – <span class="keyword_def">SCAN</span> – головки постоянно перемещаются от одного края диска до другого, по ходу дела обслуживая все встречающиеся запросы. По достижении другого края направление движения меняется, и все повторяется снова. Пусть в предыдущем примере в начальный момент времени головки двигаются в направлении уменьшения номеров цилиндров. Тогда мы и получим порядок обслуживания запросов, подсмотренный в конце предыдущего раздела. Последовательность перемещения головок выглядит следующим образом:</p><div  class="lecture_mark" id="mark_164"></div><div  class="example"><pre>
63<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">55<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">31<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">23<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">14<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">10<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px"><img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">7<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">0<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">67<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">84
</pre></div><p  id="id_166">и всего головки переместятся на 147 цилиндров.</p><div  class="lecture_mark" id="mark_166"></div><p  id="id_167">Если мы знаем, что обслужили последний попутный запрос в направлении движения головок, то мы можем не доходить до края диска, а сразу изменить направление движения на обратное:</p><div  class="lecture_mark" id="mark_167"></div><div  class="example"><pre>
63<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">55<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">31<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">23<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">14<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">10<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">7<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">67<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">84
</pre></div><p  id="id_169">и всего головки переместятся на 133 цилиндра. Полученная модификация алгоритма <span class="keyword">SCAN</span> получила название <span class="keyword">LOOK</span>.</p><div  class="lecture_mark" id="mark_169"></div><p  id="id_170">Допустим, что к моменту изменения направления движения головки в алгоритме <span class="keyword">SCAN</span>, т. е. когда головка достигла одного из краев диска, у этого края накопилось большое количество новых запросов, на обслуживание которых будет потрачено достаточно много времени (не забываем, что надо не только перемещать головку, но еще и передавать прочитанные данные!). Тогда запросы, относящиеся к другому краю диска и поступившие раньше, будут ждать обслуживания несправедливо долго. Для сокращения времени ожидания запросов применяется другая модификация алгоритма <span class="keyword">SCAN</span> – циклическое сканирование. Когда головка достигает одного из краев диска, она без чтения попутных запросов (иногда существенно быстрее, чем при выполнении обычного поиска цилиндра) перемещается на другой край, откуда вновь начинает движение в прежнем направлении. Для этого алгоритма, получившего название <span class="keyword">C-SCAN</span>, последовательность перемещений будет выглядеть так:</p><div  class="lecture_mark" id="mark_170"></div><div  class="example"><pre>
63<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">55<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">31<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">23<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">14<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">10<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">7<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">0<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">99<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">84<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">67
</pre></div><p  id="id_172">По аналогии с алгоритмом <span class="keyword">LOOK</span> для алгоритма <span class="keyword">SCAN</span> можно предложить и алгоритм <span class="keyword">C-LOOK</span> для алгоритма <span class="keyword">C-SCAN</span>:</p><div  class="lecture_mark" id="mark_172"></div><div  class="example"><pre>
63<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">55<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">31<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">23<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">14<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">10<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">7<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">84<img src="13. Система управления вводом-выводом_files/srarr000.gif" width="15" height="18" border="0" alt="" style="position: relative; top: 2px">67
</pre></div><p  id="id_174">Существуют и другие разновидности алгоритмов сканирования, и совсем другие алгоритмы, но мы на этом закончим, ибо было сказано: "И еще раз говорю: никто не обнимет необъятного".</p><div  class="lecture_mark" id="mark_174"></div><h3 >Заключение </h3><p  id="id_175">Функционирование любой вычислительной системы обычно сводится к выполнению двух видов работы: обработка информации и операции по осуществлению ее ввода-вывода. С точки зрения операционной системы "обработкой информации" являются только операции, совершаемые процессором над данными, находящимися в памяти на уровне иерархии не ниже чем оперативная память. Все остальное относится к "операциям ввода-вывода", т. е. к обмену информацией с внешними устройствами.</p><div  class="lecture_mark" id="mark_175"></div><p  id="id_176">Несмотря на все многообразие устройств ввода-вывода, управление их работой и обмен информацией с ними строятся на относительно небольшом количестве принципов. Основными физическими принципами построения системы ввода-вывода являются следующие: возможность использования различных адресных пространств для памяти и устройств ввода-вывода; подключение устройств к системе через <span class="keyword">порты ввода-вывода</span>, отображаемые в одно из адресных пространств; существование механизма <span class="keyword">прерывания</span> для извещения процессора о завершении операций ввода-вывода; наличие механизма <span class="keyword">прямого доступа устройств к памяти</span>, минуя процессор.</p><div  class="lecture_mark" id="mark_176"></div><p  id="id_177">Механизм, подобный механизму <span class="keyword">прерываний</span>, может использоваться также и для обработки исключений и <span class="keyword">программных прерываний</span>, однако это целиком лежит на совести разработчиков вычислительных систем. </p><div  class="lecture_mark" id="mark_177"></div><p  id="id_178">Для построения программной части системы ввода-вывода характерен "слоеный" подход. Для непосредственного взаимодействия с hardware используются драйверы устройств, скрывающие от остальной части операционной системы все особенности их функционирования. Драйверы устройств через жестко определенный интерфейс связаны с <span class="keyword">базовой подсистемой ввода-вывода</span>, в обязанности которой входят: организация работы <span class="keyword">блокирующихся</span>, <span class="keyword">неблокирующихся</span> и <span class="keyword">асинхронных системных вызовов</span>, <span class="keyword">буферизация</span> и <span class="keyword">кэширование</span> входных и выходных данных, осуществление spooling и монопольного захвата внешних устройств, обработка ошибок и <span class="keyword">прерываний</span>, возникающих при операциях ввода-вывода, планирование последовательности запросов на выполнение этих операций. Доступ к <span class="keyword">базовой подсистеме ввода-вывода</span> осуществляется посредством системных вызовов.</p><div  class="lecture_mark" id="mark_178"></div><p  id="id_179">Часть функций базовой подсистемы может быть делегирована <span class="keyword">драйверам</span> устройств и самим устройствам ввода-вывода.</p><div  class="lecture_mark" id="mark_179"></div>


	</td>
	</tr>
	<tr><td height="8"><img src="13. Система управления вводом-выводом_files/empty000.gif" width="1" height="8"></td></tr>
	</table>
	<!-- /content -->

</td>
<td><img src="13. Система управления вводом-выводом_files/empty000.gif" width="8" height="1"></td>
</tr>
</table>
<!-- /bottom -->
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td class="orang" height="1"><img src="13. Система управления вводом-выводом_files/empty000.gif" width="1" height="1"></td></tr>
<td class="ltxt" align=center>&copy; INTUIT.ru, 2003-2008. Все права защищены.</td>
</tr>
</table>
<!-- /bottom -->

<script src="13. Система управления вводом-выводом_files/urchin00.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-3475067-1";
urchinTracker();
</script></body>
</html>


<!-- This document saved from http://www.intuit.ru/department/os/osintro/13/osintro_13.html -->
