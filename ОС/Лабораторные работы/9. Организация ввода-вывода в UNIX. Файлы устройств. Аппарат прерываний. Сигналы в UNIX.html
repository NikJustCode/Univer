
<!-- saved from url=(0075)http://www.intuit.ru/department/os/osintropractice/9/osintropractice_9.html -->
<HTML><HEAD><META http-equiv="Content-Type" content="text/html; charset=windows-1251">

<TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<LINK href="./9. Организация ввода-вывода в UNIX. Файлы устройств. Аппарат прерываний. Сигналы в UNIX_files/printable.css" type="text/css" rel="stylesheet">
</HEAD><BODY leftmargin="6" topmargin="6" marginheight="6" marginwidth="6">

<DIV align="left">
<SPAN style="color: #000000; font-weight: bold;">
&nbsp;&nbsp;
<SPAN style="font-size:12pt;">Интернет-Университет Информационных Технологий</SPAN>
</SPAN>
</DIV>

&nbsp;&nbsp;
<SPAN align="rright" style="color: #330066; text-decoration:underline;">http://www.INTUIT.ru</SPAN>


<TABLE border="0" cellpadding="0" cellspacing="0" width="100%">
<TBODY><TR><TD height="8" colspan="3"><IMG src="./9. Организация ввода-вывода в UNIX. Файлы устройств. Аппарат прерываний. Сигналы в UNIX_files/empty.gif" width="1" height="8"></TD></TR>
<TR><TD class="orang" height="1" colspan="3"><IMG src="./9. Организация ввода-вывода в UNIX. Файлы устройств. Аппарат прерываний. Сигналы в UNIX_files/empty.gif" width="1" height="1"></TD></TR>
<TR><TD height="8" colspan="3"><IMG src="./9. Организация ввода-вывода в UNIX. Файлы устройств. Аппарат прерываний. Сигналы в UNIX_files/empty.gif" width="1" height="8"></TD></TR>
<TR valign="top">
<TD><IMG src="./9. Организация ввода-вывода в UNIX. Файлы устройств. Аппарат прерываний. Сигналы в UNIX_files/empty.gif" width="8" height="1"></TD>
<TD>
	<!-- content -->
	<TABLE border="0" cellpadding="0" cellspacing="0" width="100%">
	<TBODY><TR><TD class="head">Основы операционных систем. Практикум</TD></TR>
<TR><TD height="4"><IMG src="./9. Организация ввода-вывода в UNIX. Файлы устройств. Аппарат прерываний. Сигналы в UNIX_files/empty.gif" width="1" height="4"></TD></TR>
	<TR><TD class="orang" height="1"><IMG src="./9. Организация ввода-вывода в UNIX. Файлы устройств. Аппарат прерываний. Сигналы в UNIX_files/empty.gif" width="1" height="1"></TD></TR>
	<TR><TD height="8"><IMG src="./9. Организация ввода-вывода в UNIX. Файлы устройств. Аппарат прерываний. Сигналы в UNIX_files/empty.gif" width="1" height="8"></TD></TR>
	<TR><TD><SPAN class="headsub">


9. Лекция:

 Организация ввода-вывода в UNIX. Файлы устройств. Аппарат прерываний. Сигналы в UNIX: версия для печати и PDA</SPAN>

<BR>
<SPAN class="rtxt">Понятие виртуальной файловой системы. Операции над файловыми системами. Монтирование файловых систем. Блочные, символьные устройства. Понятие драйвера. Блочные, символьные драйверы, драйверы низкого уровня. Файловый интерфейс. Аппаратные прерывания (interrupt), исключения (exception), программные прерывания (trap, software interrupt). Их обработка. Понятие сигнала. Способы возникновения сигналов и виды их обработки. Понятия группы процессов, сеанса, лидера группы, лидера сеанса, управляющего терминала сеанса. Системные вызовы getpgrp(), setpgrp(), getpgid(), setpgid(), getsid(), setsid() Системный вызов kill и команда kill(). Системный вызов signal(). Установка собственного обработчика сигнала. Восстановление предыдущей реакции на сигнал. Сигналы SIGUSR1 и SIGUSR2. Использование сигналов для синхронизации процессов. Завершение порожденного процесса. Системный вызов waitpid(). Сигнал SIGCHLD. Возникновение сигнала SIGPIPE при попытке записи в pipe или FIFO, который никто не собирается читать. Понятие о надежности сигналов. POSIX-функции для работы с сигналами.
</SPAN>

</TD></TR>

	<TR><TD height="8"><IMG src="./9. Организация ввода-вывода в UNIX. Файлы устройств. Аппарат прерываний. Сигналы в UNIX_files/empty.gif" width="1" height="8"></TD></TR>
	<TR><TD class="orang" height="1"><IMG src="./9. Организация ввода-вывода в UNIX. Файлы устройств. Аппарат прерываний. Сигналы в UNIX_files/empty.gif" width="1" height="1"></TD></TR>
	<TR><TD height="8"><IMG src="./9. Организация ввода-вывода в UNIX. Файлы устройств. Аппарат прерываний. Сигналы в UNIX_files/empty.gif" width="1" height="8"></TD></TR>
	<TR><TD>


<A name="sect1"></A><H3>Понятие виртуальной файловой системы </H3><P id="id_1">Cеминары 11–12 были посвящены устройству файловой системы s5fs. Существуют и другие файловые системы, имеющие архитектуру, отличную от архитектуры s5fs (иные способы отображения файла на пространство физического носителя, иное построение директорий и т.д.). Современные версии UNIX-подобных операционных систем умеют работать с разнообразными файловыми системами, различающимися своей организацией. Такая возможность достигается с помощью разбиения каждой файловой системы на зависимую и независимую от конкретной реализации части, подобно тому, как в лекции 13, посвященной вопросам ввода-вывода, мы отделяли аппаратно-зависимые части для каждого устройства – <SPAN class="keyword">драйверы</SPAN> – от общей базовой подсистемы ввода-вывода. <A name="keyword-context.1"></A>Независимые части всех файловых систем одинаковы и представляют для всех остальных элементов ядра абстрактную файловую систему, которую принято называть <SPAN class="keyword_def">виртуальной файловой системой</SPAN>. Зависимые части для различных файловых систем могут встраиваться в ядро на этапе компиляции, либо добавляться к нему динамически по мере необходимости, без перекомпиляции системы (как в системах с микроядерной архитектурой).</P><DIV class="lecture_mark" id="mark_1"></DIV><P id="id_2">Рассмотрим схематично устройство <SPAN class="keyword">виртуальной файловой системы</SPAN>. В файловой системе s5fs данные о физическом расположении и атрибутах каждого открытого файла представлялись в операционной системе структурой данных в таблице индексных узлов открытых файлов (см. семинар 11–12, раздел "Системные вызовы и команды для выполнения операций над файлами и директориями"), содержащей информацию из индексного узла файла во вторичной памяти. В <SPAN class="keyword">виртуальной файловой системе</SPAN>, в отличие от s5fs, каждый файл характеризуется не индексным узлом inode, а некоторым <SPAN class="keyword">виртуальным узлом vnode</SPAN>. Соответственно, вместо таблицы индексных узлов открытых файлов в операционной системе появляется <SPAN class="keyword">таблица виртуальных узлов открытых файлов</SPAN>. При открытии файла в операционной системе для него заполняется (если, конечно, не был заполнен раньше) элемент <SPAN class="keyword">таблицы виртуальных узлов открытых файлов</SPAN>, в котором хранятся, как минимум, тип файла, счетчик числа открытий файла, <B>указатель</B> на реальные физические данные файла и, <B>обязательно, указатель</B> на таблицу системных вызовов, совершающих операции над файлом, – <SPAN class="keyword">таблицу операций</SPAN>. Реальные физические данные файла (равно как и способ расположения файла на диске и т.п.) и системные вызовы, реально выполняющие операции над файлом, уже не являются элементами <SPAN class="keyword">виртуальной файловой системы</SPAN>. Они относятся к одной из зависимых частей файловой системы, так как определяются ее конкретной реализацией. </P><DIV class="lecture_mark" id="mark_2"></DIV><P id="id_3">При выполнении операций над файлами по <SPAN class="keyword">таблице операций</SPAN>, чей адрес содержится в <SPAN class="keyword">vnode</SPAN>, определяется системный вызов, который будет на самом деле выполнен над реальными физическими данными файла, чей адрес также находится в <SPAN class="keyword">vnode</SPAN>. В случае с s5fs данные, на которые ссылается <SPAN class="keyword">vnode</SPAN>, – это как раз данные индексного узла, рассмотренные на семинарах 11–12 и на лекции 12. Заметим, что <SPAN class="keyword">таблица операций</SPAN> является общей для всех файлов, принадлежащих одной и той же файловой системе.</P><DIV class="lecture_mark" id="mark_3"></DIV><A name="sect2"></A><H3>Операции над файловыми системами. Монтирование файловых систем </H3><P id="id_4">В материалах семинаров 11–12 рассматривалась только одна файловая система, расположенная в одном разделе физического носителя. Как только мы переходим к сосуществованию нескольких файловых систем в рамках одной операционной системы, встает вопрос о логическом объединении структур этих файловых систем. При работе операционной системы нам изначально доступна лишь одна, так называемая корневая, файловая система. Прежде, чем приступить к работе с файлом, лежащим в некоторой другой файловой системе, мы должны встроить ее в уже существующий ациклический граф файлов. Эта операция – операция над файловой системой – называется <SPAN class="keyword">монтированием файловой системы</SPAN> (mount). </P><DIV class="lecture_mark" id="mark_4"></DIV><P id="id_5">Для <SPAN class="keyword">монтирования файловой системы</SPAN> (см. лекцию 12, раздел "<SPAN class="keyword">Монтирование файловых систем</SPAN>") в существующем графе должна быть найдена или создана некоторая пустая директория – точка монтирования, к которой и присоединится корень монтируемой файловой системы. При операции монтирования в ядре заводятся структуры данных, описывающие файловую систему, а в <SPAN class="keyword">vnode</SPAN> для точки монтирования файловой системы помещается специальная информация.</P><DIV class="lecture_mark" id="mark_5"></DIV><P id="id_6"><SPAN class="keyword">Монтирование файловых систем</SPAN> обычно является прерогативой системного администратора и осуществляется командой операционной системы <SPAN class="texample"><SPAN class="keyword">mount</SPAN></SPAN> в ручном режиме, либо автоматически при старте операционной системы. Использование этой команды без параметров не требует специальных полномочий и позволяет пользователю получить информацию обо всех смонтированных файловых системах и соответствующих им физических устройствах. Для пользователя также обычно разрешается <SPAN class="keyword">монтирование файловых систем</SPAN>, расположенных на гибких магнитных дисках. Для первого накопителя на гибких магнитных дисках такая команда в Linux будет выглядеть следующим образом: </P><DIV class="lecture_mark" id="mark_6"></DIV><DIV class="example"><PRE>mount /dev/fd0 &lt;имя пустой директории&gt;
</PRE></DIV><P id="id_9">где <SPAN class="texample">&lt;имя пустой директории&gt;</SPAN> описывает точку монтирования, а <SPAN class="texample">/dev/fd0</SPAN> – специальный файл устройства, соответствующего этому накопителю (о специальных файлах устройств будет подробно рассказано в следующем разделе).</P><DIV class="lecture_mark" id="mark_9"></DIV><DIV class="xml_table_env" id="id_12"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_13"><B>Команда mount</B></P><DIV class="lecture_mark" id="mark_13"></DIV>

<P id="id_14"><B>Синтаксис команды</B></P><DIV class="lecture_mark" id="mark_14"></DIV>

<DIV class="example"><PRE>mount [-hV]
mount [-rw] [-t fstype] device dir
</PRE></DIV>

<P id="id_16"><B>Описание команды</B></P><DIV class="lecture_mark" id="mark_16"></DIV>

<P id="id_17">Настоящее описание не является полным описанием команды <SPAN class="texample"><SPAN class="keyword">mount</SPAN></SPAN>, а описывает только те ее опции (очень малую часть), которые используются в данном курсе. Для получения полного описания следует обратиться к UNIX Manual. </P><DIV class="lecture_mark" id="mark_17"></DIV>

<P id="id_19"><A name="keyword-context.2"></A>Команда <SPAN class="texample"><SPAN class="keyword_def">mount</SPAN></SPAN> предназначена для выполнения операции <SPAN class="keyword">монтирования файловой системы</SPAN> и получения информации об уже смонтированных файловых системах. </P><DIV class="lecture_mark" id="mark_19"></DIV>

<P id="id_21">Опции <SPAN class="texample">-h</SPAN>, <SPAN class="texample">-V</SPAN> используются при вызове команды без параметров и служат для следующих целей: </P><DIV class="lecture_mark" id="mark_21"></DIV>

<UL id="id_24"><LI><SPAN class="texample">-h</SPAN> – вывести краткую инструкцию по пользованию командой;</LI><LI><SPAN class="texample">-V</SPAN> – вывести информацию о версии команды <SPAN class="texample"><SPAN class="keyword">mount</SPAN></SPAN>;</LI></UL><DIV class="lecture_mark" id="mark_24"></DIV>

<P id="id_30">Команда <SPAN class="texample"><SPAN class="keyword">mount</SPAN></SPAN> без опций и без параметров выводит информацию обо всех уже с<SPAN class="keyword">монтированных файловых системах</SPAN>.</P><DIV class="lecture_mark" id="mark_30"></DIV>

<P id="id_32">Команда <SPAN class="texample"><SPAN class="keyword">mount</SPAN></SPAN> с параметрами служит для выполнения операции <SPAN class="keyword">монтирования файловой системы</SPAN>. </P><DIV class="lecture_mark" id="mark_32"></DIV>

<P id="id_34">Параметр <SPAN class="texample">device</SPAN> задает имя специального файла для устройства, содержащего файловую систему.</P><DIV class="lecture_mark" id="mark_34"></DIV>

<P id="id_36">Параметр <SPAN class="texample">dir</SPAN> задает имя точки монтирования (имя некоторой уже существующей пустой директории). При монтировании могут использоваться следующие опции: </P><DIV class="lecture_mark" id="mark_36"></DIV>

<UL id="id_38"><LI><SPAN class="texample">-r</SPAN>     — смонтировать файловую систему только для чтения (<SPAN class="texample">read only</SPAN>);</LI><LI><SPAN class="texample">-w</SPAN>    — смонтировать файловую систему для чтения и для записи (<SPAN class="texample">read/write</SPAN>). Используется по умолчанию;</LI><LI><SPAN class="texample">-t fstype</SPAN>    — задать тип монтируемой файловой системы как <SPAN class="texample">fstype</SPAN>. Поддерживаемые типы файловых систем в операционной системе Linux: adfs, affs, autofs, coda, coherent, cramfs, devpts, efs, ext, ext2, ext3, hfs, hpfs, iso9660 (для CD), minix, msdos, ncpfs, nfs, ntfs, proc, qnx4, reiserfs, romfs, smbfs, sysv, udf, ufs, umsdos, vfat, xenix, xfs, xiafs. При отсутствии явно заданного типа команда для большинства типов файловых систем способна опознать его автоматически. </LI></UL><DIV class="lecture_mark" id="mark_38"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_12"></DIV><P id="id_48">Если мы не собираемся использовать смонтированную файловую систему в дальнейшем (например, хотим вынуть ранее смонтированную дискету), нам необходимо выполнить операцию логического разъединения смонтированных файловых систем (umount). Для этой операции, которая тоже, как правило, является привилегией системного администратора, используется команда <SPAN class="texample"><SPAN class="keyword">umount</SPAN></SPAN> (может выполняться в ручном режиме или автоматически при завершении работы операционной системы). Для пользователя обычно доступна команда отмонтирования файловой системы на дискете в форме </P><DIV class="lecture_mark" id="mark_48"></DIV><DIV class="example"><PRE>umount &lt;имя точки монтирования&gt;
</PRE></DIV><P id="id_51">где <SPAN class="texample">&lt;имя точки монтирования&gt;</SPAN> – это <SPAN class="texample">&lt;имя пустой директории&gt;</SPAN>, использованное ранее в команде <SPAN class="texample"><SPAN class="keyword">mount</SPAN></SPAN>, или в форме </P><DIV class="lecture_mark" id="mark_51"></DIV><DIV class="example"><PRE>umount /dev/fd0 
</PRE></DIV><P id="id_56">где <SPAN class="texample">/dev/fd0</SPAN> – специальный файл устройства, соответствующего первому накопителю на гибких магнитных дисках. </P><DIV class="lecture_mark" id="mark_56"></DIV><P id="id_58"><B>Заметим, что для последующей корректной работы операционной системы при удалении физического носителя информации обязательно необходимо предварительное логическое разъединение файловых систем, если они перед этим были объединены.</B></P><DIV class="lecture_mark" id="mark_58"></DIV><DIV class="xml_table_env" id="id_59"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_60"><B>Команда umount</B></P><DIV class="lecture_mark" id="mark_60"></DIV>

<P id="id_61"><B>Синтаксис команды</B></P><DIV class="lecture_mark" id="mark_61"></DIV>

<DIV class="example"><PRE>umount [-hV]
umount device
umount dir
</PRE></DIV>

<P id="id_63"><B>Описание команды</B></P><DIV class="lecture_mark" id="mark_63"></DIV>

<P id="id_64">Настоящее описание не является полным описанием команды <SPAN class="texample"><SPAN class="keyword">umount</SPAN></SPAN>, а описывает только те ее опции (очень малую часть), которые используются в данном курсе. Для получения полного описания следует обратиться к UNIX Manual (команда man). </P><DIV class="lecture_mark" id="mark_64"></DIV>

<P id="id_66"><A name="keyword-context.3"></A>Команда <SPAN class="texample"><SPAN class="keyword_def">umount</SPAN></SPAN> предназначена для выполнения операции логического разъединения ранее смонтированных файловых систем. </P><DIV class="lecture_mark" id="mark_66"></DIV>

<P id="id_68">Опции <SPAN class="texample">-h</SPAN>, <SPAN class="texample">-V</SPAN> используются при вызове команды без параметров и служат для следующих целей: </P><DIV class="lecture_mark" id="mark_68"></DIV>

<UL id="id_71"><LI><SPAN class="texample">-h</SPAN> – вывести краткую инструкцию по пользованию командой;</LI><LI><SPAN class="texample">-V</SPAN> – вывести информацию о версии команды <SPAN class="texample"><SPAN class="keyword">umount</SPAN></SPAN>.</LI></UL><DIV class="lecture_mark" id="mark_71"></DIV>

<P id="id_77">Команда <SPAN class="texample"><SPAN class="keyword">umount</SPAN></SPAN> с параметром служит для выполнения операции логического разъединения файловых систем. В качестве параметра может быть задано либо имя устройства, содержащего файловую систему – <SPAN class="texample">device</SPAN>, либо имя точки <SPAN class="keyword">монтирования файловой системы</SPAN> (т.е. имя директории, которое указывалось в качестве параметра при вызове команды <SPAN class="texample"><SPAN class="keyword">mount</SPAN></SPAN>) – <SPAN class="texample">dir</SPAN>.</P><DIV class="lecture_mark" id="mark_77"></DIV>

<P id="id_82"><B>Заметим, что файловая система не может быть отмонтирована до тех пор, пока она находится в использовании (busy) – например, когда в ней существуют открытые файлы, какой-либо процесс имеет в качестве рабочей директории директорию в этой файловой системе и т.д.</B> </P><DIV class="lecture_mark" id="mark_82"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_59"></DIV><A name="sect3"></A><H3>Блочные, символьные устройства. Понятие драйвера. Блочные, символьные драйверы, драйверы низкого уровня. Файловый интерфейс </H3><P id="id_83">Обремененные знаниями об устройстве современных файловых систем в UNIX, мы можем, наконец, заняться вопросами реализации подсистемы ввода-вывода.</P><DIV class="lecture_mark" id="mark_83"></DIV><P id="id_84">В лекции 13 (раздел "Структура системы ввода-вывода") речь шла о том, что все устройства ввода-вывода можно разделить на относительно небольшое число типов, в зависимости от набора операций, которые могут ими выполняться. Такое деление позволяет организовать "слоистую" структуру подсистемы ввода-вывода, вынеся все аппаратно-зависимые части в <SPAN class="keyword">драйверы устройств</SPAN>, с которыми взаимодействует базовая подсистема ввода-вывода, осуществляющая стратегическое управление всеми устройствами. </P><DIV class="lecture_mark" id="mark_84"></DIV><P id="id_85">В операционной системе UNIX принята упрощенная классификация устройств (см. лекцию 13, раздел "Систематизация внешних устройств и интерфейс между базовой подсистемой ввода-вывода и <SPAN class="keyword">драйверами</SPAN>"): все устройства разделяются по способу передачи данных на <SPAN class="keyword">символьные</SPAN> и <SPAN class="keyword">блочные</SPAN>. <A name="keyword-context.4"></A><SPAN class="keyword_def">Символьные устройства</SPAN> осуществляют передачу данных байт за байтом, в то время как <A name="keyword-context.5"></A><SPAN class="keyword_def">блочные устройства</SPAN> передают блок байт как единое целое. Типичным примером <SPAN class="keyword">символьного устройства</SPAN> является клавиатура, примером <SPAN class="keyword">блочного устройства</SPAN> – жесткий диск. Непосредственное взаимодействие операционной системы с устройствами ввода-вывода обеспечивают их <SPAN class="keyword">драйверы</SPAN>. 
Существует пять основных случаев, когда ядро обращается к <SPAN class="keyword">драйверам</SPAN>:</P><DIV class="lecture_mark" id="mark_85"></DIV><OL id="id_86"><LI>Автоконфигурация. Происходит в процессе инициализации операционной системы, когда ядро определяет наличие доступных устройств. </LI><LI>Ввод-вывод. Обработка запроса ввода-вывода. </LI><LI>Обработка прерываний. Ядро вызывает специальные функции <SPAN class="keyword">драйвера</SPAN> для обработки прерывания, поступившего от устройства, в том числе, возможно, для планирования очередности запросов к нему. </LI><LI>Специальные запросы. Например, изменение параметров <SPAN class="keyword">драйвера</SPAN> или устройства. </LI><LI>Повторная инициализация устройства или останов операционной системы. </LI></OL><DIV class="lecture_mark" id="mark_86"></DIV><P id="id_92">Так же как устройства подразделяются на <SPAN class="keyword">символьные</SPAN> и <SPAN class="keyword">блочные</SPAN>, <SPAN class="keyword">драйверы</SPAN> тоже существуют символьные и блочные. Особенностью <SPAN class="keyword">блочных устройств</SPAN> является возможность организации на них файловой системы, поэтому блочные <SPAN class="keyword">драйверы</SPAN> обычно используются файловой системой UNIX. При обращении к <SPAN class="keyword">блочному устройству</SPAN>, не содержащему файловой системы, применяются специальные <SPAN class="keyword">драйверы</SPAN> низкого уровня, как правило, представляющие собой интерфейс между ядром операционной системы и блочным <SPAN class="keyword">драйвером</SPAN> устройства. </P><DIV class="lecture_mark" id="mark_92"></DIV><P id="id_93">Для каждого из этих трех типов <SPAN class="keyword">драйверов</SPAN> были выделены основные функции, которые базовая подсистема ввода-вывода может совершать над устройствами и <SPAN class="keyword">драйверами</SPAN>: инициализация устройства или <SPAN class="keyword">драйвера</SPAN>, временное завершение работы устройства, чтение, запись, обработка прерывания, опрос устройства и т.д. (об этих операциях уже говорилось в лекции 13, раздел "Систематизация внешних устройств и интерфейс между базовой подсистемой ввода-вывода и <SPAN class="keyword">драйверами</SPAN>"). Эти функции были систематизированы и представляют собой интерфейс между <SPAN class="keyword">драйверами</SPAN> и базовой подсистемой ввода-вывода.</P><DIV class="lecture_mark" id="mark_93"></DIV><P id="id_94"><A name="keyword-context.6"></A><A name="keyword-context.7"></A>Каждый <SPAN class="keyword">драйвер</SPAN> определенного типа в операционной системе UNIX получает собственный номер, который по сути дела является индексом в массиве специальных структур данных операционной системы – <SPAN class="keyword_def">коммутаторе устройств</SPAN> соответствующего типа. Этот индекс принято также называть <SPAN class="keyword_def">старшим номером устройства</SPAN>, хотя на самом деле он относится не к устройству, а к <SPAN class="keyword">драйверу</SPAN>. Несмотря на наличие трех типов <SPAN class="keyword">драйверов</SPAN>, в операционной системе используется всего два <SPAN class="keyword">коммутатора</SPAN>: для блочных и символьных <SPAN class="keyword">драйверов</SPAN>. <SPAN class="keyword">Драйверы</SPAN> низкого уровня распределяются между ними по преобладающему типу интерфейса (к какому типу ближе – в такой массив и 
заносятся). Каждый элемент <SPAN class="keyword">коммутатора устройств</SPAN> обязательно содержит адреса (точки входа в <SPAN class="keyword">драйвер</SPAN>), соответствующие стандартному набору функций интерфейса, которые и вызываются операционной системой для выполнения тех или иных действий над устройством и/или <SPAN class="keyword">драйвером</SPAN>.</P><DIV class="lecture_mark" id="mark_94"></DIV><P id="id_95"><A name="keyword-context.8"></A>Помимо <SPAN class="keyword">старшего номера устройства</SPAN> существует еще и <SPAN class="keyword_def">младший номер устройства</SPAN>, который передается <SPAN class="keyword">драйверу</SPAN> в качестве параметра и смысл которого определяется самим <SPAN class="keyword">драйвером</SPAN>. Например, это может быть номер раздела на жестком диске (partition), доступ к которому должен обеспечить <SPAN class="keyword">драйвер</SPAN> (надо отметить, что в операционной системе UNIX различные разделы физического носителя информации рассматриваются как различные устройства). В некоторых случаях <SPAN class="keyword">младший номер устройства</SPAN> может не использоваться, но для единообразия он должен присутствовать. Таким образом, пара драйвер-устройство всегда однозначно определяется в операционной системе заданием пары номеров (<SPAN class="keyword">старшего</SPAN> и 
<SPAN class="keyword">младшего номеров устройства</SPAN>) и типа <SPAN class="keyword">драйвера</SPAN> (символьный или блочный). </P><DIV class="lecture_mark" id="mark_95"></DIV><P id="id_96">Для связи приложений с <SPAN class="keyword">драйверами устройств</SPAN> операционная система UNIX использует <B>файловый интерфейс</B>. В числе типов файлов на предыдущем семинаре упоминались специальные файлы устройств. Так вот, каждой тройке тип-драйвер-устройство в файловой системе соответствует специальный файл устройства, который не занимает на диске никаких логических блоков, кроме индексного узла. В качестве атрибутов этого файла помимо обычных атрибутов используются соответствующие <SPAN class="keyword">старший</SPAN> и <SPAN class="keyword">младший номера устройства</SPAN> и тип <SPAN class="keyword">драйвера</SPAN> (тип драйвера определяется по типу файла: ибо есть специальные файлы <SPAN class="keyword">символьных устройств</SPAN> и специальные файлы <SPAN class="keyword">блочных устройств</SPAN>, а номера устройств занимают место длины файла, скажем, для регулярных файлов). 
Когда открывается специальный файл устройства, операционная система, в числе прочих действий, заносит в соответствующий элемент <SPAN class="keyword">таблицы открытых виртуальных узлов</SPAN> указатель на набор функций интерфейса из соответствующего элемента <SPAN class="keyword">коммутатора устройств</SPAN>. Теперь при попытке чтения из файла устройства или записи в файл устройства <SPAN class="keyword">виртуальная файловая система</SPAN> будет транслировать запросы на выполнение этих операций в соответствующие вызовы нужного <SPAN class="keyword">драйвера</SPAN>. </P><DIV class="lecture_mark" id="mark_96"></DIV><P id="id_97">Мы не будем останавливаться на практическом применении файлового интерфейса для работы с устройствами ввода-вывода, поскольку это выходит за пределы нашего курса, а вместо этого приступим к изложению концепции <SPAN class="keyword">сигналов</SPAN> в UNIX, тесно связанных с понятиями <SPAN class="keyword">аппаратного прерывания</SPAN>, <SPAN class="keyword">исключения</SPAN> и <SPAN class="keyword">программного прерывания</SPAN>. </P><DIV class="lecture_mark" id="mark_97"></DIV><A name="sect4"></A><H3>Аппаратные прерывания (interrupt), исключения (exception), программные прерывания (trap, software interrupt). Их обработка</H3><P id="id_98">В лекции 13 (раздел "Опрос устройств и прерывания. Исключительные ситуации и системные вызовы") уже вводились понятия <SPAN class="keyword">аппаратного прерывания</SPAN>, <SPAN class="keyword">исключения</SPAN> и <SPAN class="keyword">программного прерывания</SPAN>. Кратко напомним сказанное.</P><DIV class="lecture_mark" id="mark_98"></DIV><P id="id_99">После выдачи запроса ввода-вывода у процессора существует два способа узнать о том, что обработка запроса устройством завершена. Первый способ заключается в регулярной проверке процессором бита занятости в регистре состояния контроллера соответствующего устройства (polling). Второй способ заключается в использовании прерываний. При втором способе процессор имеет специальный вход, на который устройства ввода-вывода, используя контроллер прерываний или непосредственно, выставляют <SPAN class="keyword">сигнал</SPAN> запроса прерывания (interrupt request) при завершении операции ввода-вывода. При наличии такого <SPAN class="keyword">сигнала</SPAN> процессор после выполнения текущей команды не выполняет следующую, а, сохранив состояние ряда регистров и, возможно, загрузив в часть регистров новые значения, переходит к выполнению команд, расположенных по некоторым фиксированным адресам. После окончания обработки прерывания можно восстановить состояние процессора и продолжить его работу с команды, 
выполнение которой было отложено. </P><DIV class="lecture_mark" id="mark_99"></DIV><P id="id_100">Аналогичный механизм часто используется при обработке исключительных ситуаций (exception), возникающих при выполнении команды процессором (неправильный адрес в команде, защита памяти, деление на ноль и т.д.). В этом случае процессор не завершает выполнение команды, а поступает, как и при прерывании, сохраняя свое состояние до момента начала ее выполнения. </P><DIV class="lecture_mark" id="mark_100"></DIV><P id="id_101">Этим же механизмом часто пользуются и для реализации так называемых <SPAN class="keyword">программных прерываний</SPAN> (software interrupt, trap), применяемых, например, для переключения процессора из режима пользователя в режим ядра внутри системных вызовов. Для выполнения действий, аналогичных действиям по обработке прерывания, процессор в этом случае должен выполнить специальную команду.</P><DIV class="lecture_mark" id="mark_101"></DIV><P id="id_102"><B>Необходимо четко представлять себе разницу между этими тремя понятиями, для чего не лишним будет в очередной раз обратиться к лекциям (лекция 13, раздел "Опрос устройств и прерывания. Исключительные ситуации и системные вызовы").</B></P><DIV class="lecture_mark" id="mark_102"></DIV><P id="id_103">Как правило, обработку <SPAN class="keyword">аппаратных прерываний</SPAN> от устройств ввода-вывода производит сама операционная система, не доверяя работу с системными ресурсами процессам пользователя. Обработка же исключительных ситуаций и некоторых <SPAN class="keyword">программных прерываний</SPAN> вполне может быть возложена на пользовательский процесс через механизм <SPAN class="keyword">сигналов</SPAN>. </P><DIV class="lecture_mark" id="mark_103"></DIV><A name="sect5"></A><H3>Понятие сигнала. Способы возникновения сигналов и виды их обработки </H3><P id="id_104">С точки зрения пользователя получение процессом <SPAN class="keyword">сигнала</SPAN> выглядит как возникновение прерывания. Процесс прекращает регулярное исполнение, и управление передается механизму обработки <SPAN class="keyword">сигнала</SPAN>. По окончании обработки <SPAN class="keyword">сигнала</SPAN> процесс может возобновить регулярное исполнение. Типы <SPAN class="keyword">сигналов</SPAN> (их принято задавать номерами, как правило, в диапазоне от 1 до 31 включительно или специальными символьными обозначениями) и способы их возникновения в системе жестко регламентированы.</P><DIV class="lecture_mark" id="mark_104"></DIV><P id="id_105">Процесс может получить <SPAN class="keyword">сигнал</SPAN> от:</P><DIV class="lecture_mark" id="mark_105"></DIV><OL id="id_106"><LI>hardware (при возникновении исключительной ситуации); </LI><LI>другого процесса, выполнившего системный вызов передачи <SPAN class="keyword">сигнала</SPAN>; </LI><LI>операционной системы (при наступлении некоторых событий); </LI><LI>терминала (при нажатии определенной комбинации клавиш); </LI><LI>системы управления заданиями (при выполнении команды <SPAN class="texample"><SPAN class="keyword">kill</SPAN></SPAN> – мы рассмотрим ее позже). </LI></OL><DIV class="lecture_mark" id="mark_106"></DIV><P id="id_113">Передачу <SPAN class="keyword">сигналов</SPAN> процессу в случаях его генерации источниками 2, 3 и 5, т.е., в конечном счете, каким-либо другим процессом, можно рассматривать как реализацию в UNIX сигнальных средств связи, о которых рассказывалось в лекции 4.</P><DIV class="lecture_mark" id="mark_113"></DIV><P id="id_114">Существует три варианта реакции процесса на <SPAN class="keyword">сигнал</SPAN>:</P><DIV class="lecture_mark" id="mark_114"></DIV><OL id="id_115"><LI>Принудительно проигнорировать <SPAN class="keyword">сигнал</SPAN>. </LI><LI>Произвести обработку по умолчанию: проигнорировать, остановить процесс (перевести в состояние ожидания до получения другого специального <SPAN class="keyword">сигнала</SPAN>), либо завершить работу с образованием core файла или без него. </LI><LI>Выполнить обработку <SPAN class="keyword">сигнала</SPAN>, специфицированную пользователем. </LI></OL><DIV class="lecture_mark" id="mark_115"></DIV><P id="id_119">Изменить реакцию процесса на <SPAN class="keyword">сигнал</SPAN> можно с помощью специальных системных вызовов, которые мы рассмотрим позже. Реакция на некоторые <SPAN class="keyword">сигналы</SPAN> не допускает изменения, и они могут быть обработаны только по умолчанию. Так, например, <SPAN class="keyword">сигнал</SPAN> с номером 9 – <SPAN class="texample"><SPAN class="keyword">SIGKILL</SPAN></SPAN> обрабатывается только по умолчанию и всегда приводит к завершению процесса. </P><DIV class="lecture_mark" id="mark_119"></DIV><P id="id_121">Важным вопросом при программировании с использованием <SPAN class="keyword">сигналов</SPAN> является вопрос о сохранении реакции на них при порождении нового процесса или замене его пользовательского контекста. При системном вызове <SPAN class="texample">fork()</SPAN> все установленные реакции на <SPAN class="keyword">сигналы</SPAN> наследуется порожденным процессом. </P><DIV class="lecture_mark" id="mark_121"></DIV><P id="id_123">При системном вызове <SPAN class="texample">exec()</SPAN> <B>сохраняются реакции только для тех</B> <SPAN class="keyword">сигналов</SPAN>, <B>которые игнорировались или обрабатывались по умолчанию. Получение любого</B> <SPAN class="keyword">сигнала</SPAN>, <B>который до вызова</B> <SPAN class="texample">exec()</SPAN> <B>обрабатывался пользователем, приведет к завершению процесса.</B></P><DIV class="lecture_mark" id="mark_123"></DIV><P id="id_126">Прежде чем продолжить тему <SPAN class="keyword">сигналов</SPAN>, нам придется подробнее остановиться на иерархии процессов в операционной системе.</P><DIV class="lecture_mark" id="mark_126"></DIV><A name="sect6"></A><H3>Понятия группы процессов, сеанса, лидера группы, лидера сеанса, управляющего терминала сеанса. Системные вызовы getpgrp(), setpgrp(), getpgid(), setpgid(), getsid(), setsid() </H3><P id="id_127">В лекции 2, раздел "Одноразовые операции", уже говорилось, что все процессы в системе связаны родственными отношениями и образуют генеалогическое дерево или лес из таких деревьев, где в качестве узлов деревьев выступают сами процессы, а связями служат отношения родитель-ребенок. Все эти деревья принято разделять на <SPAN class="keyword">группы процессов</SPAN>, или семьи (см. <A href="http://www.intuit.ru/department/os/osintropractice/9/osintropractice_9.html#image.13-14.1">рис. 13–14.1</A>). </P><DIV class="lecture_mark" id="mark_127"></DIV><P id="id_128"><A name="keyword-context.9"></A><SPAN class="keyword_def">Группа процессов</SPAN> включает в себя один или более процессов и существует, пока в <SPAN class="keyword">группе</SPAN> присутствует хотя бы один процесс. Каждый процесс обязательно включен в какую-нибудь <SPAN class="keyword">группу</SPAN>. При рождении нового процесса он попадает в ту же <SPAN class="keyword">группу процессов</SPAN>, в которой находится его родитель. Процессы могут мигрировать из <SPAN class="keyword">группы</SPAN> в <SPAN class="keyword">группу</SPAN> по своему желанию или по желанию другого процесса (в зависимости от версии UNIX). Многие системные вызовы могут быть применены не к одному конкретному процессу, а ко всем процессам в некоторой <SPAN class="keyword">группе</SPAN>. Поэтому то, как именно следует объединять процессы в <SPAN class="keyword">группы</SPAN>, зависит от того, как предполагается их использовать. Чуть позже мы поговорим об использовании <SPAN class="keyword">групп процессов</SPAN> для передачи <SPAN class="keyword">сигналов</SPAN>. </P><DIV class="lecture_mark" id="mark_128"></DIV><P align="left" id="id_129"><A name="image.13-14.1"></A></P><DIV><IMG src="./9. Организация ввода-вывода в UNIX. Файлы устройств. Аппарат прерываний. Сигналы в UNIX_files/13-14-1.gif" alt="Иерархия процессов в UNIX" width="447" height="268"></DIV><BR><B>Рис. 13-14.1.</B>&nbsp;
        Иерархия процессов в UNIX<P></P><DIV class="lecture_mark" id="mark_129"></DIV><P id="id_130">В свою очередь, <A name="keyword-context.10"></A><SPAN class="keyword">группы процессов</SPAN> объединяются в <SPAN class="keyword">сеансы</SPAN>, образуя, с родственной точки зрения, некие кланы семей. Понятие <SPAN class="keyword">сеанса</SPAN> изначально было введено в UNIX для логического объединения <SPAN class="keyword">групп процессов</SPAN>, созданных в результате каждого входа и последующей работы пользователя в системе. С каждым <SPAN class="keyword">сеансом</SPAN>, поэтому, может быть связан в системе терминал, называемый <SPAN class="keyword_def">управляющим терминалом сеанса</SPAN>, через который обычно и общаются процессы <SPAN class="keyword">сеанса</SPAN> с пользователем. <SPAN class="keyword">Сеанс</SPAN> не может иметь более одного <SPAN class="keyword">управляющего терминала</SPAN>, и один терминал не может быть <SPAN class="keyword">управляющим</SPAN> для нескольких <SPAN class="keyword">сеансов</SPAN>. В то же время могут существовать <SPAN class="keyword">сеансы</SPAN>, вообще не имеющие <SPAN class="keyword">управляющего терминала</SPAN>.</P><DIV class="lecture_mark" id="mark_130"></DIV><P id="id_131">Каждая <SPAN class="keyword">группа процессов</SPAN> в системе получает собственный уникальный номер. Узнать этот номер можно с помощью системного вызова <SPAN class="texample"><SPAN class="keyword">getpgid()</SPAN></SPAN>. Используя его, процесс может узнать номер <SPAN class="keyword">группы</SPAN> для себя самого или для процесса из своего <SPAN class="keyword">сеанса</SPAN>. К сожалению, не во всех версиях UNIX присутствует данный системный вызов. Здесь мы сталкиваемся с тяжелым наследием разделения линий UNIX'ов на линию BSD и линию System V, которое будет нас преследовать почти на всем протяжении данной темы. Вместо вызова <SPAN class="texample"><SPAN class="keyword">getpgid()</SPAN></SPAN> в таких системах существует системный вызов <SPAN class="texample"><SPAN class="keyword">getpgrp()</SPAN></SPAN>, который возвращает номер <SPAN class="keyword">группы</SPAN> только для текущего процесса.</P><DIV class="lecture_mark" id="mark_131"></DIV><DIV class="xml_table_env" id="id_135"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_136"><B>Системный вызов getpgid()</B></P><DIV class="lecture_mark" id="mark_136"></DIV>

<P id="id_137"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_137"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
pid_t getpgid(pid_t pid);
</PRE></DIV>

<P id="id_139"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_139"></DIV>

<P id="id_140"><SPAN class="keyword">Системный вызов</SPAN> возвращает идентификатор <SPAN class="keyword">группы процессов</SPAN> для процесса с идентификатором <SPAN class="texample">pid</SPAN>. </P><DIV class="lecture_mark" id="mark_140"></DIV>

<P id="id_142">Узнать номер <SPAN class="keyword">группы</SPAN> процесс может только для себя самого или для процесса из своего <SPAN class="keyword">сеанса</SPAN>. При других значениях <SPAN class="texample">pid</SPAN> системный вызов возвращает значение <SPAN class="texample">-1</SPAN>.</P><DIV class="lecture_mark" id="mark_142"></DIV>

<P id="id_145">Тип данных <SPAN class="texample">pid_t</SPAN> является синонимом для одного из целочисленных типов языка C. </P><DIV class="lecture_mark" id="mark_145"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_135"></DIV><P id="id_147"></P><DIV class="lecture_mark" id="mark_147"></DIV><DIV class="xml_table_env" id="id_148"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_149"><B>Системный вызов getpgrp()</B></P><DIV class="lecture_mark" id="mark_149"></DIV>

<P id="id_150"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_150"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
pid_t getpgrp(void);
</PRE></DIV>

<P id="id_152"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_152"></DIV>

<P id="id_153"><A name="keyword-context.11"></A>Системный вызов <SPAN class="texample"><SPAN class="keyword_def">getpgrp</SPAN></SPAN> возвращает идентификатор <SPAN class="keyword">группы процессов</SPAN> для текущего процесса.</P><DIV class="lecture_mark" id="mark_153"></DIV>

<P id="id_155">Тип данных <SPAN class="texample">pid_t</SPAN> является синонимом для одного из целочисленных типов языка C. </P><DIV class="lecture_mark" id="mark_155"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_148"></DIV><P id="id_157">Для перевода процесса в другую <SPAN class="keyword">группу процессов</SPAN>, возможно, с одновременным ее созданием, применяется системный вызов <SPAN class="texample"><SPAN class="keyword">setpgid()</SPAN></SPAN>. Перевести в другую <SPAN class="keyword">группу</SPAN> процесс может либо самого себя (и то не во всякую и не всегда), либо свой процесс-ребенок, который не выполнял системный вызов <SPAN class="texample">exec()</SPAN>, т.е. не запускал на выполнение другую программу. При определенных значениях параметров системного вызова создается новая <SPAN class="keyword">группа процессов</SPAN> с идентификатором, совпадающим с идентификатором переводимого процесса, состоящая первоначально только из одного этого процесса. Новая <SPAN class="keyword">группа</SPAN> может быть создана только таким способом, поэтому идентификаторы <SPAN class="keyword">групп</SPAN> в системе уникальны. Переход в другую <SPAN class="keyword">группу</SPAN> 
без создания новой <SPAN class="keyword">группы</SPAN> возможен лишь в пределах одного <SPAN class="keyword">сеанса</SPAN>.</P><DIV class="lecture_mark" id="mark_157"></DIV><P id="id_160">В некоторых разновидностях UNIX системный вызов <SPAN class="texample"><SPAN class="keyword">setpgid()</SPAN></SPAN> отсутствует, а вместо него используется системный вызов <SPAN class="texample"><SPAN class="keyword">setpgrp()</SPAN></SPAN>, способный только создавать новую <SPAN class="keyword">группу процессов</SPAN> с идентификатором, совпадающим с идентификатором текущего процесса, и переводить в нее текущий процесс. (В ряде систем, где сосуществуют вызовы <SPAN class="texample"><SPAN class="keyword">setpgrp()</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">setpgid()</SPAN></SPAN>, например в Solaris, вызов <SPAN class="texample"><SPAN class="keyword">setpgrp()</SPAN></SPAN> ведет себя иначе – он аналогичен рассматриваемому ниже вызову <SPAN class="texample"><SPAN class="keyword">setsid()</SPAN></SPAN>.) </P><DIV class="lecture_mark" id="mark_160"></DIV><DIV class="xml_table_env" id="id_167"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_168"><B>Системный вызов setpgid()</B></P><DIV class="lecture_mark" id="mark_168"></DIV>

<P id="id_169"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_169"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
int setpgid(pid_t pid, pid_t pgid);
</PRE></DIV>

<P id="id_171"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_171"></DIV>

<P id="id_172"><A name="keyword-context.12"></A>Системный вызов <SPAN class="texample"><SPAN class="keyword_def">setpgid</SPAN></SPAN> служит для перевода процесса из одной <SPAN class="keyword">группы процессов</SPAN> в другую, а также для создания новой <SPAN class="keyword">группы процессов</SPAN>. </P><DIV class="lecture_mark" id="mark_172"></DIV>

<P id="id_174">Параметр <SPAN class="texample">pid</SPAN> является идентификатором процесса, который нужно перевести в другую <SPAN class="keyword">группу</SPAN>, а параметр <SPAN class="texample">pgid</SPAN> – идентификатором <SPAN class="keyword">группы процессов</SPAN>, в которую предстоит перевести этот процесс. </P><DIV class="lecture_mark" id="mark_174"></DIV>

<P id="id_177">Не все комбинации этих параметров разрешены. Перевести в другую <SPAN class="keyword">группу</SPAN> процесс может либо самого себя (и то не во всякую, и не всегда), либо свой процесс-ребенок, который не выполнял системный вызов <SPAN class="texample">exec()</SPAN>, т.е. не запускал на выполнение другую программу. </P><DIV class="lecture_mark" id="mark_177"></DIV>

<UL id="id_179"><LI>Если параметр <SPAN class="texample">pid</SPAN> равен <SPAN class="texample">0</SPAN>, то считается, что процесс переводит в другую <SPAN class="keyword">группу</SPAN> самого себя. </LI><LI>Если параметр <SPAN class="texample">pgid</SPAN> равен <SPAN class="texample">0</SPAN>, то в Linux считается, что процесс переводится в <SPAN class="keyword">группу</SPAN> с идентификатором, совпадающим с идентификатором процесса, определяемого первым параметром. </LI><LI>Если значения, определяемые параметрами <SPAN class="texample">pid</SPAN> и <SPAN class="texample">pgid</SPAN>, равны, то создается новая <SPAN class="keyword">группа</SPAN> с идентификатором, совпадающим с идентификатором переводимого процесса, состоящая первоначально только из этого процесса. <B>Переход в другую</B> <SPAN class="keyword">группу</SPAN> <B>без создания новой</B> <SPAN class="keyword">группы</SPAN> <B>возможен только в пределах одного</B> <SPAN class="keyword">сеанса</SPAN>. </LI></UL><DIV class="lecture_mark" id="mark_179"></DIV>

<P id="id_189">В новую <SPAN class="keyword">группу</SPAN> не может перейти процесс, являющийся <SPAN class="keyword_def">лидером группы</SPAN>, т.е. <A name="keyword-context.13"></A>процесс, идентификатор которого совпадает с идентификатором его <SPAN class="keyword">группы</SPAN>.<SPAN class="keyword"></SPAN> </P><DIV class="lecture_mark" id="mark_189"></DIV>

<P id="id_190">Тип данных <SPAN class="texample">pid_t</SPAN> является синонимом для одного из целочисленных типов языка C. </P><DIV class="lecture_mark" id="mark_190"></DIV>

<P id="id_192"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_192"></DIV>

<P id="id_193">Системный вызов возвращает значение <SPAN class="texample">0</SPAN> при нормальном завершении и значение <SPAN class="texample">-1</SPAN> при возникновении ошибки. </P><DIV class="lecture_mark" id="mark_193"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_167"></DIV><P id="id_196"></P><DIV class="lecture_mark" id="mark_196"></DIV><DIV class="xml_table_env" id="id_197"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_198"><B>Системный вызов setpgrp()</B></P><DIV class="lecture_mark" id="mark_198"></DIV>

<P id="id_199"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_199"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
int setpgrp(void);
</PRE></DIV>

<P id="id_201"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_201"></DIV>

<P id="id_202"><A name="keyword-context.14"></A>Системный вызов <SPAN class="texample"><SPAN class="keyword_def">setpgrp</SPAN></SPAN> служит для перевода текущего процесса во вновь создаваемую <SPAN class="keyword">группу процессов</SPAN>, идентификатор которой будет совпадать с идентификатором текущего процесса. </P><DIV class="lecture_mark" id="mark_202"></DIV>

<P id="id_204"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_204"></DIV>

<P id="id_205">Системный вызов возвращает значение <SPAN class="texample">0</SPAN> при нормальном завершении и значение <SPAN class="texample">-1</SPAN> при возникновении ошибки. </P><DIV class="lecture_mark" id="mark_205"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_197"></DIV><P id="id_208">Процесс, идентификатор которого совпадает с идентификатором его <SPAN class="keyword">группы</SPAN>, называется <SPAN class="keyword">лидером группы</SPAN>. Одно из ограничений на применение вызовов <SPAN class="texample"><SPAN class="keyword">setpgid()</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">setpgrp()</SPAN></SPAN> состоит в том, что <SPAN class="keyword">лидер группы</SPAN> не может перебраться в другую <SPAN class="keyword">группу</SPAN>. </P><DIV class="lecture_mark" id="mark_208"></DIV><P id="id_211">Каждый <SPAN class="keyword">сеанс</SPAN> в системе также имеет собственный номер. Для того чтобы узнать его, можно воспользоваться системным вызовом <SPAN class="texample"><SPAN class="keyword">getsid()</SPAN></SPAN>. В разных версиях UNIX на него накладываются различные ограничения. В Linux такие ограничения отсутствуют. </P><DIV class="lecture_mark" id="mark_211"></DIV><DIV class="xml_table_env" id="id_213"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_214"><B>Системный вызов getsid()</B></P><DIV class="lecture_mark" id="mark_214"></DIV>

<P id="id_215"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_215"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
pid_t getsid(pid_t pid);
</PRE></DIV>

<P id="id_217"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_217"></DIV>

<P id="id_218"><A name="keyword-context.15"></A><SPAN class="keyword_def">Системный вызов</SPAN> возвращает идентификатор <SPAN class="keyword">сеанса</SPAN> для процесса с идентификатором <SPAN class="texample">pid</SPAN>. Если параметр <SPAN class="texample">pid</SPAN> равен <SPAN class="texample">0</SPAN>, то возвращается идентификатор <SPAN class="keyword">сеанса</SPAN> для данного процесса</P><DIV class="lecture_mark" id="mark_218"></DIV>

<P id="id_222">Тип данных <SPAN class="texample">pid_t</SPAN> является синонимом для одного из целочисленных типов языка C. </P><DIV class="lecture_mark" id="mark_222"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_213"></DIV><P id="id_224">Использование системного вызова <SPAN class="texample"><SPAN class="keyword">setsid()</SPAN></SPAN> приводит к созданию новой <SPAN class="keyword">группы</SPAN>, состоящей только из процесса, который его выполнил (он становится <SPAN class="keyword">лидером новой группы</SPAN>), и нового <SPAN class="keyword">сеанса</SPAN>, идентификатор которого совпадает с идентификатором процесса, сделавшего вызов. Такой процесс называется <SPAN class="keyword">лидером сеанса</SPAN>. Этот системный вызов может применять только процесс, не являющийся <SPAN class="keyword">лидером группы</SPAN>.</P><DIV class="lecture_mark" id="mark_224"></DIV><DIV class="xml_table_env" id="id_226"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_227"><B>Системный вызов setsid()</B></P><DIV class="lecture_mark" id="mark_227"></DIV>

<P id="id_228"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_228"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
int setsid(void);
</PRE></DIV>

<P id="id_230"><B>Описание системных вызовов</B></P><DIV class="lecture_mark" id="mark_230"></DIV>

<P id="id_231"><SPAN class="keyword">Этот системный вызов</SPAN> может применять только процесс, не являющийся <SPAN class="keyword">лидером группы</SPAN>, т.е. процесс, идентификатор которого не совпадает с идентификатором его <SPAN class="keyword">группы</SPAN>. Использование системного вызова <SPAN class="texample"><SPAN class="keyword">setsid</SPAN></SPAN> приводит к созданию новой <SPAN class="keyword">группы</SPAN>, состоящей только из процесса, который его выполнил (он становится <SPAN class="keyword">лидером новой группы</SPAN>), и нового <SPAN class="keyword">сеанса</SPAN>, идентификатор которого совпадает с идентификатором процесса, сделавшего вызов. </P><DIV class="lecture_mark" id="mark_231"></DIV>

<P id="id_233"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_233"></DIV>

<P id="id_234">Системный вызов возвращает значение <SPAN class="texample">0</SPAN> при нормальном завершении и значение <SPAN class="texample">-1</SPAN> при возникновении ошибки. </P><DIV class="lecture_mark" id="mark_234"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_226"></DIV><P id="id_237"><A name="keyword-context.16"></A>Если <SPAN class="keyword">сеанс</SPAN> имеет <SPAN class="keyword">управляющий терминал</SPAN>, то этот терминал обязательно приписывается к некоторой <SPAN class="keyword">группе процессов</SPAN>, входящей в <SPAN class="keyword">сеанс</SPAN>. Такая <SPAN class="keyword">группа процессов</SPAN> называется <SPAN class="keyword_def">текущей группой процессов</SPAN> для данного <SPAN class="keyword">сеанса</SPAN>. <A name="keyword-context.17"></A>Все процессы, входящие в <SPAN class="keyword">текущую группу процессов</SPAN>, могут совершать операции ввода-вывода, используя <SPAN class="keyword">управляющий терминал</SPAN>. Все остальные <SPAN class="keyword">группы процессов</SPAN> <SPAN class="keyword">сеанса</SPAN> называются <SPAN class="keyword_def">фоновыми группами</SPAN>, а процессы, входящие в них – <B>фоновыми процессами</B>. При попытке 
ввода-вывода фонового процесса через <SPAN class="keyword">управляющий терминал</SPAN> этот процесс получит <SPAN class="keyword">сигналы</SPAN>, которые стандартно приводят к прекращению работы процесса. Передавать <SPAN class="keyword">управляющий терминал</SPAN> от одной <SPAN class="keyword">группы процессов</SPAN> к другой может только <SPAN class="keyword">лидер сеанса</SPAN>. Заметим, что для <SPAN class="keyword">сеансов</SPAN>, не имеющих <SPAN class="keyword">управляющего терминала</SPAN>, все процессы являются фоновыми.</P><DIV class="lecture_mark" id="mark_237"></DIV><P id="id_238"><A name="keyword-context.18"></A>При завершении работы процесса – <SPAN class="keyword">лидера сеанса</SPAN> все процессы из <SPAN class="keyword">текущей группы</SPAN> <SPAN class="keyword">сеанса</SPAN> получают сигнал <SPAN class="texample"><SPAN class="keyword_def">SIGHUP</SPAN></SPAN>, который при стандартной обработке приведет к их завершению. Таким образом, после завершения <SPAN class="keyword">лидера сеанса</SPAN> в нормальной ситуации работу продолжат только фоновые процессы.</P><DIV class="lecture_mark" id="mark_238"></DIV><P id="id_240">Процессы, входящие в текущую группу <SPAN class="keyword">сеанса</SPAN>, могут получать <SPAN class="keyword">сигналы</SPAN>, инициируемые нажатием определенных клавиш на терминале – <SPAN class="texample"><SPAN class="keyword">SIGINT</SPAN></SPAN> при нажатии клавиш &lt;ctrl&gt; и &lt;c&gt;, и <SPAN class="texample"><SPAN class="keyword">SIGQUIT</SPAN></SPAN> при нажатии клавиш &lt;ctrl&gt; и &lt;4&gt;. Стандартная реакция на эти <SPAN class="keyword">сигналы</SPAN> – завершение процесса (с образованием core файла для сигнала <SPAN class="texample"><SPAN class="keyword">SIGQUIT</SPAN></SPAN>).</P><DIV class="lecture_mark" id="mark_240"></DIV><P id="id_244">Необходимо ввести еще одно понятие, связанное с процессом, – <SPAN class="keyword">эффективный идентификатор пользователя</SPAN>. В материалах первого семинара говорилось о том, что <A name="keyword-context.19"></A>каждый пользователь в системе имеет собственный идентификатор – UID. Каждый процесс, запущенный пользователем, задействует этот UID для определения своих полномочий. Однако иногда, если у исполняемого файла были выставлены соответствующие атрибуты, процесс может выдать себя за процесс, запущенный другим пользователем. Идентификатор пользователя, от имени которого процесс пользуется полномочиями, и является <SPAN class="keyword_def">эффективным идентификатором пользователя</SPAN> для процесса – <SPAN class="keyword">EUID</SPAN>. За исключением выше оговоренного случая, <SPAN class="keyword">эффективный идентификатор пользователя</SPAN> совпадает с идентификатором пользователя, создавшего процесс. </P><DIV class="lecture_mark" id="mark_244"></DIV><A name="sect7"></A><H3>Системный вызов kill() и команда kill</H3><P id="id_245">Из всех перечисленных ранее в разделе "<SPAN class="keyword">Аппаратные прерывания</SPAN> (interrupt), <SPAN class="keyword">исключения</SPAN> (exception), <SPAN class="keyword">программные прерывания</SPAN> (trap, software interrupt). Их обработка" источников <SPAN class="keyword">сигнала</SPAN> пользователю доступны только два – команда <SPAN class="texample"><SPAN class="keyword">kill</SPAN></SPAN> и посылка <SPAN class="keyword">сигнала</SPAN> процессу с помощью системного вызова <SPAN class="texample"><SPAN class="keyword">kill()</SPAN></SPAN>. Команда <SPAN class="texample"><SPAN class="keyword">kill</SPAN></SPAN> обычно используется в следующей форме:</P><DIV class="lecture_mark" id="mark_245"></DIV><DIV class="example"><PRE>kill [-номер] pid
</PRE></DIV><P id="id_250">Здесь <SPAN class="texample">pid</SPAN> – это идентификатор процесса, которому посылается <SPAN class="keyword">сигнал</SPAN>, а номер – номер <SPAN class="keyword">сигнала</SPAN>, который посылается процессу. Послать <SPAN class="keyword">сигнал</SPAN> (если у вас нет полномочий суперпользователя) можно только процессу, у которого <SPAN class="keyword">эффективный идентификатор пользователя</SPAN> совпадает с идентификатором пользователя, посылающего <SPAN class="keyword">сигнал</SPAN>. Если параметр –<SPAN class="texample">номер</SPAN> отсутствует, то посылается сигнал <SPAN class="texample"><SPAN class="keyword">SIGTERM</SPAN></SPAN>, обычно имеющий номер <SPAN class="texample">15</SPAN>, и реакция на него по умолчанию – завершить работу процесса, который получил <SPAN class="keyword">сигнал</SPAN>.</P><DIV class="lecture_mark" id="mark_250"></DIV><DIV class="xml_table_env" id="id_255"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_256"><B>Команда kill</B> </P><DIV class="lecture_mark" id="mark_256"></DIV>

<P id="id_257"><B>Синтаксис команды</B></P><DIV class="lecture_mark" id="mark_257"></DIV>

<DIV class="example"><PRE>kill [-signal] [--] pid
kill -l 
</PRE></DIV>

<P id="id_259"><B>Описание команды</B></P><DIV class="lecture_mark" id="mark_259"></DIV>

<P id="id_260">Команда <SPAN class="texample"><SPAN class="keyword">kill</SPAN></SPAN> предназначена для передачи <SPAN class="keyword">сигнала</SPAN> одному или нескольким специфицированным процессам в рамках полномочий пользователя. </P><DIV class="lecture_mark" id="mark_260"></DIV>

<P id="id_262">Параметр <SPAN class="texample">pid</SPAN> определяет процесс или процессы, которым будут доставляться <SPAN class="keyword">сигналы</SPAN>. Он может быть задан одним из следующих четырех способов:</P><DIV class="lecture_mark" id="mark_262"></DIV>

<UL id="id_264"><LI>Число <SPAN class="texample">n &gt; 0</SPAN> – определяет идентификатор процесса, которому будет доставлен <SPAN class="keyword">сигнал</SPAN>. </LI><LI>Число <SPAN class="texample">0</SPAN> – <SPAN class="keyword">сигнал</SPAN> будет доставлен всем процессам <SPAN class="keyword">текущей группы</SPAN> для данного <SPAN class="keyword">управляющего терминала</SPAN>. </LI><LI>Число <SPAN class="texample">-1</SPAN> с предваряющей опцией -- – <SPAN class="keyword">сигнал</SPAN> будет доставлен (если позволяют полномочия) всем процессам с идентификаторами, большими <SPAN class="texample">1</SPAN>. </LI><LI>Число <SPAN class="texample">n &lt; 0</SPAN>, где <SPAN class="texample">n</SPAN> не равно <SPAN class="texample">-1</SPAN>, с предваряющей опцией -- – <SPAN class="keyword">сигнал</SPAN> будет доставлен всем процессам из <SPAN class="keyword">группы процессов</SPAN>, идентификатор которой равен <SPAN class="texample">-n</SPAN>. </LI></UL><DIV class="lecture_mark" id="mark_264"></DIV>

<P id="id_277">Параметр <SPAN class="texample">-signal</SPAN> определяет тип <SPAN class="keyword">сигнала</SPAN>, который должен быть доставлен, и может задаваться в числовой или символьной форме, например <SPAN class="texample">-9</SPAN> или -<SPAN class="texample"><SPAN class="keyword">SIGKILL</SPAN></SPAN>. Если этот параметр опущен, процессам по умолчанию посылается сигнал <SPAN class="texample"><SPAN class="keyword">SIGTERM</SPAN></SPAN>.</P><DIV class="lecture_mark" id="mark_277"></DIV>

<P id="id_282">Послать <SPAN class="keyword">сигнал</SPAN> (не имея полномочий суперпользователя) можно только процессу, у которого <SPAN class="keyword">эффективный идентификатор</SPAN> пользователя совпадает с идентификатором пользователя, посылающего <SPAN class="keyword">сигнал</SPAN>. </P><DIV class="lecture_mark" id="mark_282"></DIV>

<P id="id_283">Опция <SPAN class="texample">-l</SPAN> используется для получения списка <SPAN class="keyword">сигналов</SPAN>, существующих в системе в символьной и числовой формах. </P><DIV class="lecture_mark" id="mark_283"></DIV>

<P id="id_285">Во многих операционных системах предусмотрены еще и дополнительные опции для команды <SPAN class="texample"><SPAN class="keyword">kill</SPAN></SPAN>. </P><DIV class="lecture_mark" id="mark_285"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_255"></DIV><P id="id_287">При использовании системного вызова <SPAN class="texample"><SPAN class="keyword">kill()</SPAN></SPAN> послать <SPAN class="keyword">сигнал</SPAN> (не имея полномочий суперпользователя) можно только процессу или процессам, у которых <SPAN class="keyword">эффективный идентификатор пользователя</SPAN> совпадает с <SPAN class="keyword">эффективным идентификатором пользователя</SPAN> процесса, посылающего <SPAN class="keyword">сигнал</SPAN>. </P><DIV class="lecture_mark" id="mark_287"></DIV><DIV class="xml_table_env" id="id_289"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_290"><B>Системный вызов kill()</B></P><DIV class="lecture_mark" id="mark_290"></DIV>

<P id="id_291"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_291"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;
int kill(pid_t pid, int signal);
</PRE></DIV>

<P id="id_293"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_293"></DIV>

<P id="id_294">Системный вызов <SPAN class="texample"><SPAN class="keyword">kill()</SPAN></SPAN> предназначен для передачи <SPAN class="keyword">сигнала</SPAN> одному или нескольким специфицированным процессам в рамках полномочий пользователя.</P><DIV class="lecture_mark" id="mark_294"></DIV>

<P id="id_296">Послать <SPAN class="keyword">сигнал</SPAN> (не имея полномочий суперпользователя) можно только процессу, у которого <SPAN class="keyword">эффективный идентификатор пользователя</SPAN> совпадает с <SPAN class="keyword">эффективным идентификатором пользователя</SPAN> для процесса, посылающего <SPAN class="keyword">сигнал</SPAN>.</P><DIV class="lecture_mark" id="mark_296"></DIV>

<P id="id_297">Аргумент <SPAN class="texample">pid</SPAN> описывает, кому посылается <SPAN class="keyword">сигнал</SPAN>, а аргумент <SPAN class="texample">sig</SPAN> – какой <SPAN class="keyword">сигнал</SPAN> посылается. Этот системный вызов умеет делать много разных вещей, в зависимости от значения аргументов:</P><DIV class="lecture_mark" id="mark_297"></DIV>

<UL id="id_300"><LI>Если <SPAN class="texample">pid &gt; 0</SPAN> и <SPAN class="texample">sig &gt; 0</SPAN>, то <SPAN class="keyword">сигнал</SPAN> номером <SPAN class="texample">sig</SPAN> (если позволяют привилегии) посылается процессу с идентификатором <SPAN class="texample">pid</SPAN>.</LI><LI>Если <SPAN class="texample">pid = 0</SPAN>, а <SPAN class="texample">sig &gt; 0</SPAN>, то <SPAN class="keyword">сигнал</SPAN> с номером <SPAN class="texample">sig</SPAN> посылается всем процессам в <SPAN class="keyword">группе</SPAN>, к которой принадлежит посылающий процесс.</LI><LI>Если <SPAN class="texample">pid = -1</SPAN>, <SPAN class="texample">sig &gt; 0</SPAN> и посылающий процесс не является процессом суперпользователя, то <SPAN class="keyword">сигнал</SPAN> посылается всем процессам в системе, для которых идентификатор пользователя совпадает с <SPAN class="keyword">эффективным идентификатором пользователя</SPAN> процесса, посылающего <SPAN class="keyword">сигнал</SPAN>.</LI><LI>Если <SPAN class="texample">pid = -1</SPAN>, <SPAN class="texample">sig &gt; 0</SPAN> и посылающий процесс является процессом суперпользователя, то <SPAN class="keyword">сигнал</SPAN> посылается всем процессам в системе, за исключением системных процессов (обычно всем, кроме процессов с <SPAN class="texample">pid = 0</SPAN> и <SPAN class="texample">pid = 1</SPAN>).</LI><LI>Если <SPAN class="texample">pid &lt; 0</SPAN>, но не <SPAN class="texample">–1</SPAN>, <SPAN class="texample">sig &gt; 0</SPAN>, то <SPAN class="keyword">сигнал</SPAN> посылается всем процессам из <SPAN class="keyword">группы</SPAN>, идентификатор которой равен абсолютному значению аргумента <SPAN class="texample">pid</SPAN> (если позволяют привилегии).</LI><LI>Если значение <SPAN class="texample">sig = 0</SPAN>, то производится проверка на ошибку, а <SPAN class="keyword">сигнал</SPAN> не посылается, так как все <SPAN class="keyword">сигналы</SPAN> имеют номера <SPAN class="texample">&gt; 0</SPAN>. Это можно использовать для проверки правильности аргумента <SPAN class="texample">pid</SPAN> (есть ли в системе процесс или <SPAN class="keyword">группа процессов</SPAN> с соответствующим идентификатором). </LI></UL><DIV class="lecture_mark" id="mark_300"></DIV>

<P id="id_327"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_327"></DIV>

<P id="id_328">Системный вызов возвращает <SPAN class="texample">0</SPAN> при нормальном завершении и <SPAN class="texample">–1</SPAN> при ошибке.</P><DIV class="lecture_mark" id="mark_328"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_289"></DIV><A name="sect8"></A><H3>Изучение особенностей получения терминальных сигналов текущей и фоновой группой процессов </H3><P id="id_331">Возьмем тривиальную программу <SPAN class="texample">13–14-1.c</SPAN>, в которой процесс порождает ребенка, и они оба зацикливаются, и на ее основе проиллюстрируем сказанное выше.</P><DIV class="lecture_mark" id="mark_331"></DIV><A name="example.13-14.1"></A><DIV class="example"><PRE>/* Тривиальная программа для иллюстрации 
понятий группа процессов, сеанс, фоновая 
группа и т.д. */
#include &lt;unistd.h&gt;
int main(void){ 
    (void)fork();
    while(1);
    return 0;
} 
</PRE><SPAN class="objectName">
            Листинг 
            13-14.1.
            Тривиальная программа (13–14-1.c) для иллюстрации понятий группа процессов, сеанс, фоновая группа и т.д.</SPAN></DIV><P id="id_334">Для этого будем использовать команду <SPAN class="texample">ps</SPAN> с опциями <SPAN class="texample">–e</SPAN> и <SPAN class="texample">j</SPAN>, которая позволяет получить информацию обо всех процессах в системе и узнать их идентификаторы, идентификаторы <SPAN class="keyword">групп процессов</SPAN> и <SPAN class="keyword">сеансов</SPAN>, <SPAN class="keyword">управляющий терминал сеанса</SPAN> и к какой <SPAN class="keyword">группе процессов</SPAN> он приписан. Набрав команду <SPAN class="texample">"ps –e j"</SPAN> (<B>обратите внимание на наличие пробела между буквами e и j!!!</B>) мы получим список всех процессов в системе. Колонка PID содержит идентификаторы процессов, колонка PGID – идентификаторы <SPAN class="keyword">групп</SPAN>, к которым они принадлежат, колонка SID – идентификаторы <SPAN class="keyword">сеансов</SPAN>, колонка TTY – номер соответствующего <SPAN class="keyword">управляющего терминала</SPAN>, колонка TPGID (может присутствовать не во всех версиях 
UNIX, но в Linux есть) – к какой <SPAN class="keyword">группе процессов</SPAN> приписан <SPAN class="keyword">управляющий терминал</SPAN>. </P><DIV class="lecture_mark" id="mark_334"></DIV><P id="id_339">Наберите тривиальную программу, откомпилируйте ее и запустите на исполнение (лучше всего из-под оболочки Midnight Commander – mc). Запустив команду <SPAN class="texample">"ps –e j"</SPAN> с другого экрана, проанализируйте значения идентификаторов <SPAN class="keyword">группы процессов</SPAN>, <SPAN class="keyword">сеансов</SPAN>, прикрепления <SPAN class="keyword">управляющего терминала</SPAN>, <SPAN class="keyword">текущей</SPAN> и <SPAN class="keyword">фоновой групп</SPAN>. Убедитесь, что тривиальные процессы относятся к текущей <SPAN class="keyword">группе</SPAN> <SPAN class="keyword">сеанса</SPAN>. Проверьте реакцию текущей <SPAN class="keyword">группы</SPAN> на сигналы <SPAN class="texample"><SPAN class="keyword">SIGINT</SPAN></SPAN> – нажатие клавиш &lt;CTRL&gt; и &lt;C&gt; – и <SPAN class="texample"><SPAN class="keyword">SIGQUIT</SPAN></SPAN> – нажатие клавиш &lt;CTRL&gt; и &lt;4&gt;. </P><DIV class="lecture_mark" id="mark_339"></DIV><P id="id_343">Запустите теперь тривиальную программу в фоновом режиме, например командой <SPAN class="texample">"a.out &amp;"</SPAN>. Проанализируйте значения идентификаторов <SPAN class="keyword">группы процессов</SPAN>, <SPAN class="keyword">сеансов</SPAN>, прикрепления <SPAN class="keyword">управляющего терминала</SPAN>, <SPAN class="keyword">текущей</SPAN> и <SPAN class="keyword">фоновой групп</SPAN>. Убедитесь, что тривиальные процессы относятся к <SPAN class="keyword">фоновой группе</SPAN> <SPAN class="keyword">сеанса</SPAN>. Проверьте реакцию <SPAN class="keyword">фоновой группы</SPAN> на сигналы <SPAN class="texample"><SPAN class="keyword">SIGINT</SPAN></SPAN> – нажатие клавиш &lt;CTRL&gt; и &lt;C&gt; – и <SPAN class="texample"><SPAN class="keyword">SIGQUIT</SPAN></SPAN> – нажатие клавиш &lt;CTRL&gt; и &lt;4&gt;. Ликвидируйте тривиальные процессы с помощью команды <SPAN class="texample"><SPAN class="keyword">kill</SPAN></SPAN>.</P><DIV class="lecture_mark" id="mark_343"></DIV><A name="sect9"></A><H3>Изучение получения сигнала SIGHUP процессами при завершении лидера сеанса </H3><P id="id_348">Возьмите снова тривиальную программу из предыдущего раздела и запустите ее на исполнение из-под Midnight Commander в <SPAN class="keyword">текущей группе</SPAN>. Проанализировав значения идентификаторов <SPAN class="keyword">группы процессов</SPAN>, <SPAN class="keyword">сеансов</SPAN>, прикрепления <SPAN class="keyword">управляющего терминала</SPAN>, <SPAN class="keyword">текущей</SPAN> и <SPAN class="keyword">фоновой групп</SPAN>, ликвидируйте <SPAN class="keyword">лидера сеанса</SPAN> для тривиальных процессов. Убедитесь, что все процессы в <SPAN class="keyword">текущей группе</SPAN> этого <SPAN class="keyword">сеанса</SPAN> прекратили свою работу.</P><DIV class="lecture_mark" id="mark_348"></DIV><P id="id_349">Запустите тривиальную программу в фоновом режиме. Снова удалите <SPAN class="keyword">лидера сеанса</SPAN> для тривиальных процессов. Убедитесь, что <SPAN class="keyword">фоновая группа</SPAN> продолжает работать. Ликвидируйте тривиальные процессы.</P><DIV class="lecture_mark" id="mark_349"></DIV><A name="sect10"></A><H3>Системный вызов signal(). Установка собственного обработчика сигнала </H3><P id="id_350">Одним из способов изменения поведения процесса при получении <SPAN class="keyword">сигнала</SPAN> в операционной системе UNIX является использование системного вызова <SPAN class="texample"><SPAN class="keyword">signal()</SPAN></SPAN>. </P><DIV class="lecture_mark" id="mark_350"></DIV><DIV class="xml_table_env" id="id_352"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_353"><B>Системный вызов signal()</B></P><DIV class="lecture_mark" id="mark_353"></DIV>

<P id="id_354"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_354"></DIV>

<DIV class="example"><PRE>#include &lt;signal.h&gt;
void (*signal (int sig, 
      void (*handler) (int)))(int);
</PRE></DIV>

<P id="id_356"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_356"></DIV>

<P id="id_357"><A name="keyword-context.20"></A>Системный вызов <SPAN class="texample"><SPAN class="keyword_def">signal</SPAN></SPAN> служит для изменения реакции процесса на какой-либо <SPAN class="keyword">сигнал</SPAN>. Хотя прототип системного вызова выглядит довольно пугающе, ничего страшного в нем нет. Приведенное выше описание можно словесно изложить следующим образом:</P><DIV class="lecture_mark" id="mark_357"></DIV>

<P id="id_359">функция <SPAN class="texample">signal</SPAN>, возвращающая указатель на функцию с одним параметром типа <SPAN class="texample">int</SPAN>, которая ничего не возвращает, и имеющая два параметра: параметр <SPAN class="texample">sig</SPAN> типа <SPAN class="texample">int</SPAN> и параметр <SPAN class="texample">handler</SPAN>, служащий указателем на ничего не возвращающую функцию с одним параметром типа <SPAN class="texample">int</SPAN>. </P><DIV class="lecture_mark" id="mark_359"></DIV>

<P id="id_366">Параметр <SPAN class="texample">sig</SPAN> – это номер <SPAN class="keyword">сигнала</SPAN>, обработку которого предстоит изменить.</P><DIV class="lecture_mark" id="mark_366"></DIV>

<P id="id_368">Параметр <SPAN class="texample">handler</SPAN> описывает новый способ обработки <SPAN class="keyword">сигнала</SPAN> – это может быть указатель на пользовательскую функцию – обработчик <SPAN class="keyword">сигнала</SPAN>, специальное значение <SPAN class="texample">SIG_DFL</SPAN> или специальное значение <SPAN class="texample">SIG_IGN</SPAN>. Специальное значение <SPAN class="texample">SIG_IGN</SPAN> используется для того, чтобы процесс игнорировал поступившие <SPAN class="keyword">сигналы</SPAN> с номером <SPAN class="texample">sig</SPAN>, специальное значение <SPAN class="texample">SIG_DFL</SPAN> – для восстановления реакции процесса на этот <SPAN class="keyword">сигнал</SPAN> по умолчанию.</P><DIV class="lecture_mark" id="mark_368"></DIV>

<P id="id_375"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_375"></DIV>

<P id="id_376">Системный вызов возвращает указатель на старый способ обработки <SPAN class="keyword">сигнала</SPAN>, значение которого можно использовать для восстановления старого способа в случае необходимости. </P><DIV class="lecture_mark" id="mark_376"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_352"></DIV><P id="id_377">Этот системный вызов имеет два параметра: один из них задает номер <SPAN class="keyword">сигнала</SPAN>, реакцию процесса на который требуется изменить, а второй определяет, как именно мы собираемся ее менять. Для первого варианта реакции процесса на <SPAN class="keyword">сигнал</SPAN> (см. раздел "Понятие <SPAN class="keyword">сигнала</SPAN>. Способы возникновения <SPAN class="keyword">сигналов</SPAN> и виды их обработки") – его игнорирования – применяется специальное значение этого параметра <SPAN class="texample">SIG_IGN</SPAN>. Например, если требуется игнорировать сигнал <SPAN class="texample"><SPAN class="keyword">SIGINT</SPAN></SPAN>, начиная с некоторого места работы программы, в этом месте программы мы должны употребить конструкцию</P><DIV class="lecture_mark" id="mark_377"></DIV><DIV class="example"><PRE>(void) signal(SIGINT, SIG_IGN); 
</PRE></DIV><P id="id_381">Для второго варианта реакции процесса на <SPAN class="keyword">сигнал</SPAN> – восстановления его обработки по умолчанию – применяется специальное значение этого параметра <SPAN class="texample">SIG_DFL</SPAN>. Для третьего варианта реакции процесса на <SPAN class="keyword">сигнал</SPAN> в качестве значения параметра подставляется указатель на пользовательскую функцию обработки <SPAN class="keyword">сигнала</SPAN>, которая должна иметь прототип вида</P><DIV class="lecture_mark" id="mark_381"></DIV><DIV class="example"><PRE>void *handler(int); 
</PRE></DIV><P id="id_384">Ниже приведен пример скелета конструкции для пользовательской обработки сигнала <SPAN class="texample"><SPAN class="keyword">SIGHUP</SPAN></SPAN>. </P><DIV class="lecture_mark" id="mark_384"></DIV><DIV class="example"><PRE>void *my_handler(int nsig) { 
    &lt;обработка сигнала&gt; 
}
int main() { 
    ...
    (void)signal(SIGHUP, my_handler);
    ... 
} 
</PRE></DIV><P id="id_387">В качестве значения параметра в пользовательскую функцию обработки <SPAN class="keyword">сигнала</SPAN> (в нашем скелете – параметр <SPAN class="texample">nsig</SPAN>) передается номер возникшего <SPAN class="keyword">сигнала</SPAN>, так что одна и та же функция может быть использована для обработки нескольких <SPAN class="keyword">сигналов</SPAN>.</P><DIV class="lecture_mark" id="mark_387"></DIV><A name="sect11"></A><H3>Прогон программы, игнорирующей сигнал SIGINT </H3><P id="id_389">Рассмотрим следующую программу – <SPAN class="texample">13–14-2.c</SPAN>:</P><DIV class="lecture_mark" id="mark_389"></DIV><A name="example.13-14.2"></A><DIV class="example"><PRE>/* Программа, игнорирующая сигнал SIGINT */
#include &lt;signal.h&gt;
int main(void){ 
    /* Выставляем реакцию процесса на сигнал
       SIGINT на игнорирование */ 
    (void)signal(SIGINT, SIG_IGN);
    /*Начиная с этого места, процесс будет 
      игнорировать возникновение сигнала 
      SIGINT */ 
    while(1);
    return 0;
}
</PRE><SPAN class="objectName">
            Листинг 
            13-14.2.
            Программа (13–14-2.c), игнорирующая сигнал SIGINT.</SPAN></DIV><P id="id_392">Эта программа не делает ничего полезного, кроме переустановки реакции на нажатие клавиш &lt;CTRL&gt; и &lt;C&gt; на игнорирование возникающего <SPAN class="keyword">сигнала</SPAN> и своего бесконечного зацикливания. Наберите, откомпилируйте и запустите эту программу, убедитесь, что на нажатие клавиш &lt;CTRL&gt; и &lt;C&gt; она не реагирует, а реакция на нажатие клавиш &lt;CTRL&gt; и &lt;4&gt; осталась прежней.</P><DIV class="lecture_mark" id="mark_392"></DIV><A name="sect12"></A><H3>Модификация предыдущей программы для игнорирования сигналов SIGINT и SIGQUIT </H3><P id="id_393">Модифицируйте программу из предыдущего раздела так, чтобы она перестала реагировать и на нажатие клавиш &lt;CTRL&gt; и &lt;4&gt;. Откомпилируйте и запустите ее, убедитесь в отсутствии ее реакций на внешние раздражители. Снимать программу придется теперь с другого терминала командой <SPAN class="texample"><SPAN class="keyword">kill</SPAN></SPAN>.</P><DIV class="lecture_mark" id="mark_393"></DIV><A name="sect13"></A><H3>Прогон программы с пользовательской обработкой сигнала SIGINT </H3><P id="id_395">Рассмотрим теперь другую программу – <SPAN class="texample">13–14-3.c</SPAN>:</P><DIV class="lecture_mark" id="mark_395"></DIV><A name="example.13-14.3"></A><DIV class="example"><PRE>/* Программа с пользовательской обработкой
   сигнала SIGINT */
#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
/* Функция my_handler – пользовательский 
   обработчик сигнала */ 
void my_handler(int nsig){ 
    printf("Receive signal %d, 
           CTRL-C pressed\n", nsig);
}
int main(void){ 
    /* Выставляем реакцию процесса на 
       сигнал SIGINT */ 
    (void)signal(SIGINT, my_handler);
    /*Начиная с этого места, процесс будет 
      печатать сообщение о возникновении 
      сигнала SIGINT */ 
    while(1);
    return 0;
} 
</PRE><SPAN class="objectName">
            Листинг 
            13-14.3.
            Программа (13–14-3.c) с пользовательской обработкой сигнала SIGINT.</SPAN></DIV><P id="id_398">Эта программа отличается от программы из раздела "Прогон программы, игнорирующей сигнал <SPAN class="texample"><SPAN class="keyword">SIGINT</SPAN></SPAN>" тем, что в ней введена обработка сигнала <SPAN class="texample"><SPAN class="keyword">SIGINT</SPAN></SPAN> пользовательской функцией. Наберите, откомпилируйте и запустите эту программу, проверьте ее реакцию на нажатие клавиш &lt;CTRL&gt; и &lt;C&gt; и на нажатие клавиш &lt;CTRL&gt; и &lt;4&gt;.</P><DIV class="lecture_mark" id="mark_398"></DIV><A name="sect14"></A><H3>Модификация предыдущей программы для пользовательской обработки сигналов SIGINT и SIGQUIT </H3><P id="id_401">Модифицируйте программу из предыдущего раздела так, чтобы она печатала сообщение и о нажатии клавиш &lt;CTRL&gt; и &lt;4&gt;. Используйте одну и ту же функцию для обработки сигналов <SPAN class="texample"><SPAN class="keyword">SIGINT</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">SIGQUIT</SPAN></SPAN>. Откомпилируйте и запустите ее, проверьте корректность работы. Снимать программу также придется с другого терминала командой <SPAN class="texample"><SPAN class="keyword">kill</SPAN></SPAN>.</P><DIV class="lecture_mark" id="mark_401"></DIV><A name="sect15"></A><H3>Восстановление предыдущей реакции на сигнал </H3><P id="id_405">До сих пор в примерах мы игнорировали значение, возвращаемое системным вызовом <SPAN class="texample"><SPAN class="keyword">signal()</SPAN></SPAN>. На самом деле этот системный вызов возвращает указатель на предыдущий обработчик <SPAN class="keyword">сигнала</SPAN>, что позволяет восстанавливать переопределенную реакцию на <SPAN class="keyword">сигнал</SPAN>. Рассмотрим пример программы <SPAN class="texample">13—14-4.c</SPAN>, возвращающей первоначальную реакцию на сигнал <SPAN class="texample"><SPAN class="keyword">SIGINT</SPAN></SPAN> после 5 пользовательских обработок <SPAN class="keyword">сигнала</SPAN>.</P><DIV class="lecture_mark" id="mark_405"></DIV><A name="example.13-14.4"></A><DIV class="example"><PRE>/* Программа с пользовательской обработкой 
сигнала SIGINT, возвращающаяся к первоначальной 
реакции на этот сигнал после 5 его обработок*/
#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
int i=0; /* Счетчик числа обработок сигнала */
void (*p)(int); /* Указатель, в который будет 
занесен адрес предыдущего обработчика сигнала */ 
/* Функция my_handler – пользовательский обработчик 
    сигнала */ 
void my_handler(int nsig){ 
    printf("Receive signal %d, CTRL-C pressed\n", nsig); 
    i = i+1;
    /* После 5-й обработки возвращаем первоначальную 
    реакцию на сигнал */
    if(i == 5) (void)signal(SIGINT, p);
}
int main(void){ 
    /* Выставляем свою реакцию процесса на сигнал 
SIGINT, запоминая адрес предыдущего обработчика */ 
    p = signal(SIGINT, my_handler);
    /*Начиная с этого места, процесс будет 5 раз 
печатать сообщение о возникновении сигнала SIGINT */ 
    while(1);
    return 0;
}
</PRE><SPAN class="objectName">
            Листинг 
            13-14.4.
            Программа (13—14-4.c) с пользовательской обработкой сигнала SIGINT.</SPAN></DIV><P id="id_410">Наберите, откомпилируйте программу и запустите ее на исполнение.</P><DIV class="lecture_mark" id="mark_410"></DIV><A name="sect16"></A><H3>Сигналы SIGUSR1 и SIGUSR2. Использование сигналов для синхронизации процессов </H3><P id="id_411">В операционной системе UNIX существует два <SPAN class="keyword">сигнала</SPAN>, источниками которых могут служить только системный вызов <SPAN class="texample"><SPAN class="keyword">kill()</SPAN></SPAN> или команда <SPAN class="texample"><SPAN class="keyword">kill</SPAN></SPAN>, – это сигналы <SPAN class="texample"><SPAN class="keyword">SIGUSR1</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">SIGUSR2</SPAN></SPAN>. Обычно их применяют для передачи информации о происшедшем событии от одного пользовательского процесса другому в качестве сигнального средства связи. </P><DIV class="lecture_mark" id="mark_411"></DIV><P id="id_416">В материалах семинара 5 (раздел "Написание, компиляция и запуск программы для организации двунаправленной связи между родственными процессами через pipe"), когда рассматривалась связь родственных процессов через pipe, речь шла о том, что pipe является однонаправленным каналом связи, и что для организации связи через один pipe в двух направлениях необходимо задействовать механизмы взаимной синхронизации процессов. Организуйте двустороннюю поочередную связь процесса-родителя и процесса-ребенка через pipe, используя для синхронизации сигналы <SPAN class="texample"><SPAN class="keyword">SIGUSR1</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">SIGUSR2</SPAN></SPAN>, модифицировав программу из раздела. "Прогон программы для организации однонаправленной связи между родственными процессами через pipe" семинара 5.</P><DIV class="lecture_mark" id="mark_416"></DIV><P id="id_419"><B>Задача повышенной сложности:</B> организуйте побитовую передачу целого числа между двумя процессами, используя для этого только сигналы <SPAN class="texample"><SPAN class="keyword">SIGUSR1</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">SIGUSR2</SPAN></SPAN>. </P><DIV class="lecture_mark" id="mark_419"></DIV><P id="id_422">При реализации нитей исполнения в операционной системе Linux (см. семинары 6–7, начиная с раздела "Понятие о нити исполнения (thread) в UNIX. Идентификатор нити исполнения. Функция <SPAN class="texample">pthread_self()</SPAN>") сигналы <SPAN class="texample"><SPAN class="keyword">SIGUSR1</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">SIGUSR2</SPAN></SPAN> используются для организации синхронизации между процессами, представляющими нити исполнения, и процессом-координатором в служебных целях. Поэтому пользовательские программы, применяющие в своей работе нити исполнения, <B>не могут задействовать</B> сигналы <SPAN class="texample"><SPAN class="keyword">SIGUSR1</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">SIGUSR2</SPAN></SPAN>.</P><DIV class="lecture_mark" id="mark_422"></DIV><A name="sect17"></A><H3>Завершение порожденного процесса. Системный вызов waitpid(). Сигнал SIGCHLD</H3><P id="id_428">В материалах семинаров 3–4 (раздел "Завершение процесса. Функция <SPAN class="texample">exit()</SPAN>") при изучении завершения процесса говорилось о том, что если процесс-ребенок завершает свою работу прежде процесса-родителя, и процесс-родитель явно не указал, что он не заинтересован в получении информации о статусе завершения процесса-ребенка, то завершившийся процесс не исчезает из системы окончательно, а остается в состоянии <B>закончил исполнение</B> (зомби-процесс) либо до завершения процесса-родителя, либо до того момента, когда родитель соблаговолит получить эту информацию.</P><DIV class="lecture_mark" id="mark_428"></DIV><P id="id_430">Для получения такой информации процесс-родитель может воспользоваться системным вызовом <SPAN class="texample"><SPAN class="keyword">waitpid()</SPAN></SPAN> или его упрощенной формой <SPAN class="texample"><SPAN class="keyword">wait()</SPAN></SPAN>. Системный вызов <SPAN class="texample"><SPAN class="keyword">waitpid()</SPAN></SPAN> позволяет процессу-родителю синхронно получить данные о статусе завершившегося процесса-ребенка либо блокируя процесс-родитель до завершения процесса-ребенка, либо без блокировки при его периодическом вызове с опцией WNOHANG. Эти данные занимают 16 бит и в рамках нашего курса могут быть расшифрованы следующим образом:</P><DIV class="lecture_mark" id="mark_430"></DIV><UL id="id_434"><LI>Если процесс завершился при помощи явного или неявного вызова функции <SPAN class="texample">exit()</SPAN>, то данные выглядят так (старший бит находится слева)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:
    <P align="left" id="id_437"><A name=""></A></P><DIV><IMG src="./9. Организация ввода-вывода в UNIX. Файлы устройств. Аппарат прерываний. Сигналы в UNIX_files/13-14-2.gif" alt=""></DIV><BR><P></P><DIV class="lecture_mark" id="mark_437"></DIV>
</LI><LI>Если процесс был завершен <SPAN class="keyword">сигналом</SPAN>, то данные выглядят так (старший бит находится слева):
    <P align="left" id="id_439"><A name=""></A></P><DIV><IMG src="./9. Организация ввода-вывода в UNIX. Файлы устройств. Аппарат прерываний. Сигналы в UNIX_files/13-14-3.gif" alt=""></DIV><BR><P></P><DIV class="lecture_mark" id="mark_439"></DIV>
</LI></UL><DIV class="lecture_mark" id="mark_434"></DIV><P id="id_440">Каждый процесс-ребенок при завершении работы посылает своему процессу-родителю специальный сигнал <SPAN class="texample"><SPAN class="keyword">SIGCHLD</SPAN></SPAN>, на который у всех процессов по умолчанию установлена реакция "игнорировать <SPAN class="keyword">сигнал</SPAN>". Наличие такого <SPAN class="keyword">сигнала</SPAN> совместно с системным вызовом <SPAN class="texample"><SPAN class="keyword">waitpid()</SPAN></SPAN> позволяет организовать асинхронный сбор информации о статусе завершившихся порожденных процессов процессом-родителем.</P><DIV class="lecture_mark" id="mark_440"></DIV><DIV class="xml_table_env" id="id_443"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_444"><B>Системные вызовы wait() и waitpid()</B></P><DIV class="lecture_mark" id="mark_444"></DIV>

<P id="id_445"><B>Прототипы системных вызовов</B></P><DIV class="lecture_mark" id="mark_445"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;wait.h&gt;
pid_t waitpid(pid_t pid, int *status, 
              int options);
pid_t wait(int *status);
</PRE></DIV>

<P id="id_447"><B>Описание системных вызовов</B></P><DIV class="lecture_mark" id="mark_447"></DIV>

<P id="id_448">Это описание не является полным описанием системных вызовов, а адаптировано применительно к нашему курсу. Для получения полного описания обращайтесь к UNIX Manual. </P><DIV class="lecture_mark" id="mark_448"></DIV>

<P id="id_449"><A name="keyword-context.21"></A>Системный вызов <SPAN class="texample"><SPAN class="keyword_def">waitpid()</SPAN></SPAN> блокирует выполнение текущего процесса до тех пор, пока либо не завершится порожденный им процесс, определяемый значением параметра <SPAN class="texample">pid</SPAN>, либо текущий процесс не получит <SPAN class="keyword">сигнал</SPAN>, для которого установлена реакция по умолчанию "завершить процесс" или реакция обработки пользовательской функцией. Если порожденный процесс, заданный параметром <SPAN class="texample">pid</SPAN>, к моменту системного вызова находится в состоянии закончил исполнение, то системный вызов возвращается немедленно без блокирования текущего процесса.</P><DIV class="lecture_mark" id="mark_449"></DIV>

<P id="id_453">Параметр <SPAN class="texample">pid</SPAN> определяет порожденный процесс, завершения которого дожидается процесс-родитель, следующим образом:</P><DIV class="lecture_mark" id="mark_453"></DIV>

<UL id="id_455"><LI>Если <SPAN class="texample">pid &gt; 0</SPAN> ожидаем завершения процесса с идентификатором <SPAN class="texample">pid</SPAN>. </LI><LI>Если <SPAN class="texample">pid = 0</SPAN>, то ожидаем завершения любого порожденного процесса в <SPAN class="keyword">группе</SPAN>, к которой принадлежит процесс-родитель. </LI><LI>Если <SPAN class="texample">pid = -1</SPAN>, то ожидаем завершения любого порожденного процесса. </LI><LI>Если <SPAN class="texample">pid &lt; 0</SPAN>, но не <SPAN class="texample">–1</SPAN>, то ожидаем завершения любого порожденного процесса из <SPAN class="keyword">группы</SPAN>, идентификатор которой равен абсолютному значению параметра <SPAN class="texample">pid</SPAN>.</LI></UL><DIV class="lecture_mark" id="mark_455"></DIV>

<P id="id_467">Параметр <SPAN class="texample">options</SPAN> в нашем курсе может принимать два значения: <SPAN class="texample">0</SPAN> и <SPAN class="texample">WNOHANG</SPAN>. Значение <SPAN class="texample">WNOHANG</SPAN> требует немедленного возврата из вызова без блокировки текущего процесса в любом случае. </P><DIV class="lecture_mark" id="mark_467"></DIV>

<P id="id_472">Если системный вызов обнаружил завершившийся порожденный процесс, из числа специфицированных параметром <SPAN class="texample">pid</SPAN>, то этот процесс удаляется из вычислительной системы, а по адресу, указанному в параметре status, сохраняется информация о статусе его завершения. Параметр <SPAN class="texample">status</SPAN> может быть задан равным <SPAN class="texample">NULL</SPAN>, если эта информация не имеет для нас значения.</P><DIV class="lecture_mark" id="mark_472"></DIV>

<P id="id_476">При обнаружении завершившегося процесса системный вызов возвращает его идентификатор. Если вызов был сделан с установленной опцией <SPAN class="texample">WNOHANG</SPAN>, и порожденный процесс, специфицированный параметром <SPAN class="texample">pid</SPAN>, существует, но еще не завершился, системный вызов вернет значение <SPAN class="texample">0</SPAN>. Во всех остальных случаях он возвращает отрицательное значение. Возврат из вызова, связанный с возникновением обработанного пользователем <SPAN class="keyword">сигнала</SPAN>, может быть в этом случае идентифицирован по значению системной переменной <SPAN class="texample">errno == EINTR</SPAN>, и вызов может быть сделан снова.</P><DIV class="lecture_mark" id="mark_476"></DIV>

<P id="id_481">Системный вызов <SPAN class="texample">wait</SPAN> является синонимом для системного вызова <SPAN class="texample">waitpid</SPAN> со значениями параметров <SPAN class="texample">pid = -1</SPAN>, <SPAN class="texample">options = 0</SPAN>. </P><DIV class="lecture_mark" id="mark_481"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_443"></DIV><P id="id_486">Используя системный вызов <SPAN class="texample"><SPAN class="keyword">signal()</SPAN></SPAN>, мы можем явно установить игнорирование этого <SPAN class="keyword">сигнала</SPAN> (<SPAN class="texample">SIG_IGN</SPAN>), тем самым проинформировав систему, что нас не интересует, каким образом завершатся порожденные процессы. В этом случае зомби-процессов возникать не будет, но и применение системных вызовов <SPAN class="texample"><SPAN class="keyword">wait()</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">waitpid()</SPAN></SPAN> будет запрещено.</P><DIV class="lecture_mark" id="mark_486"></DIV><A name="sect18"></A><H3>Прогон программы для иллюстрации обработки сигнала SIGCHLD </H3><P id="id_491">Для закрепления материала рассмотрим пример программы <SPAN class="texample">13—14-5.c</SPAN> с асинхронным получением информации о статусе завершения порожденного процесса.</P><DIV class="lecture_mark" id="mark_491"></DIV><A name="example.13-14.5"></A><DIV class="example"><PRE>/* Программа с асинхронным получением информации о 
статусе двух завершившихся порожденных процессов */
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;waith&gt;
#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
/* Функция my_handler – обработчик сигнала SIGCHLD */ 
void my_handler(int nsig){
    int status;
    pid_t pid;
    /* Опрашиваем статус завершившегося процесса и 
    одновременно узнаем его идентификатор */ 
    if((pid = waitpid(-1, &amp;status, 0)) &lt; 0){
        /* Если возникла ошибка – сообщаем о ней и 
        продолжаем работу */ 
        printf("Some error on waitpid errno = %d\n", 
            errno);
    } else {
        /* Иначе анализируем статус завершившегося процесса */ 
        if ((status &amp; 0xff) == 0) {
            /* Процесс завершился с явным или неявным 
вызовом функции exit() */ 
            printf("Process %d was exited with status %d\n", 
            pid, status &gt;&gt; 8);
        } else if ((status &amp; 0xff00) == 0){
            /* Процесс был завершен с помощью сигнала */ 
            printf("Process %d killed by signal %d %s\n", 
            pid, status &amp;0x7f,(status &amp; 0x80) ? 
            "with core file" : "without core file");
        }
    }
}
int main(void){
    pid_t pid;
    /* Устанавливаем обработчик для сигнала SIGCHLD */ 
    (void) signal(SIGCHLD, my_handler);
    /* Порождаем Сhild 1 */ 
    if((pid = fork()) &lt; 0){
        printf("Can\'t fork child 1\n");
        exit(1);
    } else if (pid == 0){
        /* Child 1 – завершается с кодом 200 */
        exit(200);
    }
    /* Продолжение процесса-родителя – порождаем Сhild 2 */ 
    if((pid = fork()) &lt; 0){
        printf("Can\'t fork child 2\n");
        exit(1);
    } else if (pid == 0){
        /* Child 2 – циклится, необходимо удалять с помощью 
        сигнала! */
        while(1);
    }
    /* Продолжение процесса-родителя – уходим в цикл */ 
    while(1);
    return 0;
}
</PRE><SPAN class="objectName">
            Листинг 
            13-14.5.
            Программа (13—14-5.c) с асинхронным получением информации о статусе двух завершившихся порожденных процессов.</SPAN></DIV><P id="id_494">В этой программе родитель порождает два процесса. Один из них завершается с кодом 200, а второй зацикливается. Перед порождением процессов родитель устанавливает обработчик прерывания для сигнала <SPAN class="texample"><SPAN class="keyword">SIGCHLD</SPAN></SPAN>, а после их порождения уходит в бесконечный цикл. В обработчике прерывания вызывается <SPAN class="texample"><SPAN class="keyword">waitpid()</SPAN></SPAN> для любого порожденного процесса. Так как в обработчик мы попадаем, когда какой-либо из процессов завершился, системный вызов не блокируется, и мы можем получить информацию об идентификаторе завершившегося процесса и причине его завершения. Откомпилируйте программу и запустите ее на исполнение. Второй порожденный процесс завершайте с помощью команды <SPAN class="texample"><SPAN class="keyword">kill</SPAN></SPAN> с каким-либо номером <SPAN class="keyword">сигнала</SPAN>. Родительский процесс также будет необходимо завершать командой <SPAN class="texample"><SPAN class="keyword">kill</SPAN></SPAN>.</P><DIV class="lecture_mark" id="mark_494"></DIV><A name="sect19"></A><H3>Возникновение сигнала SIGPIPE при попытке записи в pipe или FIFO, который никто не собирается читать </H3><P id="id_499">В материалах семинара 5 (раздел "Особенности поведения вызовов <SPAN class="texample">read()</SPAN> и <SPAN class="texample">write()</SPAN> для pip'а") при обсуждении работы с pip'ами и FIFO мы говорили, что для них системные вызовы <SPAN class="texample">read()</SPAN> и <SPAN class="texample">write()</SPAN> имеют определенные особенности поведения. Одной из таких особенностей является получение сигнала <SPAN class="texample"><SPAN class="keyword">SIGPIPE</SPAN></SPAN> процессом, который пытается записывать информацию в pipe или в FIFO в том случае, когда читать ее уже некому (нет ни одного процесса, который держит соответствующий pipe или FIFO открытым для чтения). <B>Реакция по умолчанию на этот</B> <SPAN class="keyword">сигнал</SPAN> <B>– прекратить работу процесса</B>. Теперь мы уже можем написать корректную обработку этого <SPAN class="keyword">сигнала</SPAN> пользователем, например, для элегантного прекращения работы пишущего процесса. Однако для полноты картины необходимо познакомиться с особенностями поведения некоторых системных вызовов при 
получении процессом <SPAN class="keyword">сигналов</SPAN> во время их выполнения.</P><DIV class="lecture_mark" id="mark_499"></DIV><P id="id_505">По ходу нашего курса мы представили читателям ряд системных вызовов, которые могут во время выполнения блокировать процесс. К их числу относятся системный вызов <SPAN class="texample">open()</SPAN> при открытии FIFO, системные вызовы <SPAN class="texample">read()</SPAN> и <SPAN class="texample">write()</SPAN> при работе с pip'ами и FIFO, системные вызовы <SPAN class="texample">msgsnd()</SPAN> и <SPAN class="texample">msgrcv()</SPAN> при работе с очередями сообщений, системный вызов <SPAN class="texample">semop()</SPAN> при работе с семафорами и т.д. Что произойдет с процессом, если он, выполняя один из этих системных вызовов, получит какой-либо <SPAN class="keyword">сигнал</SPAN>? Дальнейшее поведение процесса зависит от установленной для него реакции на этот <SPAN class="keyword">сигнал</SPAN>. </P><DIV class="lecture_mark" id="mark_505"></DIV><UL id="id_512"><LI>Если реакция на полученный <SPAN class="keyword">сигнал</SPAN> была "игнорировать <SPAN class="keyword">сигнал</SPAN>" (независимо от того, установлена она по умолчанию или пользователем с помощью системного вызова <SPAN class="texample"><SPAN class="keyword">signal()</SPAN></SPAN>), то поведение процесса не изменится. </LI><LI>Если реакция на полученный <SPAN class="keyword">сигнал</SPAN> установлена по умолчанию и заключается в прекращении работы процесса, то процесс перейдет в состояние <B>закончил исполнение.</B> </LI><LI>Если реакция процесса на <SPAN class="keyword">сигнал</SPAN> заключается в выполнении пользовательской функции, то процесс выполнит эту функцию (если он находился в состоянии <SPAN class="texample">ожидание</SPAN>, он попадет в состояние <SPAN class="texample">готовность</SPAN> и затем в состояние <SPAN class="texample">исполнение</SPAN>) и вернется из системного вызова с констатацией ошибочной ситуации (некоторые системные вызовы позволяют операционной системе после выполнения обработки <SPAN class="keyword">сигнала</SPAN> вновь вернуть процесс в состояние ожидания). Отличить такой возврат от действительно ошибочной ситуации можно с помощью значения системной переменной <SPAN class="texample">errno</SPAN>, которая в этом случае примет значение <SPAN class="texample">EINTR</SPAN> (для вызова write и сигнала <SPAN class="texample"><SPAN class="keyword">SIGPIPE</SPAN></SPAN> соответствующее значение в порядке исключения будет <SPAN class="texample">EPIPE</SPAN>).</LI></UL><DIV class="lecture_mark" id="mark_512"></DIV><P id="id_524">После этого краткого обсуждения становится до конца ясно, как корректно обработать ситуацию "никто не хотел прочитать" для системного вызова <SPAN class="texample">write()</SPAN>. Чтобы пришедший сигнал <SPAN class="texample"><SPAN class="keyword">SIGPIPE</SPAN></SPAN> не завершил работу нашего процесса по умолчанию, мы должны его обработать самостоятельно (функция-обработчик при этом может быть и пустой!). Но этого мало. Поскольку нормальный ход выполнения системного вызова был нарушен <SPAN class="keyword">сигналом</SPAN>, мы вернемся из него с отрицательным значением, которое свидетельствует об ошибке. Проанализировав значение системной переменной <SPAN class="texample">errno</SPAN> на предмет совпадения со значением <SPAN class="texample">EPIPE</SPAN>, мы можем отличить возникновение сигнала <SPAN class="texample"><SPAN class="keyword">SIGPIPE</SPAN></SPAN> от других ошибочных ситуаций (неправильные значения параметров и т.д.) и грациозно продолжить работу программы.</P><DIV class="lecture_mark" id="mark_524"></DIV><A name="sect20"></A><H3>Понятие о надежности сигналов. POSIX функции для работы с сигналами </H3><P id="id_530">Основным недостатком системного вызова <SPAN class="texample"><SPAN class="keyword">signal()</SPAN></SPAN> является его низкая надежность. </P><DIV class="lecture_mark" id="mark_530"></DIV><P id="id_532">Во многих вариантах операционной системы UNIX установленная при его помощи обработка <SPAN class="keyword">сигнала</SPAN> пользовательской функцией выполняется только один раз, после чего автоматически восстанавливается реакция на <SPAN class="keyword">сигнал</SPAN> по умолчанию. Для постоянной пользовательской обработки <SPAN class="keyword">сигнала</SPAN> необходимо каждый раз заново устанавливать реакцию на <SPAN class="keyword">сигнал</SPAN> прямо внутри функции-обработчика.</P><DIV class="lecture_mark" id="mark_532"></DIV><P id="id_533">В системных вызовах и пользовательских программах могут существовать критические участки, на которых процессу недопустимо отвлекаться на обработку <SPAN class="keyword">сигналов</SPAN>. Мы можем выставить на этих участках реакцию "игнорировать <SPAN class="keyword">сигнал</SPAN>" с последующим восстановлением предыдущей реакции, но если <SPAN class="keyword">сигнал</SPAN> все-таки возникнет на критическом участке, то информация о его возникновении будет безвозвратно потеряна. </P><DIV class="lecture_mark" id="mark_533"></DIV><P id="id_534">Наконец, последний недостаток связан с невозможностью определения количества <SPAN class="keyword">сигналов</SPAN> одного и того же типа, поступивших процессу, пока он находился в состоянии <B>готовность</B>. <SPAN class="keyword">Сигналы</SPAN> одного типа в очередь не ставятся! Процесс может узнать о том, что <SPAN class="keyword">сигнал</SPAN> или <SPAN class="keyword">сигналы</SPAN> определенного типа были ему переданы, но не может определить их количество. Этот недостаток мы можем проиллюстрировать, слегка изменив программу с асинхронным получением информации о статусе завершившихся процессов, рассмотренную нами ранее в разделе "Изучение особенностей получения терминальных <SPAN class="keyword">сигналов</SPAN> <SPAN class="keyword">текущей</SPAN> и <SPAN class="keyword">фоновой группой процессов</SPAN>". Пусть в новой программе <SPAN class="texample">13–14-6.c</SPAN> процесс-родитель порождает в цикле пять новых процессов, каждый из которых сразу же завершается со своим собственным кодом, после чего уходит в бесконечный цикл.</P><DIV class="lecture_mark" id="mark_534"></DIV><A name="example.13-14.6"></A><DIV class="example"><PRE>/* Программа для иллюстрации ненадежности сигналов */
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;waith&gt;
#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
/* Функция my_handler – обработчик сигнала SIGCHLD */ 
void my_handler(int nsig){
    int status;
    pid_t pid;
    /* Опрашиваем статус завершившегося процесса и одновременно 
    узнаем его идентификатор */ 
    if((pid = waitpid(-1, &amp;status, 0)) &lt; 0){
        /* Если возникла ошибка – сообщаем о ней и продолжаем 
        работу */ 
        printf("Some error on waitpid errno = %d\n", errno);
    } else {
        /* Иначе анализируем статус завершившегося процесса */ 
        if ((status &amp; 0xff) == 0) {
            /* Процесс завершился с явным или неявным вызовом 
            функции exit() */ 
            printf("Process %d was exited with status %d\n", 
            pid, status &gt;&gt; 8);
        } else if ((status &amp; 0xff00) == 0){
            /* Процесс был завершен с помощью сигнала */ 
            printf("Process %d killed by signal %d %s\n", 
            pid, status &amp;0x7f,(status &amp; 0x80) ? 
            "with core file" : "without core file");
        }
    }
}
int main(void){
    pid_t pid;
    int i;
    /* Устанавливаем обработчик для сигнала SIGCHLD */ 
    (void) signal(SIGCHLD, my_handler);
    /* В цикле порождаем 5 процессов-детей */ 
    for (i=0; i
        if((pid = fork()) &lt; 0){
            printf("Can\'t fork child %d\n", i);
            exit(1);
        } else if (pid == 0){
            /* Child i – завершается с кодом 200 + i */
            exit(200 + i);
        }
        /* Продолжение процесса-родителя – уходим на новую 
        итерацию */ 
    }
    /* Продолжение процесса-родителя – уходим в цикл */ 
    while(1);
    return 0;
}
</PRE><SPAN class="objectName">
            Листинг 
            13-14.6.
            Программа (13–14-6.c) для иллюстрации ненадежности сигналов.</SPAN></DIV><P id="id_537">Сколько сообщений о статусе завершившихся детей мы ожидаем получить? Пять! А сколько получим? It depends... Откомпилируйте, прогоните и посчитайте. </P><DIV class="lecture_mark" id="mark_537"></DIV><P id="id_538">Последующие версии System V и BSD пытались устранить эти недостатки собственными средствами. Единый способ более надежной обработки <SPAN class="keyword">сигналов</SPAN> появился с введением POSIX стандарта на системные вызовы UNIX. Набор функций и системных вызовов для работы с <SPAN class="keyword">сигналами</SPAN> был существенно расширен и построен таким образом, что позволял временно блокировать обработку определенных <SPAN class="keyword">сигналов</SPAN>, не допуская их потери. Однако проблема, связанная с определением количества пришедших <SPAN class="keyword">сигналов</SPAN> одного типа, по-прежнему остается актуальной. (Надо отметить, что подобная проблема существует на аппаратном уровне и для внешних прерываний. Процессор зачастую не может определить, какое количество внешних прерываний с одним номером возникло, пока он выполнял очередную команду.) </P><DIV class="lecture_mark" id="mark_538"></DIV><P id="id_539">Рассмотрение <SPAN class="keyword">POSIX сигналов</SPAN> выходит за рамки нашего курса. Желающие могут самостоятельно просмотреть описания функций и системных вызовов <SPAN class="texample">sigemptyset()</SPAN>, <SPAN class="texample">sigfillset()</SPAN>, <SPAN class="texample">sigaddset()</SPAN>, <SPAN class="texample">sigdelset()</SPAN>, <SPAN class="texample">sigismember()</SPAN>, <SPAN class="texample">sigaction()</SPAN>, <SPAN class="texample">sigprocmask()</SPAN>, <SPAN class="texample">sigpending()</SPAN>, <SPAN class="texample">sigsuspend()</SPAN> в UNIX Manual.</P><DIV class="lecture_mark" id="mark_539"></DIV><P id="id_549"><B>Задача повышенной сложности:</B> модифицируйте обработку <SPAN class="keyword">сигнала</SPAN> в программе из этого раздела, не применяя <SPAN class="keyword">POSIX-сигналы</SPAN>, так, чтобы процесс-родитель все-таки сообщал о статусе всех завершившихся процессов-детей. </P><DIV class="lecture_mark" id="mark_549"></DIV>


	</TD>
	</TR>
	<TR><TD height="8"><IMG src="./9. Организация ввода-вывода в UNIX. Файлы устройств. Аппарат прерываний. Сигналы в UNIX_files/empty.gif" width="1" height="8"></TD></TR>
	</TBODY></TABLE>
	<!-- /content -->

</TD>
<TD><IMG src="./9. Организация ввода-вывода в UNIX. Файлы устройств. Аппарат прерываний. Сигналы в UNIX_files/empty.gif" width="8" height="1"></TD>
</TR>
</TBODY></TABLE>
<!-- /bottom -->
<TABLE border="0" cellpadding="0" cellspacing="0" width="100%">
<TBODY><TR><TD class="orang" height="1"><IMG src="./9. Организация ввода-вывода в UNIX. Файлы устройств. Аппарат прерываний. Сигналы в UNIX_files/empty.gif" width="1" height="1"></TD></TR>
<TR><TD class="ltxt" align="center">© INTUIT.ru, 2003-2009. Все права защищены.</TD>
</TR>
</TBODY></TABLE>
<!-- /bottom -->

<SCRIPT src="./9. Организация ввода-вывода в UNIX. Файлы устройств. Аппарат прерываний. Сигналы в UNIX_files/urchin.js" type="text/javascript">
</SCRIPT>
<SCRIPT type="text/javascript">
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>


</BODY></HTML>