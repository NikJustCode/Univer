
<!-- saved from url=(0075)http://www.intuit.ru/department/os/osintropractice/1/osintropractice_1.html -->
<HTML><HEAD><META http-equiv="Content-Type" content="text/html; charset=windows-1251">

<TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<LINK href="./1. Введение в курс практических занятий. Знакомство с операционной системой UNIX_files/printable.css" type="text/css" rel="stylesheet">
</HEAD><BODY leftmargin="6" topmargin="6" marginheight="6" marginwidth="6">

<DIV align="left">
<SPAN style="color: #000000; font-weight: bold;">
&nbsp;&nbsp;
<SPAN style="font-size:12pt;">Интернет-Университет Информационных Технологий</SPAN>
</SPAN>
</DIV>

&nbsp;&nbsp;
<SPAN align="rright" style="color: #330066; text-decoration:underline;">http://www.INTUIT.ru</SPAN>


<TABLE border="0" cellpadding="0" cellspacing="0" width="100%">
<TBODY><TR><TD height="8" colspan="3"><IMG src="./1. Введение в курс практических занятий. Знакомство с операционной системой UNIX_files/empty.gif" width="1" height="8"></TD></TR>
<TR><TD class="orang" height="1" colspan="3"><IMG src="./1. Введение в курс практических занятий. Знакомство с операционной системой UNIX_files/empty.gif" width="1" height="1"></TD></TR>
<TR><TD height="8" colspan="3"><IMG src="./1. Введение в курс практических занятий. Знакомство с операционной системой UNIX_files/empty.gif" width="1" height="8"></TD></TR>
<TR valign="top">
<TD><IMG src="./1. Введение в курс практических занятий. Знакомство с операционной системой UNIX_files/empty.gif" width="8" height="1"></TD>
<TD>
	<!-- content -->
	<TABLE border="0" cellpadding="0" cellspacing="0" width="100%">
	<TBODY><TR><TD class="head">Основы операционных систем. Практикум</TD></TR>
<TR><TD height="4"><IMG src="./1. Введение в курс практических занятий. Знакомство с операционной системой UNIX_files/empty.gif" width="1" height="4"></TD></TR>
	<TR><TD class="orang" height="1"><IMG src="./1. Введение в курс практических занятий. Знакомство с операционной системой UNIX_files/empty.gif" width="1" height="1"></TD></TR>
	<TR><TD height="8"><IMG src="./1. Введение в курс практических занятий. Знакомство с операционной системой UNIX_files/empty.gif" width="1" height="8"></TD></TR>
	<TR><TD><SPAN class="headsub">


1. Лекция:

 Введение в курс практических занятий. Знакомство с операционной системой UNIX: версия для печати и PDA</SPAN>

<BR>
<SPAN class="rtxt">Введение в курс практических занятий. Краткая история операционной системы UNIX, ее структура. Системные вызовы и библиотека libc. Понятия login и password. Упрощенное понятие об устройстве файловой системы в UNIX. Полные имена файлов. Понятие о текущей директории. Команда pwd. Относительные имена файлов. Домашняя директория пользователя и ее определение. Команда man – универсальный справочник. Команды cd – смены текущей директории и ls – просмотра состава директории. Команда cat и создание файла. Перенаправление ввода и вывода. Простейшие команды для работы с файлами – cp, rm, mkdir, mv. История редактирования файлов – ed, vi. Система Midnight Commander – mc. Встроенный mc редактор и редактор joe. Пользователь и группа. Команды chown и chgrp. Права доступа к файлу. Команда ls с опциями -al. Использование команд chmod и umask. Системные вызовы getuid и getgid. Компиляция программ на языке C в UNIX и запуск их на счет.
</SPAN>

</TD></TR>

	<TR><TD height="8"><IMG src="./1. Введение в курс практических занятий. Знакомство с операционной системой UNIX_files/empty.gif" width="1" height="8"></TD></TR>
	<TR><TD class="orang" height="1"><IMG src="./1. Введение в курс практических занятий. Знакомство с операционной системой UNIX_files/empty.gif" width="1" height="1"></TD></TR>
	<TR><TD height="8"><IMG src="./1. Введение в курс практических занятий. Знакомство с операционной системой UNIX_files/empty.gif" width="1" height="8"></TD></TR>
	<TR><TD>


<A name="sect1"></A><H3>Введение в курс практических занятий</H3><P id="id_1">Настоящий курс практических занятий является одной из первых известных авторам попыток систематически проиллюстрировать лекционный курс "Основы операционных систем" на примере конкретной операционной системы, а именно – операционной системы UNIX.</P><DIV class="lecture_mark" id="mark_1"></DIV><P id="id_2">Необходимость связывания систематического изложения материала семинарских и практических занятий с материалом лекций возникла в процессе становления базового четырехсеместрового набора курсов по информатике в МФТИ. Новизна излагаемого материала для многих преподавателей заставила лекторов для соблюдения некоторого стандарта обучения готовить по каждой теме методические указания для участников семинаров, и эти указания, как показал опыт, могут с успехом использоваться и студентами, в том числе для самостоятельного обучения. Обкатанная версия этих методических указаний, расширенная, дополненная и модифицированная по результатам многочисленных обсуждений предлагается сейчас вашему вниманию.</P><DIV class="lecture_mark" id="mark_2"></DIV><P id="id_3">Семестровый курс "Основы операционных систем" является третьим по счету курсом цикла "Информатика", которому предшествуют курсы "Алгоритмы и алгоритмические языки" и "Архитектура ЭВМ и язык ассемблера". Предполагается, что к началу практических занятий студенты умеют программировать на языке С (с использованием функций стандартной библиотеки для работы с файлами и строками) и имеют представление о внутреннем устройстве ЭВМ.</P><DIV class="lecture_mark" id="mark_3"></DIV><P id="id_4">Переход от обучения студентов информатике с использованием мэйнфреймов к обучению с использованием сетевых классов персональных компьютеров, свершившийся за последние двадцать лет, неизбежно наложил свой отпечаток на форму проведения практических занятий. Вместо раздельного проведения семинаров и практикума (лабораторных работ) появилось нечто смешанное – семинарский практикум или практический семинар, когда изложение нового материала в течение одного занятия чередуется с короткими практическими программными работами. Именно в виде таких семинаров-практикумов и построен наш курс. Ввиду достаточно высокой сложности используемых программных конструкций мы решили приводить готовые примеры программ для иллюстрации рассматриваемых понятий с последующей их модификацией студентами. Это позволило увеличить насыщенность занятий и за семестровый курс охватить большее количество материала.</P><DIV class="lecture_mark" id="mark_4"></DIV><P id="id_5">Для иллюстрации лекций была выбрана операционная система UNIX, как наиболее открытая, изящная и простая для понимания, хотя создание подобного практического курса возможно и для других операционных систем, например для Windows NT.</P><DIV class="lecture_mark" id="mark_5"></DIV><P id="id_6">В целом практический курс включает в себя 16 занятий, одно из которых в середине семестра – между семинарами 9 и 10-11 – посвящено проведению контрольной работы по материалам лекций. Некоторым темам выделено по два занятия, и соответствующие семинары имеют сдвоенные номера. Естественно, разбиение тем на занятия является достаточно условным, желательно лишь, чтобы они непосредственно следовали за лекциями, на которых основываются.</P><DIV class="lecture_mark" id="mark_6"></DIV><P id="id_7">Далее мы переходим к изложению материала семинарско-практического курса.</P><DIV class="lecture_mark" id="mark_7"></DIV><P id="id_8">По своему содержанию материал текущих семинаров 1–2 является наиболее критичным по отношению к используемому виду операционной системы и политике администрирования. Поэтому многие вопросы будут содержать ссылку <B>"узнайте у своего системного администратора"</B>. Прежде чем приступать к занятиям, необходимо обеспечить наличие пользовательских account'ов для обучающихся. <B>"Узнайте у своего системного администратора"</B>, как это сделать.</P><DIV class="lecture_mark" id="mark_8"></DIV><P id="id_9">В тексте семинаров программные конструкции, включая имена <SPAN class="keyword">системных вызовов</SPAN>, стандартных функций и команды оболочки операционной системы, <SPAN class="texample">выделены другим шрифтом</SPAN>. В UNIX <SPAN class="keyword">системные вызовы</SPAN> и команды оболочки инициируют сложные последовательности действий, затрагивая различные аспекты функционирования операционной системы. Как правило, в рамках одного семинара полное объяснение всех нюансов их поведения является невозможным. Поэтому подробные описания большинства используемых <SPAN class="keyword">системных вызовов</SPAN>, системных функций и некоторых команд оболочки операционной системы при первой встрече с ними вынесены из основного текста на серый фон и обведены рамочкой, а в основном тексте рассматриваются только те детали их описания, для понимания которых хватает накопленных знаний.</P><DIV class="lecture_mark" id="mark_9"></DIV><P id="id_11">Если какой-либо параметр у команды оболочки является необязательным, он будет указываться в квадратных скобках, например, <SPAN class="texample">[who]</SPAN>. В случае, когда возможен выбор только одного из нескольких возможных вариантов параметров, варианты будут перечисляться в фигурных скобках и разделяться вертикальной чертой, например, <SPAN class="texample">{+ | - | =}</SPAN>.</P><DIV class="lecture_mark" id="mark_11"></DIV><A name="sect2"></A><H3>Краткая история операционной системы UNIX, ее структура</H3><P id="id_14">На первой лекции мы разобрали содержание понятия "операционная система", обсудили функции операционных систем и способы их построения. Все материалы первой и последующих лекций мы будем иллюстрировать практическими примерами, связанными с использованием одной из разновидностей операционной системы UNIX – операционной системы Linux, хотя постараемся не связывать свой рассказ именно с ее особенностями. </P><DIV class="lecture_mark" id="mark_14"></DIV><P id="id_15">Ядро операционной системы Linux представляет собой монолитную систему. При компиляции ядра Linux можно разрешить динамическую загрузку и выгрузку очень многих компонентов ядра – так называемых модулей. В момент загрузки модуля его код загружается для исполнения в привилегированном режиме и связывается с остальной частью ядра. Внутри модуля могут использоваться любые экспортируемые ядром функции.</P><DIV class="lecture_mark" id="mark_15"></DIV><P id="id_16">Свой нынешний вид эта операционная система обрела в результате длительной эволюции UNIX-образных операционных систем. История развития UNIX подробно освещена практически во всей литературе, посвященной вычислительной технике. Как правило, это во многом один и тот же текст, с небольшими изменениями кочующий из одного издания в другое, и нам не хотелось бы повторяться. Мы просто сошлемся на достаточно подробное изложение в книге <A target="_blank" href="http://www.intuit.ru/department/os/osintropractice/popup.lit.html#23">[23]</A> или на оригинальную работу одного из родоначальников UNIX <A target="_blank" href="http://www.intuit.ru/department/os/osintropractice/popup.lit.html#7">[7]</A>. Для нас наиболее важным во всей этой истории является существование двух стержневых линий эволюции – линии System V и линии BSD, поскольку в процессе обучения мы будем сталкиваться с различиями в их реализации.</P><DIV class="lecture_mark" id="mark_16"></DIV><A name="sect3"></A><H3>Системные вызовы и библиотека libc</H3><P id="id_17">Основной постоянно функционирующей частью операционной системы UNIX является ее ядро. Другие программы (системные или пользовательские) могут общаться с ядром посредством <SPAN class="keyword">системных вызовов</SPAN>, которые по сути дела являются прямыми точками входа программ в ядро. При исполнении <SPAN class="keyword">системного вызова</SPAN> программа пользователя временно переходит в привилегированный режим, получая доступ к данным или устройствам, которые недоступны при работе в режиме пользователя. </P><DIV class="lecture_mark" id="mark_17"></DIV><P id="id_18">Реальные машинные команды, необходимые для активизации <SPAN class="keyword">системных вызовов</SPAN>, естественно, отличаются от машины к машине, наряду со способом передачи параметров и результатов между вызывающей программой и ядром. Однако с точки зрения программиста на языке C использование <SPAN class="keyword">системных вызовов</SPAN> ничем внешне не отличается от использования других функций стандартной ANSI библиотеки языка C, таких как функции работы со строками <SPAN class="texample">strlen()</SPAN>, <SPAN class="texample">strcpy()</SPAN> и т.д. Стандартная библиотека UNIX – <SPAN class="texample">libc</SPAN> – обеспечивает C-интерфейс к каждому <SPAN class="keyword">системному вызову</SPAN>. Это приводит к тому, что <SPAN class="keyword">системный вызов</SPAN> выглядит как функция на языке C для программиста. Более того, многие из уже известных вам стандартных функций, например функции для работы с файлами: <SPAN class="texample">fopen()</SPAN>, <SPAN class="texample">fread()</SPAN>, <SPAN class="texample">fwrite()</SPAN> при реализации в 
операционной системе UNIX будут применять различные <SPAN class="keyword">системные вызовы</SPAN>. По ходу курса нам придется познакомиться с большим количеством разнообразных <SPAN class="keyword">системных вызовов</SPAN> и их C-интерфейсами. </P><DIV class="lecture_mark" id="mark_18"></DIV><P id="id_25">Большинство <SPAN class="keyword">системных вызовов</SPAN>, возвращающих целое значение, использует значение <SPAN class="texample">-1</SPAN> для оповещения о возникновении ошибки и значение большее или равное <SPAN class="texample">0</SPAN> – при нормальном завершении. <SPAN class="keyword">Системные вызовы</SPAN>, возвращающие указатели, обычно для идентификации ошибочной ситуации пользуются значением <SPAN class="texample">NULL</SPAN>. <A name="keyword-context.1"></A>Для точного определения причины ошибки C-интерфейс предоставляет глобальную переменную <SPAN class="texample"><SPAN class="keyword_def">errno</SPAN></SPAN>, описанную в файле <SPAN class="texample">&lt;errno.h&gt;</SPAN> вместе с ее возможными значениями и их краткими определениями. Заметим, что анализировать значение переменной <SPAN class="texample"><SPAN class="keyword">errno</SPAN></SPAN> необходимо сразу после возникновения ошибочной ситуации, так как успешно завершившиеся <SPAN class="keyword">системные вызовы</SPAN> не изменяют ее значения. <A name="keyword-context.2"></A>Для получения символьной информации об ошибке на 
стандартном выводе программы 
для ошибок (по умолчанию экран терминала) может применяться стандартная UNIX-функция <SPAN class="texample"><SPAN class="keyword_def">perror()</SPAN></SPAN>.</P><DIV class="lecture_mark" id="mark_25"></DIV><DIV class="xml_table_env" id="id_33"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">
<P id="id_34"><B>Функция perror()</B></P><DIV class="lecture_mark" id="mark_34"></DIV>
<P id="id_35"><B>Прототип функции</B></P><DIV class="lecture_mark" id="mark_35"></DIV>
<DIV class="example"><PRE>#include &lt;stdio.h&gt;
void perror(char *str);
</PRE></DIV>

<P id="id_37"><B>Описание функции</B></P><DIV class="lecture_mark" id="mark_37"></DIV>
<P id="id_38">Функция <SPAN class="texample"><SPAN class="keyword">perror()</SPAN></SPAN> предназначена для вывода сообщения об ошибке, соответствующего значению системной переменной <SPAN class="texample"><SPAN class="keyword">errno</SPAN></SPAN> на стандартный поток вывода ошибок. Функция печатает содержимое строки <SPAN class="texample">str</SPAN> (если параметр <SPAN class="texample">str</SPAN> не равен <SPAN class="texample">NULL</SPAN>), двоеточие, пробел и текст сообщения, соответствующий возникшей ошибке, с последующим символом перевода строки <SPAN class="texample">('\n')</SPAN>.</P><DIV class="lecture_mark" id="mark_38"></DIV>
</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_33"></DIV><A name="sect4"></A><H3>Понятия login и password</H3><P id="id_45">Операционная система UNIX является многопользовательской операционной системой. Для обеспечения безопасной работы пользователей и целостности системы доступ к ней должен быть санкционирован. <A name="keyword-context.3"></A><A name="keyword-context.4"></A>Для каждого пользователя, которому разрешен вход в систему, заводится специальное регистрационное имя – username или <SPAN class="keyword_def">login</SPAN> и сохраняется специальный пароль – <SPAN class="keyword_def">password</SPAN>, соответствующий этому имени. Как правило, при заведении нового пользователя начальное значение пароля для него задает системный администратор. После первого входа в систему пользователь должен изменить начальное значение пароля с помощью специальной команды. В дальнейшем он может в любой момент изменить пароль по своему желанию.</P><DIV class="lecture_mark" id="mark_45"></DIV><P id="id_46"><B>"Узнайте у своего системного администратора"</B> регистрационные имена и пароли, установленные для обучающихся.</P><DIV class="lecture_mark" id="mark_46"></DIV><A name="sect5"></A><H3>Вход в систему и смена пароля</H3><P id="id_47">Настало время первый раз войти в систему. Если в системе установлена графическая оболочка наряду с обычными алфавитно-цифровыми терминалами, лучше всего это сделать с алфавитно-цифрового терминала или его эмулятора. На экране появляется надпись, предлагающая ввести регистрационное имя, как правило, это <SPAN class="texample">"<SPAN class="keyword">login</SPAN>:"</SPAN>. Набрав свое регистрационное имя, нажмите клавишу &lt;Enter&gt;. Система запросит у вас пароль, соответствующий введенному имени, выдав специальное приглашение – обычно <SPAN class="texample">"<SPAN class="keyword">Password</SPAN>:"</SPAN>. Внимательно наберите пароль, установленный для вас системным администратором, и нажмите клавишу &lt;Enter&gt;. <B>Вводимый пароль на экране не отображается, поэтому набирайте его аккуратно!</B> Если все было сделано правильно, у вас на экране появится приглашение к вводу команд операционной системы.</P><DIV class="lecture_mark" id="mark_47"></DIV><P id="id_50">Пароль, установленный системным администратором, необходимо сменить. <B>"Узнайте у своего системного администратора"</B>, какая команда для этого используется на вашей вычислительной системе (чаще всего это команда <SPAN class="texample">passwd</SPAN> или <SPAN class="texample">yppasswd</SPAN>). В большинстве UNIX-образных систем требуется, чтобы новый пароль имел не менее шести символов и содержал, по крайней мере, две не буквы и две не цифры. <B>"Узнайте у своего системного администратора"</B>, какие ограничения на новый пароль существуют в вашей операционной системе. </P><DIV class="lecture_mark" id="mark_50"></DIV><P id="id_53">Придумайте новый пароль и хорошенько его запомните, а лучше запишите. Пароли в операционной системе хранятся в закодированном виде, и если вы его забыли, никто не сможет помочь вам его вспомнить. Единственное, что может сделать системный администратор, так это установить вам новый пароль. <B>"Узнайте у своего системного администратора"</B>, что нужно предпринять, если вы забыли пароль.</P><DIV class="lecture_mark" id="mark_53"></DIV><P id="id_54">Введите команду для смены пароля. Обычно система просит сначала набрать старый пароль, затем ввести новый и подтвердить правильность его набора повторным введением. После смены пароля уже никто посторонний не сможет войти в систему под вашим регистрационным именем.</P><DIV class="lecture_mark" id="mark_54"></DIV><P id="id_55">Congratulations!!! Теперь Вы полноценный пользователь операционной системы UNIX. </P><DIV class="lecture_mark" id="mark_55"></DIV><A name="sect6"></A><H3>Упрощенное понятие об устройстве файловой системы в UNIX. Полные и относительные имена файлов</H3><P id="id_56">В операционной системе UNIX существуют три базовых понятия: <B>"процесс"</B>, <B>"файл"</B> и <B>"пользователь"</B>. С понятием "пользователь" мы только что уже столкнулись и будем сталкиваться в дальнейшем при изучении работы операционной системы UNIX. Понятие "процесс" характеризует динамическую сторону происходящего в вычислительной системе, оно будет подробно обсуждаться в лекции 2 и в описании последующих семинаров. Понятие "файл" характеризует статическую сторону вычислительной системы.</P><DIV class="lecture_mark" id="mark_56"></DIV><P id="id_57">Из предыдущего опыта работы с вычислительной техникой вы уже имеете некоторое представление о файле, как об именованном наборе данных, хранящемся где-нибудь на магнитных дисках или лентах. Для нашего сегодняшнего обсуждения нам достаточно такого понимания, чтобы разобраться в том, как организована работа с файлами в операционной системе UNIX. Более подробное рассмотрение понятия "файл" и организации файловых систем для операционных систем в целом будет приведено в лекции 11 и лекции 12, а также на семинарах 11–12, посвященных организации файловых систем в UNIX.</P><DIV class="lecture_mark" id="mark_57"></DIV><P id="id_58">Все файлы, доступные в операционной системе UNIX, как и в уже известных вам операционных системах, объединяются в древовидную логическую структуру. Файлы могут объединяться в <B>каталоги</B> или <B>директории</B>. Не существует файлов, которые не входили бы в состав какой-либо директории. Директории в свою очередь могут входить в состав других директорий. Допускается существование пустых директорий, в которые не входит ни один файл, и ни одна другая директория (см. <A href="http://www.intuit.ru/department/os/osintropractice/1/osintropractice_1.html#image.1-2.1">рис. 1–2.1</A>). Среди всех директорий существует только одна директория, которая не входит в состав других директорий – ее принято называть <B>корневой</B>. На настоящем уровне нашего незнания UNIX мы можем заключить, что в файловой системе UNIX присутствует, по крайней мере, два типа файлов: обычные файлы, которые могут содержать тексты программ, исполняемый код, данные и т.д. – их принято называть <B>регулярными файлами</B>, и директории. </P><DIV class="lecture_mark" id="mark_58"></DIV><P align="left" id="id_59"><A name="image.1-2.1"></A></P><DIV><IMG src="./1. Введение в курс практических занятий. Знакомство с операционной системой UNIX_files/1-2-1.gif" alt="Пример структуры файловой системы" width="447" height="276"></DIV><BR><B>Рис. 1-2.1.</B>&nbsp;
        Пример структуры файловой системы<P></P><DIV class="lecture_mark" id="mark_59"></DIV><P id="id_60">Каждому файлу (регулярному или директории) должно быть присвоено имя. В различных версиях операционной системы UNIX существуют те или иные ограничения на построение имени файла. В стандарте POSIX на интерфейс системных вызовов для операционной системы UNIX содержится лишь три явных ограничения: </P><DIV class="lecture_mark" id="mark_60"></DIV><UL id="id_61"><LI>Нельзя создавать имена большей длины, чем это предусмотрено операционной системой (для Linux – 255 символов). </LI><LI>Нельзя использовать символ <SPAN class="texample">NUL</SPAN> (не путать с указателем <SPAN class="texample">NULL!</SPAN>) – он же символ с нулевым кодом, он же признак конца строки в языке C. </LI><LI>Нельзя использовать символ <SPAN class="texample">'/'</SPAN>. </LI></UL><DIV class="lecture_mark" id="mark_61"></DIV><P id="id_68">От себя добавим, что также нежелательно применять символы "звездочка" – <SPAN class="texample">"*"</SPAN>, "знак вопроса" – <SPAN class="texample">"?"</SPAN>, "кавычка" – <SPAN class="texample">"\""</SPAN>, "апостроф" – <SPAN class="texample">"\'"</SPAN>, "пробел" – <SPAN class="texample">" "</SPAN> и "обратный слэш" – <SPAN class="texample">"\\"</SPAN>(символы записаны в нотации символьных констант языка C). </P><DIV class="lecture_mark" id="mark_68"></DIV><P id="id_75">Единственным исключением является корневая директория, которая <B>всегда</B> имеет имя <SPAN class="texample">"/"</SPAN>. Эта же директория по вполне понятным причинам представляет собой единственный файл, который должен иметь уникальное имя во всей файловой системе. Для всех остальных файлов имена должны быть уникальными только в рамках той директории, в которую они непосредственно входят. Каким же образом отличить два файла с именами <SPAN class="texample">"aaa.c"</SPAN>, входящими в директории <SPAN class="texample">"b"</SPAN> и <SPAN class="texample">"d"</SPAN> на рисунке <A href="http://www.intuit.ru/department/os/osintropractice/1/osintropractice_1.html#image.1-2.1">1–2.1</A>, чтобы было понятно о каком из них идет речь? Здесь на помощь приходит <B>понятие</B> <SPAN class="keyword">полного имени файла</SPAN>.</P><DIV class="lecture_mark" id="mark_75"></DIV><P id="id_80">Давайте мысленно построим путь от корневой вершины дерева файлов к интересующему нас файлу и выпишем все имена файлов (т.е. узлов дерева), встречающиеся на нашем пути, например, <SPAN class="texample">"/ usr b aaa.c"</SPAN>. В этой последовательности первым будет всегда стоять имя корневой директории, а последним – имя интересующего нас файла. Отделим имена узлов друг от друга в этой записи не пробелами, а символами <SPAN class="texample">"/"</SPAN>, за исключением имени корневой директории и следующего за ним имени (<SPAN class="texample">"/usr/b/aaa.c"</SPAN>). Полученная запись однозначно идентифицирует файл во всей логической конструкции файловой системы. Такая запись и получила название <SPAN class="keyword">полного имени файла</SPAN>. </P><DIV class="lecture_mark" id="mark_80"></DIV><A name="sect7"></A><H3>Понятие о текущей директории. Команда pwd. Относительные имена файлов</H3><P id="id_84"><SPAN class="keyword">Полные имена файлов</SPAN> могут включать в себя достаточно много имен директорий и быть очень длинными, с ними не всегда удобно работать. В то же время, существуют такие понятия как <SPAN class="keyword">текущая или рабочая директория</SPAN> и <SPAN class="keyword">относительное имя файла</SPAN>. </P><DIV class="lecture_mark" id="mark_84"></DIV><P id="id_85"><A name="keyword-context.5"></A>Для каждой работающей программы в операционной системе, включая командный интерпретатор (<SPAN class="texample">shell</SPAN>), который обрабатывает вводимые команды и высвечивает приглашение к их вводу, одна из директорий в логической структуре файловой системы назначается <SPAN class="keyword_def">текущей или рабочей</SPAN> для данной программы. Узнать, какая директория является <SPAN class="keyword">текущей</SPAN> для вашего командного интерпретатора, можно с помощью команды операционной системы <SPAN class="texample">pwd</SPAN>. </P><DIV class="lecture_mark" id="mark_85"></DIV><DIV class="xml_table_env" id="id_88"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">
<P id="id_89"><B>Команда pwd</B></P><DIV class="lecture_mark" id="mark_89"></DIV>
<P id="id_90"><B>Синтаксис команды</B></P><DIV class="lecture_mark" id="mark_90"></DIV>
<DIV class="example"><PRE>pwd
</PRE></DIV>

<P id="id_92"><B>Описание команды</B></P><DIV class="lecture_mark" id="mark_92"></DIV>
<P id="id_93">Команда <SPAN class="texample">pwd</SPAN> выводит полное имя текущей директории для работающего командного интерпретатора.</P><DIV class="lecture_mark" id="mark_93"></DIV>
</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_88"></DIV><P id="id_95"><A name="keyword-context.6"></A>Зная <SPAN class="keyword">текущую директорию</SPAN>, мы можем проложить путь по графу файлов от <SPAN class="keyword">текущей директории</SPAN> к интересующему нас файлу. Запишем последовательность узлов, которые встретятся на этом пути, следующим образом. Узел, соответствующий <SPAN class="keyword">текущей директории</SPAN>, в запись не включаем. При движении по направлению к корневому каталогу каждый узел будем обозначать двумя символами "точка" – <SPAN class="texample">".."</SPAN>, а при движении по направлению от корневого каталога будем записывать имя встретившегося узла. Разделим обозначения, относящиеся к разным узлам в этой записи, символами <SPAN class="texample">"/"</SPAN>. Полученную строку принято называть <SPAN class="keyword_def">относительным именем файла</SPAN>. <SPAN class="keyword">Относительные имена файлов</SPAN> меняются при смене рабочего каталога. Так, в нашем примере, если рабочий каталог – это директория <SPAN class="texample">"/d"
</SPAN>, то для файла <SPAN class="texample">"/usr/b/aaa.c"</SPAN> <SPAN class="keyword">относительным именем</SPAN> будет <SPAN class="texample">"../usr/b/aaa.c"</SPAN>, а если рабочий каталог – это директория <SPAN class="texample">"/usr/b"</SPAN>, то его <SPAN class="keyword">относительное имя</SPAN> – <SPAN class="texample">"ааа.с"</SPAN>.</P><DIV class="lecture_mark" id="mark_95"></DIV><P id="id_103">Для полноты картины имя текущего каталога можно вставлять в <SPAN class="keyword">относительное имя файла</SPAN>, обозначая текущий каталог одиночным символом "точка" – <SPAN class="texample">"."</SPAN>. Тогда наши <SPAN class="keyword">относительные имена</SPAN> будут выглядеть как <SPAN class="texample">"./../usr/b/aaa.c"</SPAN> и <SPAN class="texample">"./aaa.c"</SPAN> соответственно.</P><DIV class="lecture_mark" id="mark_103"></DIV><P id="id_107">Программы, запущенные с помощью командного интерпретатора, будут иметь в качестве рабочей директории его рабочую директорию, если внутри этих программ не изменить ее расположение с помощью специального <SPAN class="keyword">системного вызова</SPAN>.</P><DIV class="lecture_mark" id="mark_107"></DIV><A name="sect8"></A><H3>Домашняя директория пользователя и ее определение</H3><P id="id_108"><A name="keyword-context.7"></A>Для каждого нового пользователя в системе заводится специальная директория, которая становится <SPAN class="keyword">текущей</SPAN> сразу после его входа в систему. Эта директория получила название <SPAN class="keyword_def">домашней директории</SPAN> пользователя. Воспользуйтесь командой pwd для определения своей <SPAN class="keyword">домашней директории</SPAN>.</P><DIV class="lecture_mark" id="mark_108"></DIV><A name="sect9"></A><H3>Команда man – универсальный справочник </H3><P id="id_109">По ходу изучения операционной системы UNIX вам часто будет требоваться информация о том, что делает та или иная команда или <SPAN class="keyword">системный вызов</SPAN>, какие у них параметры и опции, для чего предназначены некоторые системные файлы, каков их формат и т.д. Мы постарались, по мере возможности, включить описания большинства используемых в курсе команд и <SPAN class="keyword">системных вызовов</SPAN> в наш текст. Однако иногда для получения более полной информации мы отсылаем читателей к UNIX Manual – руководству по операционной системе UNIX. К счастью, большая часть информации в UNIX Manual доступна в интерактивном режиме с помощью утилиты <SPAN class="texample"><SPAN class="keyword">man</SPAN></SPAN>. </P><DIV class="lecture_mark" id="mark_109"></DIV><P id="id_111">Пользоваться утилитой <SPAN class="texample"><SPAN class="keyword">man</SPAN></SPAN> достаточно просто – наберите команду</P><DIV class="lecture_mark" id="mark_111"></DIV><DIV class="example"><PRE>man имя </PRE></DIV><P id="id_114">где <SPAN class="texample">имя</SPAN> – это имя интересующей вас команды, утилиты, <SPAN class="keyword">системного вызова</SPAN>, библиотечной функции или файла. Попробуйте с ее помощью посмотреть информацию о команде <SPAN class="texample">pwd</SPAN>.</P><DIV class="lecture_mark" id="mark_114"></DIV><P id="id_117">Чтобы пролистать страницу полученного описания, если оно не поместилось на экране полностью, следует нажать клавишу &lt;пробел&gt;. Для прокрутки одной строки воспользуйтесь клавишей &lt;Enter&gt;. Вернуться на страницу назад позволит одновременное нажатие клавиш &lt;Ctrl&gt; и &lt;b&gt;. Выйти из режима просмотра информации можно с помощью клавиши &lt;q&gt;.</P><DIV class="lecture_mark" id="mark_117"></DIV><P id="id_118">Иногда имена команд интерпретатора и <SPAN class="keyword">системных вызовов</SPAN> или какие-либо еще имена совпадают. Тогда чтобы найти интересующую вас информацию, необходимо задать утилите <SPAN class="texample"><SPAN class="keyword">man</SPAN></SPAN> категорию, к которой относится эта информация (номер раздела). Деление информации по категориям может слегка отличаться от одной версии UNIX к другой. В Linux, например, принято следующее разделение:</P><DIV class="lecture_mark" id="mark_118"></DIV><OL id="id_120"><LI>Исполняемые файлы или команды интерпретатора. </LI><LI><SPAN class="keyword">Системные вызовы</SPAN>. </LI><LI>Библиотечные функции. </LI><LI>Специальные файлы (обычно файлы устройств) – что это такое, вы узнаете на семинарах 13–14. </LI><LI>Формат системных файлов и принятые соглашения. </LI><LI>Игры (обычно отсутствуют). </LI><LI>Макропакеты и утилиты – такие как сам <SPAN class="texample"><SPAN class="keyword">man</SPAN></SPAN>. </LI><LI>Команды системного администратора. </LI><LI>Подпрограммы ядра (нестандартный раздел). </LI></OL><DIV class="lecture_mark" id="mark_120"></DIV><P id="id_131">Если вы знаете раздел, к которому относится информация, то утилиту <SPAN class="texample"><SPAN class="keyword">man</SPAN></SPAN> можно вызвать в Linux с дополнительным параметром </P><DIV class="lecture_mark" id="mark_131"></DIV><DIV class="example"><PRE>man номер_раздела имя</PRE></DIV><P id="id_134">В других операционных системах этот вызов может выглядеть иначе. Для получения точной информации о разбиении на разделы, форме указания номера раздела и дополнительных возможностях утилиты <SPAN class="texample"><SPAN class="keyword">man</SPAN></SPAN> наберите команду </P><DIV class="lecture_mark" id="mark_134"></DIV><DIV class="example"><PRE>man man
</PRE></DIV><A name="sect10"></A><H3>Команды cd – для смены текущей директории и ls – для просмотра состава директории </H3><P id="id_137"><A name="keyword-context.8"></A>Для смены <SPAN class="keyword">текущей директории</SPAN> командного интерпретатора можно воспользоваться командой <SPAN class="texample"><SPAN class="keyword_def">cd</SPAN></SPAN> (change directory). Для этого необходимо набрать команду в виде</P><DIV class="lecture_mark" id="mark_137"></DIV><DIV class="example"><PRE>cd имя_директории
</PRE></DIV><P id="id_140">где <SPAN class="texample">имя_директории</SPAN> – полное или относительное имя директории, которую вы хотите сделать <SPAN class="keyword">текущей</SPAN>. Команда <SPAN class="texample"><SPAN class="keyword">cd</SPAN></SPAN> без параметров сделает <SPAN class="keyword">текущей директорией</SPAN> вашу <SPAN class="keyword">домашнюю директорию</SPAN>.</P><DIV class="lecture_mark" id="mark_140"></DIV><P id="id_143"><A name="keyword-context.9"></A>Просмотреть содержимое <SPAN class="keyword">текущей</SPAN> или любой другой директории можно, воспользовавшись командой <SPAN class="texample"><SPAN class="keyword_def">ls</SPAN></SPAN> (от list). Если ввести ее без параметров, эта команда распечатает вам список файлов, находящихся в <SPAN class="keyword">текущей директории</SPAN>. Если же в качестве параметра задать полное или относительное имя директории:</P><DIV class="lecture_mark" id="mark_143"></DIV><DIV class="example"><PRE>ls имя_директории
</PRE></DIV><P id="id_146">то она распечатает список файлов в указанной директории. Надо отметить, что в полученный список не войдут файлы, имена которых начинаются с символа "точка" – <SPAN class="texample">"."</SPAN>. Такие файлы обычно создаются различными системными программами для своих целей (например, для настройки). Посмотреть полный список файлов можно, дополнительно указав команде <SPAN class="texample"><SPAN class="keyword">ls</SPAN></SPAN> опцию <SPAN class="texample">-a</SPAN>, т.е. набрав ее в виде </P><DIV class="lecture_mark" id="mark_146"></DIV><DIV class="example"><PRE>ls -a 
</PRE></DIV><P id="id_151">или</P><DIV class="lecture_mark" id="mark_151"></DIV><DIV class="example"><PRE>ls -a имя_директории 
</PRE></DIV><P id="id_153">У команды <SPAN class="texample"><SPAN class="keyword">ls</SPAN></SPAN> существует и много других опций, часть из которых мы еще рассмотрим на семинарах. Для получения полной информации о команде <SPAN class="texample"><SPAN class="keyword">ls</SPAN></SPAN> воспользуйтесь утилитой <SPAN class="texample"><SPAN class="keyword">man</SPAN></SPAN>. </P><DIV class="lecture_mark" id="mark_153"></DIV><A name="sect11"></A><H3>Путешествие по структуре файловой системы </H3><P id="id_157">Пользуясь командами <SPAN class="texample"><SPAN class="keyword">cd</SPAN></SPAN>, <SPAN class="texample"><SPAN class="keyword">ls</SPAN></SPAN> и <SPAN class="texample">pwd</SPAN>, попутешествуйте по структуре файловой системы и просмотрите ее содержимое. Возможно, зайти в некоторые директории или посмотреть их содержимое вам не удастся. Это связано с работой механизма защиты файлов и директорий, о котором мы поговорим позже. Не забудьте в конце путешествия вернуться в свою <SPAN class="keyword">домашнюю директорию</SPAN>.</P><DIV class="lecture_mark" id="mark_157"></DIV><A name="sect12"></A><H3>Команда cat и создание файла. Перенаправление ввода и вывода</H3><P id="id_161">Мы умеем перемещаться по логической структуре файловой системы и рассматривать ее содержимое. Хотелось бы уметь еще и просматривать содержимое файлов, и создавать их. <A name="keyword-context.10"></A>Для просмотра содержимого небольшого текстового файла на экране можно воспользоваться командой <SPAN class="texample"><SPAN class="keyword_def">cat</SPAN></SPAN>. Если набрать ее в виде </P><DIV class="lecture_mark" id="mark_161"></DIV><DIV class="example"><PRE>cat имя_файла 
</PRE></DIV><P id="id_164">то на экран выплеснется все его содержимое. </P><DIV class="lecture_mark" id="mark_164"></DIV><P id="id_165"><B>Внимание! Не пытайтесь рассматривать на экране содержимое директорий – все равно не получится! Не пытайтесь просматривать содержимое неизвестных файлов, особенно если вы не знаете, текстовый он или бинарный. Вывод на экран бинарного файла может привести к непредсказуемому поведению вашего терминала</B>. </P><DIV class="lecture_mark" id="mark_165"></DIV><P id="id_166">Если даже ваш файл и текстовый, но большой, то все равно вы увидите только его последнюю страницу. Большой текстовый файл удобнее рассматривать с помощью утилиты <SPAN class="texample">more</SPAN> (описание ее использования вы найдете в UNIX Manual). Команда <SPAN class="texample"><SPAN class="keyword">cat</SPAN></SPAN> будет нам интересна с другой точки зрения.</P><DIV class="lecture_mark" id="mark_166"></DIV><P id="id_169">Если мы в качестве параметров для команды <SPAN class="texample"><SPAN class="keyword">cat</SPAN></SPAN> зададим не одно имя, а имена нескольких файлов</P><DIV class="lecture_mark" id="mark_169"></DIV><DIV class="example"><PRE>cat файл1 файл2 ... файлN
</PRE></DIV><P id="id_172">то система выдаст на экран их содержимое в указанном порядке. Вывод команды <SPAN class="texample"><SPAN class="keyword">cat</SPAN></SPAN> можно перенаправить с экрана терминала в какой-нибудь файл, воспользовавшись символом перенаправления выходного потока данных – знаком "больше" – <SPAN class="texample">"&gt;"</SPAN>. Команда </P><DIV class="lecture_mark" id="mark_172"></DIV><DIV class="example"><PRE>cat файл1 файл2 ... файлN &gt; файл_результата
</PRE></DIV><P id="id_176">сольет содержимое всех файлов, чьи имена стоят перед знаком <SPAN class="texample">"&gt;"</SPAN>, воедино в <SPAN class="texample">файл_результата</SPAN> – конкатенирует их (от слова concatenate и произошло ее название). Прием перенаправления выходных данных со стандартного потока вывода (экрана) в файл является стандартным для всех команд, выполняемых командным интерпретатором. Вы можете получить файл, содержащий список всех файлов <SPAN class="keyword">текущей директории</SPAN>, если выполните команду <SPAN class="texample"><SPAN class="keyword">ls</SPAN></SPAN> <SPAN class="texample">-a</SPAN> с перенаправлением выходных данных </P><DIV class="lecture_mark" id="mark_176"></DIV><DIV class="example"><PRE>ls -a &gt; новый_файл
</PRE></DIV><P id="id_182">Если имена входных файлов для команды <SPAN class="texample"><SPAN class="keyword">cat</SPAN></SPAN> не заданы, то она будет использовать в качестве входных данных информацию, которая вводится с клавиатуры, до тех пор, пока вы не наберете признак окончания ввода – комбинацию клавиш &lt;CTRL&gt; и &lt;d&gt;.</P><DIV class="lecture_mark" id="mark_182"></DIV><P id="id_184">Таким образом, команда </P><DIV class="lecture_mark" id="mark_184"></DIV><DIV class="example"><PRE>cat &gt; новый_файл
</PRE></DIV><P id="id_186">позволяет создать новый текстовый файл с именем <SPAN class="texample">новый_файл</SPAN> и содержимым, которое пользователь введет с клавиатуры. У команды <SPAN class="texample"><SPAN class="keyword">cat</SPAN></SPAN> существует множество различных опций. Посмотреть ее полное описание можно в UNIX Manual.</P><DIV class="lecture_mark" id="mark_186"></DIV><P id="id_189">Заметим, что наряду с перенаправлением выходных данных существует способ перенаправить входные данные. Если во время выполнения некоторой команды требуется ввести данные с клавиатуры, можно положить их заранее в файл, а затем перенаправить стандартный ввод этой команды с помощью знака "меньше" – <SPAN class="texample">"&lt;"</SPAN> и следующего за ним имени файла с входными данными. Другие варианты перенаправления потоков данных можно посмотреть в UNIX Manual для командного интерпретатора.</P><DIV class="lecture_mark" id="mark_189"></DIV><A name="sect13"></A><H3>Создание файла с помощью команды cat</H3><P id="id_191">Убедитесь, что вы находитесь в своей <SPAN class="keyword">домашней директории</SPAN>, и создайте с помощью команды <SPAN class="texample"><SPAN class="keyword">cat</SPAN></SPAN> новый текстовый файл. Просмотрите его содержимое.</P><DIV class="lecture_mark" id="mark_191"></DIV><A name="sect14"></A><H3>Простейшие команды работы с файлами – cp, rm, mkdir, mv</H3><P id="id_193">Для нормальной работы с файлами необходимо не только уметь создавать файлы, просматривать их содержимое и перемещаться по логическому дереву файловой системы. Нужно уметь создавать собственные поддиректории, копировать и удалять файлы, переименовывать их. Это минимальный набор операций, не владея которым нельзя чувствовать себя уверенно при работе с компьютером. </P><DIV class="lecture_mark" id="mark_193"></DIV><P id="id_194"><A name="keyword-context.11"></A>Для создания новой поддиректории используется команда <SPAN class="texample"><SPAN class="keyword_def">mkdir</SPAN></SPAN> (сокращение от make directory). В простейшем виде команда выглядит следующим образом:</P><DIV class="lecture_mark" id="mark_194"></DIV><DIV class="example"><PRE>mkdir имя_директории</PRE></DIV><P id="id_197">где <SPAN class="texample">имя_директории</SPAN> – полное или относительное имя создаваемой директории. У команды <SPAN class="texample"><SPAN class="keyword">mkdir</SPAN></SPAN> имеется набор опций, описание которых можно просмотреть с помощью утилиты <SPAN class="texample"><SPAN class="keyword">man</SPAN></SPAN>.</P><DIV class="lecture_mark" id="mark_197"></DIV><DIV class="xml_table_env" id="id_201"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_202"><B>Команда cp</B></P><DIV class="lecture_mark" id="mark_202"></DIV>
<P id="id_203"><B>Синтаксис команды</B></P><DIV class="lecture_mark" id="mark_203"></DIV>
<DIV class="example"><PRE>cp файл_источник файл_назначения
cp файл1 файл2 ... файлN дир_назначения
cp -r дир_источник дир_назначения
cp -r дир1 дир2 ... дирN дир_назначения
</PRE></DIV>
<P id="id_205"><B>Описание команды</B></P><DIV class="lecture_mark" id="mark_205"></DIV>
<P id="id_206">Настоящее описание является не полным описанием команды <SPAN class="texample"><SPAN class="keyword">cp</SPAN></SPAN>, а кратким введением в ее использование. Для получения полного описания команды обратитесь к UNIX Manual.</P><DIV class="lecture_mark" id="mark_206"></DIV>

<P id="id_208">Команда <SPAN class="texample"><SPAN class="keyword">cp</SPAN></SPAN> в форме</P><DIV class="lecture_mark" id="mark_208"></DIV>

<DIV class="example"><PRE>cp файл_источник файл_назначения
</PRE></DIV>

<P id="id_211">служит для копирования одного файла с именем <SPAN class="texample">файл_источник</SPAN> в файл с именем <SPAN class="texample">файл_назначения</SPAN>.</P><DIV class="lecture_mark" id="mark_211"></DIV>

<P id="id_214">Команда <SPAN class="texample"><SPAN class="keyword">cp</SPAN></SPAN> в форме</P><DIV class="lecture_mark" id="mark_214"></DIV>

<DIV class="example"><PRE>cp файл1 файл2 ... файлN дир_назначения
</PRE></DIV>

<P id="id_217">служит для копирования файла или файлов с именами <SPAN class="texample">файл1, файл2, ... файлN</SPAN> в уже существующую директорию с именем <SPAN class="texample">дир_назначения</SPAN> под своими именами. Вместо имен копируемых файлов могут использоваться их шаблоны.</P><DIV class="lecture_mark" id="mark_217"></DIV>

<P id="id_220">Команда <SPAN class="texample"><SPAN class="keyword">cp</SPAN></SPAN> в форме</P><DIV class="lecture_mark" id="mark_220"></DIV>

<DIV class="example"><PRE>cp -r дир_источник дир_назначения
</PRE></DIV>

<P id="id_223">служит для рекурсивного копирования одной директории с <SPAN class="texample">именем дир_источник</SPAN> в новую директорию с именем <SPAN class="texample">дир_назначения</SPAN>. Если директория <SPAN class="texample">дир_назначения</SPAN> уже существует, то мы получаем команду <SPAN class="texample"><SPAN class="keyword">cp</SPAN></SPAN> в следующей форме</P><DIV class="lecture_mark" id="mark_223"></DIV>

<DIV class="example"><PRE>cp -r дир1 дир2 ... дирN дир_назначения
</PRE></DIV>

<P id="id_229">Такая команда служит для рекурсивного копирования директории или директорий с именами <SPAN class="texample">дир1, дир2, ... дирN</SPAN> в уже существующую директорию с именем <SPAN class="texample">дир_назначения</SPAN> под своими собственными именами. Вместо имен копируемых директорий могут использоваться их шаблоны.</P><DIV class="lecture_mark" id="mark_229"></DIV>
</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_201"></DIV><P id="id_232"><A name="keyword-context.12"></A>Для копирования файлов может использоваться команда <SPAN class="texample"><SPAN class="keyword_def">cp</SPAN></SPAN> (сокращение от copy). Команда <SPAN class="texample">ср</SPAN> умеет копировать не только отдельный файл, но и набор файлов, и даже директорию целиком вместе со всеми входящими в нее поддиректориями (рекурсивное копирование). Для задания набора файлов могут использоваться шаблоны имен файлов. Точно так же шаблон имени может быть использован и в командах переименования файлов и их удаления, которые мы рассмотрим ниже.</P><DIV class="lecture_mark" id="mark_232"></DIV><DIV class="xml_table_env" id="id_235"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">
<P id="id_236"><B>Шаблоны имен файлов</B></P><DIV class="lecture_mark" id="mark_236"></DIV>

<P id="id_237">Шаблоны имен файлов могут применяться в качестве параметра для задания набора имен файлов во многих командах операционной системы. При использовании шаблона просматривается вся совокупность имен файлов, находящихся в файловой системе, и те имена, которые удовлетворяют шаблону, включаются в набор. В общем случае шаблоны могут задаваться с использованием следующих метасимволов:</P><DIV class="lecture_mark" id="mark_237"></DIV>

<P id="id_238"><SPAN class="texample">*</SPAN> – соответствует всем цепочкам литер, включая пустую;</P><DIV class="lecture_mark" id="mark_238"></DIV>

<P id="id_240"><SPAN class="texample">?</SPAN> – соответствует всем одиночным литерам;</P><DIV class="lecture_mark" id="mark_240"></DIV>

<P id="id_242"><SPAN class="texample">[...]</SPAN> – соответствует любой литере, заключенной в скобки. Пара литер, разделенных знаком минус, задает диапазон литер.</P><DIV class="lecture_mark" id="mark_242"></DIV>

<P id="id_244">Так, например, шаблону <SPAN class="texample">*.c</SPAN> удовлетворяют все файлы текущей директории, чьи имена заканчиваются на <SPAN class="texample">.c</SPAN>. Шаблону <SPAN class="texample">[a-d]*</SPAN> удовлетворяют все файлы текущей директории, чьи имена начинаются с букв <SPAN class="texample">a</SPAN>, <SPAN class="texample">b</SPAN>, <SPAN class="texample">c</SPAN>, <SPAN class="texample">d</SPAN>. Существует одно ограничение на использование метасимвола <SPAN class="texample">*</SPAN> в начале имени файла, например, в случае шаблона <SPAN class="texample">*c</SPAN>. Для таких шаблонов имена файлов, начинающиеся с символа точка, считаются не удовлетворяющими шаблону.</P><DIV class="lecture_mark" id="mark_244"></DIV>
</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_235"></DIV><P id="id_254"><A name="keyword-context.13"></A>Для удаления файлов или директорий применяется команда <SPAN class="texample"><SPAN class="keyword_def">rm</SPAN></SPAN> (сокращение от remove). Если вы хотите удалить один или несколько регулярных файлов, то простейший вид команды <SPAN class="texample"><SPAN class="keyword">rm</SPAN></SPAN> будет выглядеть следующим образом: </P><DIV class="lecture_mark" id="mark_254"></DIV><DIV class="example"><PRE>rm файл1 файл2 ... файлN</PRE></DIV><P id="id_258">где <SPAN class="texample">файл1, файл2, ... файлN</SPAN> – <SPAN class="keyword">полные</SPAN> или <SPAN class="keyword">относительные имена</SPAN> регулярных файлов, которые требуется удалить. Вместо имен файлов могут использоваться их шаблоны. Если вы хотите удалить одну или несколько директорий вместе с их содержимым (рекурсивное удаление), то к команде добавляется опция <SPAN class="texample">-r</SPAN>: </P><DIV class="lecture_mark" id="mark_258"></DIV><DIV class="example"><PRE>rm -r дир1 дир2 ... дирN</PRE></DIV><P id="id_262">где <SPAN class="texample">дир1, дир2, ... дирN</SPAN> – полные или относительные имена директорий, которые нужно удалить. Вместо непосредственно имен директорий также могут использоваться их шаблоны. У команды <SPAN class="texample"><SPAN class="keyword">rm</SPAN></SPAN> есть еще набор полезных опций, которые описаны в UNIX Manual. На самом деле процесс удаления файлов не так прост, как кажется на первый взгляд. Более подробно он будет рассмотрен нами на семинарах 11–12, когда мы будем обсуждать операции над файлами в операционной системе UNIX.</P><DIV class="lecture_mark" id="mark_262"></DIV><DIV class="xml_table_env" id="id_265"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">
<P id="id_266"><B>Команда mv</B></P><DIV class="lecture_mark" id="mark_266"></DIV>
<P id="id_267"><B>Синтаксис команды</B></P><DIV class="lecture_mark" id="mark_267"></DIV>
<DIV class="example"><PRE>mv имя_источника имя_назначения
mv имя1 имя2 ... имяN дир_назначения
</PRE></DIV>

<P id="id_269"><B>Описание команды</B></P><DIV class="lecture_mark" id="mark_269"></DIV>

<P id="id_270">Настоящее описание не является полным описанием команды <SPAN class="texample"><SPAN class="keyword">mv</SPAN></SPAN>, а служит кратким введением в ее использование. Для получения полного описания команды обращайтесь к UNIX Manual.</P><DIV class="lecture_mark" id="mark_270"></DIV>

<P id="id_272">Команда <SPAN class="texample"><SPAN class="keyword">mv</SPAN></SPAN> в форме</P><DIV class="lecture_mark" id="mark_272"></DIV>

<DIV class="example"><PRE>mv имя_источника имя_назначения
</PRE></DIV>

<P id="id_275">служит для переименования или перемещения одного файла (неважно, регулярного или директории) с именем <SPAN class="texample">имя_источника</SPAN> в файл с именем <SPAN class="texample">имя_назначения</SPAN>. При этом перед выполнением команды файла с именем <SPAN class="texample">имя_назначения</SPAN> существовать не должно.</P><DIV class="lecture_mark" id="mark_275"></DIV>

<P id="id_279">Команда <SPAN class="texample"><SPAN class="keyword">mv</SPAN></SPAN> в форме</P><DIV class="lecture_mark" id="mark_279"></DIV>

<DIV class="example"><PRE>mv имя1 имя2 ... имяN дир_назначения
</PRE></DIV>

<P id="id_282">служит для перемещения файла или файлов (неважно, регулярных файлов или директорий) с именами <SPAN class="texample">имя1, имя2, ... имяN</SPAN> в уже существующую директорию с именем <SPAN class="texample">дир_назначения</SPAN> под собственными именами. Вместо имен перемещаемых файлов могут использоваться их шаблоны.</P><DIV class="lecture_mark" id="mark_282"></DIV>
</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_265"></DIV><P id="id_285"><B>Командой удаления файлов и директорий следует пользоваться с осторожностью. Удаленную информацию восстановить невозможно. Если вы системный администратор и ваша</B> <SPAN class="keyword">текущая директория</SPAN> <B>– это корневая директория, пожалуйста, не выполняйте команду</B> <SPAN class="texample"><SPAN class="keyword">rm</SPAN></SPAN> <SPAN class="texample"> -r *</SPAN><B>!</B> </P><DIV class="lecture_mark" id="mark_285"></DIV><P id="id_288"><A name="keyword-context.14"></A>Для переименования файла или его перемещения в другой каталог применяется команда <SPAN class="texample"><SPAN class="keyword_def">mv</SPAN></SPAN> (сокращение от move). Для задания имен перемещаемых файлов в ней тоже можно использовать их шаблоны.</P><DIV class="lecture_mark" id="mark_288"></DIV><A name="sect15"></A><H3>История редактирования файлов – ed, vi</H3><P id="id_290">Полученные знания уже позволяют нам достаточно свободно оперировать файлами. Но что нам делать, если потребуется изменить содержимое файла, отредактировать его?</P><DIV class="lecture_mark" id="mark_290"></DIV><P id="id_291">Когда появились первые варианты операционной системы UNIX, устройства ввода и отображения информации существенно отличались от существующих сегодня. На клавиатурах присутствовали только алфавитно-цифровые клавиши (не было даже клавиш курсоров), а дисплеи не предполагали экранного редактирования. Поэтому первый редактор операционной системы UNIX – редактор <SPAN class="texample">ed</SPAN> – требовал от пользователя строгого указания того, что и как будет редактироваться с помощью специальных команд. Так, например, для замены первого сочетания символов <SPAN class="texample">"ra"</SPAN> на <SPAN class="texample">"ru"</SPAN> в одиннадцатой строке редактируемого файла потребовалось бы ввести команду</P><DIV class="lecture_mark" id="mark_291"></DIV><DIV class="example"><PRE>11 s/ra/ru 
</PRE></DIV><P id="id_296">Редактор ed<SUP><A href="http://www.intuit.ru/department/os/osintropractice/1/osintropractice_1.html#footnote.1" class="objectName">1)</A></SUP>, по существу, являлся построчечным редактором. Впоследствии появился экранный редактор – vi<SUP><A href="http://www.intuit.ru/department/os/osintropractice/1/osintropractice_1.html#footnote.2" class="objectName">2)</A></SUP>, однако и он требовал строгого указания того, что и как в текущей позиции на экране мы должны сделать, или каким образом изменить текущую позицию, с помощью специальных команд, соответствующих алфавитно-цифровым клавишам. Эти редакторы могут показаться нам сейчас анахронизмами, но они до сих пор входят в состав всех вариантов UNIX и иногда 



(например, при работе с удаленной машиной по медленному каналу связи) являются единственным средством, позволяющим удаленно редактировать файл. </P><DIV class="lecture_mark" id="mark_296"></DIV><A name="sect16"></A><H3>Система Midnight Commander – mc. Встроенный mc редактор и редактор joe</H3><P id="id_301">Наверное, вы уже убедились в том, что работа в UNIX исключительно на уровне командного интерпретатора и встроенных редакторов далека от уже привычных для нас удобств. Но не все так плохо. Существуют разнообразные пакеты, облегчающие задачу пользователя в UNIX. К таким пакетам следует отнести Midnight Commander – аналог программ Norton Commander для DOS и FAR для Windows 9x и NT – со своим встроенным редактором, запускаемый командой <SPAN class="texample">mc</SPAN>, и экранный редактор <SPAN class="texample">joe</SPAN>. Информацию о них можно найти в UNIX Manual. Большими возможностями обладают многофункциональные текстовые редакторы, например, emacs<SUP><A href="http://www.intuit.ru/department/os/osintropractice/1/osintropractice_1.html#footnote.3" class="objectName">3)</A></SUP>.</P><DIV class="lecture_mark" id="mark_301"></DIV><P id="id_305">Войдите в <SPAN class="texample">mc</SPAN> и попробуйте перемещаться по директориям, создавать и редактировать файлы.</P><DIV class="lecture_mark" id="mark_305"></DIV><A name="sect17"></A><H3>Пользователь и группа. Команды chown и chgrp. Права доступа к файлу</H3><P id="id_307">Как уже говорилось, <A name="keyword-context.15"></A>для входа в операционную систему UNIX каждый пользователь должен быть зарегистрирован в ней под определенным именем. Вычислительные системы не умеют оперировать именами, поэтому каждому имени пользователя в системе соответствует некоторое числовое значение – его <SPAN class="keyword_def">идентификатор</SPAN> – <SPAN class="keyword_def">UID</SPAN> (<SPAN class="keyword">user identificator</SPAN>). </P><DIV class="lecture_mark" id="mark_307"></DIV><P id="id_308">Все пользователи в системе делятся на группы. Например, студенты одной учебной группы могут составлять отдельную группу пользователей. Группы пользователей также получают свои имена и соответствующие идентификационные номера – <SPAN class="keyword">GID</SPAN> (<SPAN class="keyword">group identificator</SPAN>). В одних версиях UNIX каждый пользователь может входить только в одну группу, в других – в несколько групп.</P><DIV class="lecture_mark" id="mark_308"></DIV><DIV class="xml_table_env" id="id_309"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">
<P id="id_310"><B>Команда chown</B></P><DIV class="lecture_mark" id="mark_310"></DIV>
<P id="id_311"><B>Синтаксис команды</B></P><DIV class="lecture_mark" id="mark_311"></DIV>
<DIV class="example"><PRE>chown owner файл1 файл2 ... файлN
</PRE></DIV>
<P id="id_313"><B>Описание команды</B></P><DIV class="lecture_mark" id="mark_313"></DIV>
<P id="id_314">Команда <SPAN class="texample"><SPAN class="keyword">chown</SPAN></SPAN> предназначена для изменения собственника (хозяина) файлов. Настоящее описание не является полным описанием команды, а адаптировано применительно к данному курсу. Для получения полного описания обращайтесь к UNIX Manual. Нового собственника файла могут назначить только предыдущий собственник файла или системный администратор.</P><DIV class="lecture_mark" id="mark_314"></DIV>

<P id="id_316">Параметр <SPAN class="texample">owner</SPAN> задает нового собственника файла в символьном виде, как его <SPAN class="texample">username</SPAN>,или в числовом виде, как его <SPAN class="texample">UID</SPAN>.</P><DIV class="lecture_mark" id="mark_316"></DIV>

<P id="id_320">Параметры <SPAN class="texample">файл1, файл2, ... файлN</SPAN> – это имена файлов, для которых производится изменение собственника. Вместо имен могут использоваться их шаблоны.</P><DIV class="lecture_mark" id="mark_320"></DIV>
</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_309"></DIV><P id="id_322">Для каждого файла, созданного в файловой системе, запоминаются имена его хозяина и группы хозяев. Заметим, что группа хозяев не обязательно должна быть группой, в которую входит хозяин. Упрощенно можно считать, что в операционной системе Linux при создании файла его хозяином становится пользователь, создавший файл, а его группой хозяев – группа, к которой этот пользователь принадлежит. Впоследствии хозяин файла или системный администратор могут передать его в собственность другому пользователю или изменить его группу хозяев с помощью команд <SPAN class="texample"><SPAN class="keyword">chown</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">chgrp</SPAN></SPAN>, описание которых можно найти в UNIX Manual.</P><DIV class="lecture_mark" id="mark_322"></DIV><DIV class="xml_table_env" id="id_325"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">
<P id="id_326"><B>Команда chgrp</B></P><DIV class="lecture_mark" id="mark_326"></DIV>
<P id="id_327"><B>Синтаксис команды</B></P><DIV class="lecture_mark" id="mark_327"></DIV>
<DIV class="example"><PRE>chgrp group файл1 файл2 ... файлN
</PRE></DIV>
<P id="id_329"><B>Описание команды</B></P><DIV class="lecture_mark" id="mark_329"></DIV>
<P id="id_330">Команда <SPAN class="texample"><SPAN class="keyword">chgrp</SPAN></SPAN> предназначена для изменения группы собственников (хозяев) файлов. Настоящее описание не является полным описанием команды, а адаптировано применительно к данному курсу. Для получения полного описания обращайтесь к UNIX Manual. Новую группу собственников файла могут назначить только собственник файла или системный администратор.</P><DIV class="lecture_mark" id="mark_330"></DIV>

<P id="id_332">Параметр <SPAN class="texample">group</SPAN> задает новую группу собственников файла в символьном виде, как имя группы, или в числовом виде, как ее <SPAN class="texample">GID</SPAN>.</P><DIV class="lecture_mark" id="mark_332"></DIV>

<P id="id_335">Параметры <SPAN class="texample">файл1, файл2, ... файлN</SPAN> – это имена файлов, для которых производится изменение группы собственников. Вместо имен могут использоваться их шаблоны.</P><DIV class="lecture_mark" id="mark_335"></DIV>
</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_325"></DIV><P id="id_337">Как мы видим, для каждого файла выделяется три категории пользователей: </P><DIV class="lecture_mark" id="mark_337"></DIV><UL id="id_338"><LI>Пользователь, являющийся хозяином файла; </LI><LI>Пользователи, относящиеся к группе хозяев файла; </LI><LI>Все остальные пользователи. </LI></UL><DIV class="lecture_mark" id="mark_338"></DIV><P id="id_342">Для каждой из этих категорий хозяин файла может определить различные права доступа к файлу. Различают три вида прав доступа: право на чтение файла – <SPAN class="texample">r</SPAN> (от слова read), право на модификацию файла – <SPAN class="texample">w</SPAN> (от слова write) и право на исполнение файла — <SPAN class="texample">x</SPAN> (от слова execute). Для регулярных файлов смысл этих прав совпадает с указанным выше. Для директорий он несколько иной. Право чтения для каталогов позволяет читать имена файлов, находящихся в этом каталоге (и только имена). Поскольку "исполнять" директорию бессмысленно (как, впрочем, и неисполняемый регулярный файл), право доступа на исполнение для директорий меняет смысл: наличие этого права позволяет получить дополнительную информацию о файлах, входящих в каталог (их размер, кто их хозяин, дата создания и т.д.). Без этого права вы не сможете ни читать содержимое файлов, лежащих в директории, ни модифицировать их, ни исполнять. Право на исполнение также требуется для директории, чтобы сделать ее 
<SPAN class="keyword">текущей</SPAN>, а также для всех директорий на пути к ней. Право записи для директории позволяет изменять ее содержимое: создавать и удалять в ней файлы, переименовывать их. Отметим, что для удаления файла достаточно иметь права записи и исполнения для директории, в которую входит данный файл, независимо от прав доступа к самому файлу.</P><DIV class="lecture_mark" id="mark_342"></DIV><A name="sect18"></A><H3>Команда ls с опциями -al. Использование команд chmod и umask</H3><P id="id_346">Получить подробную информацию о файлах в некоторой директории, включая имена хозяина, группы хозяев и права доступа, можно с помощью уже известной нам команды <SPAN class="texample"><SPAN class="keyword">ls</SPAN></SPAN> с опциями -<SPAN class="texample">al</SPAN>. В выдаче этой команды третья колонка слева содержит имена пользователей хозяев файлов, а четвертая колонка слева – имена групп хозяев файла. Самая левая колонка содержит типы файлов и права доступа к ним. Тип файла определяет первый символ в наборе символов. Если это символ '<SPAN class="texample">d</SPAN>', то тип файла – директория, если там стоит символ '<SPAN class="texample">-</SPAN>', то это – регулярный файл. Следующие три символа определяют права доступа для хозяина файла, следующие три – для пользователей, входящих в группу хозяев файла, и последние три – для всех остальных пользователей. Наличие символа (<SPAN class="texample">r</SPAN>, <SPAN class="texample">w</SPAN> или <SPAN class="texample">x</SPAN>), соответствующего праву, для некоторой категории пользователей означает, что данная категория пользователей обладает этим правом.</P><DIV class="lecture_mark" id="mark_346"></DIV><P id="id_354">Вызовите команду <SPAN class="texample"><SPAN class="keyword">ls</SPAN>-al</SPAN> для своей <SPAN class="keyword">домашней директории</SPAN> и проанализируйте ее выдачу.</P><DIV class="lecture_mark" id="mark_354"></DIV><DIV class="xml_table_env" id="id_356"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">
<P id="id_357"><B>Команда chmod</B></P><DIV class="lecture_mark" id="mark_357"></DIV>
<P id="id_358"><B>Синтаксис команды</B></P><DIV class="lecture_mark" id="mark_358"></DIV>
<DIV class="example"><PRE>chmod [who] { + | – | = } [perm] 
    файл1 файл2 ... файлN
</PRE></DIV>
<P id="id_360"><B>Описание команды</B></P><DIV class="lecture_mark" id="mark_360"></DIV>
<P id="id_361">Команда <SPAN class="texample"><SPAN class="keyword">chmod</SPAN></SPAN> предназначена для изменения прав доступа к одному или нескольким файлам. Настоящее описание не является полным описанием команды, а адаптировано применительно к данному курсу. Для получения полного описания обращайтесь к UNIX Manual. Права доступа к файлу могут менять только собственник (хозяин) файла или системный администратор.</P><DIV class="lecture_mark" id="mark_361"></DIV>

<P id="id_363">Параметр <SPAN class="texample">who</SPAN> определяет, для каких категорий пользователей устанавливаются права доступа. Он может представлять собой один или несколько символов:</P><DIV class="lecture_mark" id="mark_363"></DIV>

<P id="id_365"><SPAN class="texample">a</SPAN> – установка прав доступа для всех категорий пользователей. Если параметр <SPAN class="texample">who</SPAN> не задан, то по умолчанию применяется <SPAN class="texample">a</SPAN>. При определении прав доступа с этим значением заданные права устанавливаются с учетом значения маски создания файлов;</P><DIV class="lecture_mark" id="mark_365"></DIV>

<P id="id_369"><SPAN class="texample">u</SPAN> – установка прав доступа для собственника файла;</P><DIV class="lecture_mark" id="mark_369"></DIV>

<P id="id_371"><SPAN class="texample">g</SPAN> – установка прав доступа для пользователей, входящих в группу собственников файла;</P><DIV class="lecture_mark" id="mark_371"></DIV>

<P id="id_373"><SPAN class="texample">O</SPAN> – установка прав доступа для всех остальных пользователей.</P><DIV class="lecture_mark" id="mark_373"></DIV>

<P id="id_375">Операция, выполняемая над правами доступа для заданной категории пользователей, определяется одним из следующих символов:</P><DIV class="lecture_mark" id="mark_375"></DIV>

<P id="id_376"><SPAN class="texample">+</SPAN> – добавление прав доступа;</P><DIV class="lecture_mark" id="mark_376"></DIV>

<P id="id_378"><SPAN class="texample">-</SPAN> – отмена прав доступа;</P><DIV class="lecture_mark" id="mark_378"></DIV>

<P id="id_380"><SPAN class="texample">=</SPAN> – замена прав доступа, т.е. отмена всех существовавших и добавление перечисленных.</P><DIV class="lecture_mark" id="mark_380"></DIV>

<P id="id_382">Если параметр <SPAN class="texample">perm</SPAN> не определен, то все существовавшие права доступа отменяются.</P><DIV class="lecture_mark" id="mark_382"></DIV>

<P id="id_384">Параметр <SPAN class="texample">perm</SPAN> определяет права доступа, которые будут добавлены, отменены или установлены взамен соответствующей командой. Он представляет собой комбинацию следующих символов или один из них:</P><DIV class="lecture_mark" id="mark_384"></DIV>

<P id="id_386"><SPAN class="texample">r</SPAN> – право на чтение;</P><DIV class="lecture_mark" id="mark_386"></DIV>

<P id="id_388"><SPAN class="texample">w</SPAN> – право на модификацию;</P><DIV class="lecture_mark" id="mark_388"></DIV>

<P id="id_390"><SPAN class="texample">x</SPAN> – право на исполнение.</P><DIV class="lecture_mark" id="mark_390"></DIV>

<P id="id_392">Параметры <SPAN class="texample">файл1, файл2, ... файлN</SPAN> – это имена файлов, для которых производится изменение прав доступа. Вместо имен могут использоваться их шаблоны.</P><DIV class="lecture_mark" id="mark_392"></DIV>
</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_356"></DIV><P id="id_394"><A name="keyword-context.16"></A>Хозяин файла может изменять права доступа к нему, пользуясь командой <SPAN class="texample"><SPAN class="keyword_def">chmod</SPAN></SPAN>. </P><DIV class="lecture_mark" id="mark_394"></DIV><P id="id_396">Создайте новый файл и посмотрите на права доступа к нему, установленные системой при его создании. Чем руководствуется операционная система при назначении этих прав? Она использует для этого <SPAN class="keyword">маску создания файлов</SPAN> для программы, которая файл создает. Изначально для программы-оболочки она имеет некоторое значение по умолчанию. </P><DIV class="lecture_mark" id="mark_396"></DIV><DIV class="xml_table_env" id="id_397"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">
<P id="id_398"><B>Маска создания файлов текущего процесса</B></P><DIV class="lecture_mark" id="mark_398"></DIV>

<P id="id_399">Маска создания файлов текущего процесса (<SPAN class="texample">umask</SPAN>) используется системными вызовами <SPAN class="texample">open()</SPAN> и <SPAN class="texample">mknod()</SPAN> при установке начальных прав доступа для вновь создаваемых файлов или FIFO. Младшие 9 бит маски создания файлов соответствуют правам доступа пользователя, создающего файл, группы, к которой он принадлежит, и всех остальных пользователей так, как записано ниже с применением восьмеричных значений:</P><DIV class="lecture_mark" id="mark_399"></DIV>

<P id="id_403"><SPAN class="texample">0400</SPAN> – право чтения для пользователя, создавшего файл;</P><DIV class="lecture_mark" id="mark_403"></DIV>

<P id="id_405"><SPAN class="texample">0200</SPAN> – право записи для пользователя, создавшего файл;</P><DIV class="lecture_mark" id="mark_405"></DIV>

<P id="id_407"><SPAN class="texample">0100</SPAN> – право исполнения для пользователя, создавшего файл;</P><DIV class="lecture_mark" id="mark_407"></DIV>

<P id="id_409"><SPAN class="texample">0040</SPAN> – право чтения для группы пользователя, создавшего файл;</P><DIV class="lecture_mark" id="mark_409"></DIV>

<P id="id_411"><SPAN class="texample">0020</SPAN> – право записи для группы пользователя, создавшего файл;</P><DIV class="lecture_mark" id="mark_411"></DIV>

<P id="id_413"><SPAN class="texample">0010</SPAN> – право исполнения для группы пользователя, создавшего файл;</P><DIV class="lecture_mark" id="mark_413"></DIV>

<P id="id_415"><SPAN class="texample">0004</SPAN> – право чтения для всех остальных пользователей;</P><DIV class="lecture_mark" id="mark_415"></DIV>

<P id="id_417"><SPAN class="texample">0002</SPAN> – право записи для всех остальных пользователей;</P><DIV class="lecture_mark" id="mark_417"></DIV>

<P id="id_419"><SPAN class="texample">0001</SPAN> – право исполнения для всех остальных пользователей.</P><DIV class="lecture_mark" id="mark_419"></DIV>

<P id="id_421">Установление значения какого-либо бита равным <SPAN class="texample">1</SPAN> запрещает инициализацию соответствующего права доступа для вновь создаваемого файла. Значение маски создания файлов может изменяться с помощью системного вызова <SPAN class="texample">umask()</SPAN> или команды <SPAN class="texample"><SPAN class="keyword">umask</SPAN></SPAN>. Маска создания файлов наследуется процессом-ребенком при порождении нового процесса системным вызовом <SPAN class="texample">fork()</SPAN> и входит в состав неизменяемой части системного контекста процесса при системном вызове <SPAN class="texample">exec()</SPAN>. В результате этого наследования изменение маски с помощью команды <SPAN class="texample"><SPAN class="keyword">umask</SPAN></SPAN> окажет влияние на атрибуты доступа к вновь создаваемым файлам для всех процессов, порожденных далее командной оболочкой.</P><DIV class="lecture_mark" id="mark_421"></DIV>
</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_397"></DIV><P id="id_428"><A name="keyword-context.17"></A>Изменить текущее значение маски для программы-оболочки или посмотреть его можно с помощью команды <SPAN class="texample"><SPAN class="keyword_def">umask</SPAN></SPAN>. </P><DIV class="lecture_mark" id="mark_428"></DIV><DIV class="xml_table_env" id="id_430"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">
<P id="id_431"><B>Команда umask</B></P><DIV class="lecture_mark" id="mark_431"></DIV>
<P id="id_432"><B>Синтаксис команды</B></P><DIV class="lecture_mark" id="mark_432"></DIV>
<DIV class="example"><PRE>umask [value]
</PRE></DIV>
<P id="id_434"><B>Описание команды</B></P><DIV class="lecture_mark" id="mark_434"></DIV>
<P id="id_435">Команда <SPAN class="texample"><SPAN class="keyword">umask</SPAN></SPAN> предназначена для изменения маски создания файлов командной оболочки или просмотра ее текущего значения. При отсутствии параметра команда выдает значение установленной маски создания файлов в восьмеричном виде. Для установления нового значения оно задается как параметр <SPAN class="texample">value</SPAN> в восьмеричном виде.</P><DIV class="lecture_mark" id="mark_435"></DIV>
</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_430"></DIV><P id="id_438">Если вы хотите изменить его для Midnight Commander, необходимо выйти из <SPAN class="texample">mc</SPAN>, выполнить команду <SPAN class="texample"><SPAN class="keyword">umask</SPAN></SPAN> и запустить <SPAN class="texample">mc</SPAN> снова. <SPAN class="keyword">Маска создания файлов</SPAN> не сохраняется между сеансами работы в системе. При новом входе в систему значение маски снова будет установлено по умолчанию.</P><DIV class="lecture_mark" id="mark_438"></DIV><A name="sect19"></A><H3>Системные вызовы getuid и getgid </H3><P id="id_442"><A name="keyword-context.18"></A><A name="keyword-context.19"></A>Узнать <SPAN class="keyword">идентификатор пользователя</SPAN>, запустившего программу на исполнение, – <SPAN class="keyword">UID</SPAN> и <SPAN class="keyword">идентификатор группы</SPAN>, к которой он относится, – <SPAN class="keyword">GID</SPAN> можно с помощью системных вызовов <SPAN class="texample"><SPAN class="keyword_def">getuid()</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword_def">getgid()</SPAN></SPAN>, применив их внутри этой программы. </P><DIV class="lecture_mark" id="mark_442"></DIV><DIV class="xml_table_env" id="id_445"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">
<P id="id_446"><B>Системные вызовы getuid() и getgid()</B></P><DIV class="lecture_mark" id="mark_446"></DIV>
<P id="id_447"><B>Прототипы системных вызовов</B></P><DIV class="lecture_mark" id="mark_447"></DIV>
<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
uid_t getuid(void);
gid_t getgid(void);
</PRE></DIV>
<P id="id_449"><B>Описание системных вызовов</B></P><DIV class="lecture_mark" id="mark_449"></DIV>

<P id="id_450">Системный вызов <SPAN class="texample"><SPAN class="keyword">getuid</SPAN></SPAN> возвращает идентификатор пользователя для текущего процесса.</P><DIV class="lecture_mark" id="mark_450"></DIV>

<P id="id_452">Системный вызов <SPAN class="texample"><SPAN class="keyword">getgid</SPAN></SPAN> возвращает идентификатор группы пользователя для текущего процесса.</P><DIV class="lecture_mark" id="mark_452"></DIV>

<P id="id_454">Типы данных <SPAN class="texample">uid_t</SPAN> и <SPAN class="texample">gid_t</SPAN> являются синонимами для одного из целочисленных типов языка C.</P><DIV class="lecture_mark" id="mark_454"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_445"></DIV><A name="sect20"></A><H3>Компиляция программ на языке C в UNIX и запуск их на счет</H3><P id="id_457">Теперь мы готовы к тому, чтобы написать первую программу в нашем курсе. Осталось только научиться компилировать программы на языке C и запускать их на счет. Для компиляции программ в Linux мы будем применять компилятор <SPAN class="texample">gcc</SPAN>. </P><DIV class="lecture_mark" id="mark_457"></DIV><P id="id_459"><B>Для того чтобы он нормально работал, необходимо, чтобы исходные файлы, содержащие текст программы, имели имена, заканчивающиеся на</B> <SPAN class="texample">.c. </SPAN></P><DIV class="lecture_mark" id="mark_459"></DIV><P id="id_461">В простейшем случае откомпилировать программу можно, запуская компилятор командой </P><DIV class="lecture_mark" id="mark_461"></DIV><DIV class="example"><PRE>gcc имя_исходного_файла 
</PRE></DIV><P id="id_463">Если программа была написана без ошибок, то компилятор создаст исполняемый файл с именем <SPAN class="texample">a.out</SPAN>. Изменить имя создаваемого исполняемого файла можно, задав его с помощью опции <SPAN class="texample">-o</SPAN>:</P><DIV class="lecture_mark" id="mark_463"></DIV><DIV class="example"><PRE>gcc имя_исходного_файла -o 
    имя_исполняемого_файла
</PRE></DIV><P id="id_467">Компилятор <SPAN class="texample">gcc</SPAN> имеет несколько сотен возможных опций. Получить информацию о них вы можете в UNIX Manual.</P><DIV class="lecture_mark" id="mark_467"></DIV><P id="id_469"><B>"Узнайте у своего системного администратора"</B>, как называется компилятор с языка C для вашей операционной системы и какие опции он имеет. Обычно во всех версиях UNIX имеется компилятор с именем <SPAN class="texample">cc</SPAN>, поддерживающий опцию <SPAN class="texample">–о</SPAN>.</P><DIV class="lecture_mark" id="mark_469"></DIV><P id="id_472">Запустить программу на исполнение можно, набрав имя исполняемого файла и нажав клавишу &lt;Enter&gt;. </P><DIV class="lecture_mark" id="mark_472"></DIV><A name="sect21"></A><H3>Написание, компиляция и запуск программы c использованием системных вызовов getuid() и getgid()</H3><P id="id_473">Напишите, откомпилируйте и запустите программу, которая печатала бы <SPAN class="keyword">идентификатор пользователя</SPAN>, запустившего программу, и <SPAN class="keyword">идентификатор его группы</SPAN>.</P><DIV class="lecture_mark" id="mark_473"></DIV><TABLE border="0" cellpadding="0" cellspacing="0" width="100%"><TBODY><TR><TD height="4"><IMG src="./1. Введение в курс практических занятий. Знакомство с операционной системой UNIX_files/empty.gif" width="1" height="4"></TD></TR><TR><TD class="orang"><IMG src="./1. Введение в курс практических занятий. Знакомство с операционной системой UNIX_files/empty.gif" width="1" height="1" border="0"></TD></TR><TR><TD height="8"><IMG src="./1. Введение в курс практических занятий. Знакомство с операционной системой UNIX_files/empty.gif" width="1" height="8"></TD></TR></TBODY></TABLE>


        &nbsp;
        <A name="footnote.1"></A><SPAN class="objectName"><SUP>1)</SUP></SPAN>
        &nbsp;
        Описание редактора <SPAN class="texample">ed</SPAN> можно найти, например, в <A target="_blank" href="http://www.intuit.ru/department/os/osintropractice/popup.lit.html#11">[11]</A>. В электронном виде описание есть в документе <A target="_blank" href="http://cs.mipt.ru/docs/comp/rus/os/unix/user_guide/unixuser/gl6_1.htm">http://cs.mipt.ru/docs/comp/rus/os/unix/user_guide/unixuser/gl6_1.htm</A>.<BR>


        &nbsp;
        <A name="footnote.2"></A><SPAN class="objectName"><SUP>2)</SUP></SPAN>
        &nbsp;
        Описание редактора <SPAN class="texample">vi</SPAN> тоже можно найти в <A target="_blank" href="http://www.intuit.ru/department/os/osintropractice/popup.lit.html#11">[11]</A>. В электронном виде описание есть в документе <A target="_blank" href="http://cs.mipt.ru/docs/comp/rus/os/unix/user_guide/unixuser/gl7_1.htm">http://cs.mipt.ru/docs/comp/rus/os/unix/user_guide/unixuser/gl7_1.htm</A>.<BR>


        &nbsp;
        <A name="footnote.3"></A><SPAN class="objectName"><SUP>3)</SUP></SPAN>
        &nbsp;
        В электронном виде описание редактора emacs см. в документе <A target="_blank" href="http://cs.mipt.ru/docs/comp/rus/os/unix/user_guide/emacs/index.html">http://cs.mipt.ru/docs/comp/rus/os/unix/user_guide/emacs/index.html</A>.


	</TD>
	</TR>
	<TR><TD height="8"><IMG src="./1. Введение в курс практических занятий. Знакомство с операционной системой UNIX_files/empty.gif" width="1" height="8"></TD></TR>
	</TBODY></TABLE>
	<!-- /content -->

</TD>
<TD><IMG src="./1. Введение в курс практических занятий. Знакомство с операционной системой UNIX_files/empty.gif" width="8" height="1"></TD>
</TR>
</TBODY></TABLE>
<!-- /bottom -->
<TABLE border="0" cellpadding="0" cellspacing="0" width="100%">
<TBODY><TR><TD class="orang" height="1"><IMG src="./1. Введение в курс практических занятий. Знакомство с операционной системой UNIX_files/empty.gif" width="1" height="1"></TD></TR>
<TR><TD class="ltxt" align="center">© INTUIT.ru, 2003-2009. Все права защищены.</TD>
</TR>
</TBODY></TABLE>
<!-- /bottom -->

<SCRIPT src="./1. Введение в курс практических занятий. Знакомство с операционной системой UNIX_files/urchin.js" type="text/javascript">
</SCRIPT>
<SCRIPT type="text/javascript">
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>


</BODY></HTML>