
<!-- saved from url=(0077)http://www.intuit.ru/department/os/osintropractice/10/osintropractice_10.html -->
<HTML><HEAD><META http-equiv="Content-Type" content="text/html; charset=windows-1251">

<TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<LINK href="./10. Семейство протоколов TCP-IP. Сокеты (sockets) в UNIX и основы работы с ними_files/printable.css" type="text/css" rel="stylesheet">
</HEAD><BODY leftmargin="6" topmargin="6" marginheight="6" marginwidth="6">

<DIV align="left">
<SPAN style="color: #000000; font-weight: bold;">
&nbsp;&nbsp;
<SPAN style="font-size:12pt;">Интернет-Университет Информационных Технологий</SPAN>
</SPAN>
</DIV>

&nbsp;&nbsp;
<SPAN align="rright" style="color: #330066; text-decoration:underline;">http://www.INTUIT.ru</SPAN>


<TABLE border="0" cellpadding="0" cellspacing="0" width="100%">
<TBODY><TR><TD height="8" colspan="3"><IMG src="./10. Семейство протоколов TCP-IP. Сокеты (sockets) в UNIX и основы работы с ними_files/empty.gif" width="1" height="8"></TD></TR>
<TR><TD class="orang" height="1" colspan="3"><IMG src="./10. Семейство протоколов TCP-IP. Сокеты (sockets) в UNIX и основы работы с ними_files/empty.gif" width="1" height="1"></TD></TR>
<TR><TD height="8" colspan="3"><IMG src="./10. Семейство протоколов TCP-IP. Сокеты (sockets) в UNIX и основы работы с ними_files/empty.gif" width="1" height="8"></TD></TR>
<TR valign="top">
<TD><IMG src="./10. Семейство протоколов TCP-IP. Сокеты (sockets) в UNIX и основы работы с ними_files/empty.gif" width="8" height="1"></TD>
<TD>
	<!-- content -->
	<TABLE border="0" cellpadding="0" cellspacing="0" width="100%">
	<TBODY><TR><TD class="head">Основы операционных систем. Практикум</TD></TR>
<TR><TD height="4"><IMG src="./10. Семейство протоколов TCP-IP. Сокеты (sockets) в UNIX и основы работы с ними_files/empty.gif" width="1" height="4"></TD></TR>
	<TR><TD class="orang" height="1"><IMG src="./10. Семейство протоколов TCP-IP. Сокеты (sockets) в UNIX и основы работы с ними_files/empty.gif" width="1" height="1"></TD></TR>
	<TR><TD height="8"><IMG src="./10. Семейство протоколов TCP-IP. Сокеты (sockets) в UNIX и основы работы с ними_files/empty.gif" width="1" height="8"></TD></TR>
	<TR><TD><SPAN class="headsub">


10. Лекция:

 Семейство протоколов TCP/IP. Сокеты (sockets) в UNIX и основы работы с ними: версия для печати и PDA</SPAN>

<BR>
<SPAN class="rtxt">Краткая история семейства протоколов TCP/IP. Общие сведения об архитектуре семейства протоколов TCP/IP. Уровень сетевого интерфейса. Уровень Internet. Протоколы IP, ICMP, ARP, RARP. Internet-адреса. Транспортный уровень. Протоколы TCP и UDP. UDP и TCP сокеты (sockets). Адресные пространства портов. Понятие encapsulation. Уровень приложений/программ. Использование модели клиент-сервер при изучении сетевого программирования. Организация связи между удаленными процессами с помощью датаграмм. Сетевой порядок байт. Функции htons(), htonl(), ntohs(), ntohl(). Функции преобразования IP-адресов inet_ntoa(), inet_aton(). Функция bzero(). Системные вызовы socket(), bind(), sendto(), recvfrom(). Организация связи между процессами с помощью установки логического соединения. Системные вызовы connect(), listen(), accept(). Использование интерфейса сокетов для других семейств протоколов. Файлы типа "сокет".
</SPAN>

</TD></TR>

	<TR><TD height="8"><IMG src="./10. Семейство протоколов TCP-IP. Сокеты (sockets) в UNIX и основы работы с ними_files/empty.gif" width="1" height="8"></TD></TR>
	<TR><TD class="orang" height="1"><IMG src="./10. Семейство протоколов TCP-IP. Сокеты (sockets) в UNIX и основы работы с ними_files/empty.gif" width="1" height="1"></TD></TR>
	<TR><TD height="8"><IMG src="./10. Семейство протоколов TCP-IP. Сокеты (sockets) в UNIX и основы работы с ними_files/empty.gif" width="1" height="8"></TD></TR>
	<TR><TD>


<A name="sect1"></A><H3>Краткая история семейства протоколов TCP/IP </H3><P id="id_1">Мы приступаем к последней теме наших семинарских и практических занятий – введению в сетевое программирование в операционной системе UNIX.</P><DIV class="lecture_mark" id="mark_1"></DIV><P id="id_2">Все многообразие сетевых приложений и многомиллионная всемирная компьютерная сеть выросли из четырехкомпьютерной сети ARPANET, созданной по заказу Министерства Обороны США и связавшей вычислительные комплексы в Стэндфордском исследовательском институте, Калифорнийском университете в Санта-Барбаре, Калифорнийском университете в Лос-Анджелесе и университете Юты. Первая передача информации между двумя компьютерами сети ARPANET состоялась в октябре 1969 года, и эту дату принято считать датой рождения нелокальных компьютерных сетей. (Необходимо отметить, что дата является достаточно условной, так как первая связь двух удаленных компьютеров через коммутируемые телефонные линии была осуществлена еще в 1965 году, а реальные возможности для разработки пользователями ARPANET сетевых приложений появились только в 1972 году.) Эта сеть росла и почковалась, закрывались ее отдельные части, появлялись ее гражданские аналоги, они сливались вместе, и в результате "что выросло – то выросло".</P><DIV class="lecture_mark" id="mark_2"></DIV><P id="id_3">При создании ARPANET был разработан протокол сетевого взаимодействия коммуникационных узлов – Network Control Protocol (NCP), осуществлявший связь посредством передачи <SPAN class="keyword">датаграмм</SPAN> (см. лекцию 14, раздел "Связь с установлением <SPAN class="keyword">логического соединения</SPAN> и передача данных с помощью сообщений"). Этот протокол был предназначен для конкретного архитектурного построения сети и базировался на предположении, что сеть является статической и настолько надежной, что компьютерам не требуется умения реагировать на возникающие ошибки. По мере роста ARPANET и необходимости подключения к ней сетей, построенных на других архитектурных принципах (пакетные спутниковые сети, наземные пакетные радиосети), от этого предположения пришлось отказаться и искать другие подходы к построению сетевых систем. Результатом исследований в этих областях стало появление <SPAN class="keyword">семейства протоколов TCP/IP</SPAN>, на базе которого обеспечивалась надежная доставка информации по неоднородной сети. Это семейство протоколов до сих пор занимает ведущее место в качестве сетевой технологии, используемой в операционной системе UNIX. Именно поэтому мы и выбрали его для практической иллюстрации общих сетевых решений, изложенных в лекции 14.</P><DIV class="lecture_mark" id="mark_3"></DIV><A name="sect2"></A><H3>Общие сведения об архитектуре семейства протоколов TCP/IP</H3><P id="id_4"><SPAN class="keyword">Семейство протоколов TCP/IP</SPAN> построено по "слоеному" принципу, подробно рассмотренному в лекции (лекция 14, раздел "Многоуровневая модель построения сетевых вычислительных систем"). Хотя оно и имеет многоуровневую структуру, его строение отличается от строения эталонной модели OSI, предложенной стандартом ISO. Это и неудивительно, так как основные черты <SPAN class="keyword">семейства TCP/IP</SPAN> были заложены до появления эталонной модели и во многом послужили толчком для ее разработки. В <SPAN class="keyword">семействе протоколов TCP/IP</SPAN> можно выделить четыре уровня:</P><DIV class="lecture_mark" id="mark_4"></DIV><UL id="id_5"><LI><SPAN class="keyword">Уровень сетевого интерфейса</SPAN>. </LI><LI><SPAN class="keyword">Уровень Internet</SPAN>. </LI><LI><SPAN class="keyword">Транспортный уровень</SPAN>. </LI><LI><SPAN class="keyword">Уровень приложений/процессов</SPAN>. </LI></UL><DIV class="lecture_mark" id="mark_5"></DIV><P id="id_10">Соотношение уровней <SPAN class="keyword">семейства TCP/IP</SPAN> и уровней модели OSI/ISO приведено на <A href="http://www.intuit.ru/department/os/osintropractice/10/osintropractice_10.html#image.15-16.1">рисунке 15–16.1</A>.</P><DIV class="lecture_mark" id="mark_10"></DIV><P align="left" id="id_11"><A name="image.15-16.1"></A></P><DIV><IMG src="./10. Семейство протоколов TCP-IP. Сокеты (sockets) в UNIX и основы работы с ними_files/15-16-1.gif" alt="Соотношение моделей OSI/ISO и TCP/IP" width="446" height="415"></DIV><BR><B>Рис. 15-16.1.</B>&nbsp;
        Соотношение моделей OSI/ISO и TCP/IP<P></P><DIV class="lecture_mark" id="mark_11"></DIV><P id="id_12">На каждом уровне <SPAN class="keyword">семейства TCP/IP</SPAN> присутствует несколько протоколов. Связь между наиболее употребительными протоколами и их принадлежность уровням изображены на <A href="http://www.intuit.ru/department/os/osintropractice/10/osintropractice_10.html#image.15-16.2">рисунке 15–16.2</A>. </P><DIV class="lecture_mark" id="mark_12"></DIV><P id="id_13">Давайте кратко охарактеризуем каждый уровень семейства.</P><DIV class="lecture_mark" id="mark_13"></DIV><P align="left" id="id_14"><A name="image.15-16.2"></A></P><DIV><IMG src="./10. Семейство протоколов TCP-IP. Сокеты (sockets) в UNIX и основы работы с ними_files/15-16-2.gif" alt="Основные протоколы семейства TCP/IP" width="447" height="288"></DIV><BR><B>Рис. 15-16.2.</B>&nbsp;
        Основные протоколы семейства TCP/IP<P></P><DIV class="lecture_mark" id="mark_14"></DIV><A name="sect3"></A><H3>Уровень сетевого интерфейса </H3><P id="id_15"><A name="keyword-context.1"></A>
<SPAN class="keyword_def">Уровень сетевого интерфейса</SPAN> составляют протоколы, которые обеспечивают передачу данных между узлами связи, физически напрямую соединенными друг с другом, или, иначе говоря, подключенными к одному сегменту сети, и соответствующие физические средства передачи данных. К этому уровню относятся протоколы Ethernet, Token Ring, SLIP, PPP и т.д. и такие физические средства как витая пара, коаксиальный кабель, оптоволоконный кабель и т.д. Формально <SPAN class="keyword">протоколы уровня сетевого интерфейса</SPAN> не являются частью <SPAN class="keyword">семейства TCP/IP</SPAN>, но существующие стандарты определяют, каким образом должна осуществляться передача данных <SPAN class="keyword">семейства TCP/IP</SPAN> с использованием этих протоколов. На <SPAN class="keyword">уровне сетевого интерфейса</SPAN> в операционной системе UNIX обычно функционируют 

драйверы различных сетевых плат.</P><DIV class="lecture_mark" id="mark_15"></DIV><P id="id_16">Передача информации на <SPAN class="keyword">уровне сетевого интерфейса</SPAN> производится на основании физических адресов, соответствующих точкам входа сети в узлы связи (например, физических адресов сетевых карт). Каждая точка входа имеет свой уникальный адрес – <SPAN class="keyword">MAC-адрес</SPAN> (Media Access Control), физически зашитый в нее на этапе изготовления. Так, например, каждая сетевая плата Ethernet имеет собственный уникальный 48-битовый номер.</P><DIV class="lecture_mark" id="mark_16"></DIV><A name="sect4"></A><H3>Уровень Internet. Протоколы IP, ICMP, ARP, RARP. Internet–адреса</H3><P id="id_17">Из многочисленных протоколов <SPAN class="keyword">уровня Internet</SPAN> мы перечислим только те, которые будут в дальнейшем упоминаться в нашем курсе:</P><DIV class="lecture_mark" id="mark_17"></DIV><UL id="id_18"><LI><A name="keyword-context.2"></A>
	<SPAN class="keyword_def">ICMP</SPAN> – Internet Control Message Protocol. Протокол обработки ошибок и обмена управляющей информацией между узлами сети. </LI><LI><A name="keyword-context.3"></A>
	<SPAN class="keyword_def">IP – Internet Protocol</SPAN>. Это протокол, который обеспечивает доставку пакетов информации для <SPAN class="keyword">протокола ICMP</SPAN> и протоколов <SPAN class="keyword">транспортного уровня</SPAN> TCP и UDP. </LI><LI><A name="keyword-context.4"></A>
	<SPAN class="keyword_def">ARP</SPAN> – Address Resolution Protocol. Это протокол для отображения адресов <SPAN class="keyword">уровня Internet</SPAN> в адреса <SPAN class="keyword">уровня сетевого интерфейса</SPAN>. </LI><LI><A name="keyword-context.5"></A>
	<SPAN class="keyword_def">RARP</SPAN> – Reverse Address Resolution Protocol. Этот протокол служит для решения обратной задачи: отображения адресов <SPAN class="keyword">уровня сетевого интерфейса</SPAN> в адреса <SPAN class="keyword">уровня Internet</SPAN>. </LI></UL><DIV class="lecture_mark" id="mark_18"></DIV><P id="id_23">Два последних протокола используются не для всех сетей; только некоторые сети требуют их применения.</P><DIV class="lecture_mark" id="mark_23"></DIV><P id="id_24"><A name="keyword-context.6"></A><SPAN class="keyword_def">Уровень Internet</SPAN> обеспечивает доставку информации от сетевого узла отправителя к сетевому узлу получателя без установления <SPAN class="keyword">виртуального соединения</SPAN> с помощью <SPAN class="keyword">датаграмм</SPAN> и не является надежным. </P><DIV class="lecture_mark" id="mark_24"></DIV><P id="id_25">Центральным протоколом уровня является <SPAN class="keyword">протокол IP</SPAN>. Вся информация, поступающая к нему от других протоколов, оформляется в виде IP-пакетов данных (IP datagrams). Каждый IP-пакет содержит адреса компьютера отправителя и компьютера получателя, поэтому он может передаваться по сети независимо от других пакетов и, возможно, по своему собственному маршруту. Любая ассоциативная связь между пакетами, предполагающая знания об их содержании, должна осуществляться на более высоком уровне семейства протоколов. </P><DIV class="lecture_mark" id="mark_25"></DIV><P id="id_26">IP-уровень <SPAN class="keyword">семейства TCP/IP</SPAN> не является уровнем, обеспечивающим надежную связь, так как он не гарантирует ни доставку отправленного пакета информации, ни то, что пакет будет доставлен без ошибок. IP вычисляет и проверяет контрольную сумму, которая покрывает только его собственный 20-байтовый заголовок для пакета информации (включающий, например, адреса отправителя и получателя). Если IP-заголовок пакета при передаче оказывается испорченным, то весь пакет просто отбрасывается. Ответственность за повторную передачу пакета тем самым возлагается на вышестоящие уровни.</P><DIV class="lecture_mark" id="mark_26"></DIV><P id="id_27"><SPAN class="keyword">IP протокол</SPAN>, при необходимости, осуществляет фрагментацию и дефрагментацию данных, передаваемых по сети. Если размер IP-пакета слишком велик для дальнейшей передачи по сети, то полученный пакет разбивается на несколько фрагментов, и каждый фрагмент оформляется в виде нового IP-пакета с теми же адресами отправителя и получателя. Фрагменты собираются в единое целое только в конечной точке своего путешествия. Если при дефрагментации пакета обнаруживается, что хотя бы один из фрагментов был потерян или отброшен, то отбрасывается и весь пакет целиком.</P><DIV class="lecture_mark" id="mark_27"></DIV><P id="id_28"><SPAN class="keyword">Уровень Internet</SPAN> отвечает за маршрутизацию пакетов. Для обмена информацией между узлами сети в случае возникновения проблем с маршрутизацией пакетов используется <SPAN class="keyword">протокол ICMP</SPAN>. С помощью сообщений этого же протокола <SPAN class="keyword">уровень Internet</SPAN> умеет частично управлять скоростью передачи данных – он может попросить отправителя уменьшить скорость передачи. </P><DIV class="lecture_mark" id="mark_28"></DIV><P id="id_29">Поскольку на <SPAN class="keyword">уровне Internet</SPAN> информация передается от компьютера-отправителя к компьютеру-получателю, ему требуются специальные <SPAN class="keyword">IP-адреса</SPAN> компьютеров (а точнее, их точек подсоединения к сети – сетевых интерфейсов) – удаленные части полных адресов процессов (см. лекцию 14, раздел "Удаленная адресация и разрешение адресов"). Мы будем далее работать с IP версии 4 (IPv4), которая предполагает наличие у каждого сетевого интерфейса уникального 32-битового адреса. Когда разрабатывалось <SPAN class="keyword">семейство протоколов TCP/IP</SPAN>, казалось, что 32 битов адреса будет достаточно для всех нужд сети, однако не прошло и 30 лет, как выяснилось, что этого мало. Поэтому была разработана версия 6 для IP (IPv6), предполагающая наличие 128-битовых адресов. С точки зрения сетевого программиста IPv6 мало отличается от IPv4, но имеет более сложный интерфейс передачи параметров, поэтому для практических занятий 
был выбран IPv4.</P><DIV class="lecture_mark" id="mark_29"></DIV><P id="id_30">Все <SPAN class="keyword">IP-адреса</SPAN> версии 4 принято делить на 5 классов. Принадлежность адреса к некоторому классу определяют по количеству последовательных 1 в старших битах адреса (см. <A href="http://www.intuit.ru/department/os/osintropractice/10/osintropractice_10.html#image.15-16.3">рис. 15–16.3</A>). Адреса классов A, B и C используют собственно для адресации сетевых интерфейсов. Адреса класса D применяются для групповой рассылки информации (multicast addresses) и далее нас интересовать не будут. Класс E (про который во многих книгах по сетям забывают) был зарезервирован для будущих расширений.</P><DIV class="lecture_mark" id="mark_30"></DIV><P id="id_31">Каждый из <SPAN class="keyword">IP-адресов</SPAN> классов A–C логически делится на две части: идентификатор или номер сети и идентификатор или номер узла в этой сети. Идентификаторы сетей в настоящее время присваиваются локальным сетям специальной международной организацией – корпорацией Internet по присвоению имен и номеров (ICANN). Присвоение адреса конкретному узлу сети, получившей идентификатор, является заботой ее администратора. Класс A предназначен для небольшого количества сетей, содержащих очень много компьютеров, класс C – напротив, для большого количества сетей с малым числом компьютеров. Класс B занимает среднее положение. Надо отметить, что все идентификаторы сетей классов A и B к настоящему моменту уже задействованы.</P><DIV class="lecture_mark" id="mark_31"></DIV><P align="left" id="id_32"><A name="image.15-16.3"></A></P><DIV><IMG src="./10. Семейство протоколов TCP-IP. Сокеты (sockets) в UNIX и основы работы с ними_files/15-16-3.gif" alt="Классы IP-адресов" width="447" height="302"></DIV><BR><B>Рис. 15-16.3.</B>&nbsp;
        Классы IP-адресов<P></P><DIV class="lecture_mark" id="mark_32"></DIV><P id="id_33">Любая организация, которой был выделен идентификатор сети из любого класса, может произвольным образом разделить имеющееся у нее адресное пространство идентификаторов узлов для создания подсетей. </P><DIV class="lecture_mark" id="mark_33"></DIV><P id="id_34">Допустим, что вам выделен адрес сети класса C, в котором под номер узла сети отведено 8 бит. Если нужно присвоить <SPAN class="keyword">IP-адреса</SPAN> 100 компьютерам, которые организованы в 10 Ethernet-сегментов по 10 компьютеров в каждом, можно поступить по-разному. Можно присвоить номера от 1 до 100 компьютерам, игнорируя их принадлежность к конкретному сегменту – воспользовавшись стандартной формой <SPAN class="keyword">IP-адреса</SPAN>. Или же можно выделить несколько младших бит из адресного пространства идентификаторов узлов для идентификации сегмента сети, например 4 бита, а для адресации узлов внутри сегмента использовать оставшиеся 4 бита. Последний способ получил название адресации с использованием подсетей (см. <A href="http://www.intuit.ru/department/os/osintropractice/10/osintropractice_10.html#image.15-16.4">рис. 15–16.4</A>).</P><DIV class="lecture_mark" id="mark_34"></DIV><P id="id_35">Запоминать четырехбайтовые числа для человека достаточно сложно, поэтому принято записывать <SPAN class="keyword">IP-адреса</SPAN> в символической форме, переводя значение каждого байта в десятичный вид по отдельности и разделяя полученные десятичные числа в записи точками, начиная со старшего байта: <B>192.168.253.10</B>.</P><DIV class="lecture_mark" id="mark_35"></DIV><P align="left" id="id_36"><A name="image.15-16.4"></A></P><DIV><IMG src="./10. Семейство протоколов TCP-IP. Сокеты (sockets) в UNIX и основы работы с ними_files/15-16-4.gif" alt="Адресация с подсетями" width="447" height="140"></DIV><BR><B>Рис. 15-16.4.</B>&nbsp;
        Адресация с подсетями<P></P><DIV class="lecture_mark" id="mark_36"></DIV><P id="id_37">Допустим, что мы имеем дело с сегментом сети, использующим Ethernet на <SPAN class="keyword">уровне сетевого интерфейса</SPAN> и состоящим из компьютеров, где применяются <SPAN class="keyword">протоколы TCP/IP</SPAN> на более высоких уровнях. Тогда у нас в сети есть два вида адресов: 48-битовые физические адреса Ethernet (<SPAN class="keyword">MAC-адреса</SPAN>) и 32-битовые <SPAN class="keyword">IP-адреса</SPAN>. Для нормальной передачи информации необходимо, чтобы Internet уровень семейства протоколов, обращаясь к <SPAN class="keyword">уровню сетевого интерфейса</SPAN>, знал, какой физический адрес соответствует данному <SPAN class="keyword">IP-адресу</SPAN> и наоборот, т.е. умел "разрешать адреса". В очередной раз мы сталкиваемся с проблемой разрешения адресов, которая в различных постановках разбиралась в материалах лекций. При разрешении адресов может возникнуть две сложности:</P><DIV class="lecture_mark" id="mark_37"></DIV><UL id="id_38"><LI>Если мы знаем <SPAN class="keyword">IP-адреса</SPAN> компьютеров, которым или через которые мы хотим передать данные, то каким образом <SPAN class="keyword">Internet уровень</SPAN> <SPAN class="keyword">семейства протоколов TCP/IP</SPAN> сможет определить соответствующие им <SPAN class="keyword">MAC-адреса</SPAN>? Эта проблема получила название address resolution problem (проблема разрешения адресов). </LI><LI>Пусть у нас есть бездисковые рабочие станции или рабочие станции, на которых операционные системы сгенерированы без назначения <SPAN class="keyword">IP-адресов</SPAN> (это часто делается, когда один и тот же образ операционной системы загружается на ряд компьютеров, например, в учебных классах). Тогда при старте операционной системы на каждом таком компьютере операционная система знает только <SPAN class="keyword">MAC-адреса</SPAN>, соответствующие данному компьютеру. Как можно определить, какой Internet-адрес был выделен данной рабочей станции? Эта проблема называется reverse address resolution problem (обратная проблема разрешения адресов).</LI></UL><DIV class="lecture_mark" id="mark_38"></DIV><P id="id_41">Первая задача решается с использованием <SPAN class="keyword">протокола ARP</SPAN>, вторая – с помощью <SPAN class="keyword">протокола RARP</SPAN>.</P><DIV class="lecture_mark" id="mark_41"></DIV><P id="id_42"><SPAN class="keyword">Протокол ARP</SPAN> позволяет компьютеру разослать специальное сообщение по всему сегменту сети, которое требует от компьютера, имеющего содержащийся в сообщении <SPAN class="keyword">IP-адрес</SPAN>, откликнуться и указать свой физический адрес. Это сообщение поступает всем компьютерам в сегменте сети, но откликается на него только тот, кого спрашивали. После получения ответа запрашивавший компьютер может установить необходимое соответствие между <SPAN class="keyword">IP-адресом</SPAN> и <SPAN class="keyword">MAC-адресом</SPAN>. </P><DIV class="lecture_mark" id="mark_42"></DIV><P id="id_43">Для решения второй проблемы один или несколько компьютеров в сегменте сети должны выполнять функции <SPAN class="keyword">RARP</SPAN>-сервера и содержать набор физических адресов для рабочих станций и соответствующих им <SPAN class="keyword">IP-адресов</SPAN>. Когда рабочая станция с операционной системой, сгенерированной без назначения <SPAN class="keyword">IP-адреса</SPAN>, начинает свою работу, она получает <SPAN class="keyword">MAC-адрес</SPAN> от сетевого оборудования и рассылает соответствующий <SPAN class="keyword">RARP</SPAN>-запрос, содержащий этот адрес, всем компьютерам сегмента сети. Только <SPAN class="keyword">RARP</SPAN>-сервер, содержащий информацию о соответствии указанного физического адреса и выделенного <SPAN class="keyword">IP-адреса</SPAN>, откликается на данный запрос и отправляет ответ, содержащий <SPAN class="keyword">IP-адрес</SPAN>.</P><DIV class="lecture_mark" id="mark_43"></DIV><A name="sect5"></A><H3>Транспортный уровень. Протоколы TCP и UDP. TCP и UDP сокеты. Адресные пространства портов. Понятие encapsulation </H3><P id="id_44">Мы не будем вдаваться в детали реализации протоколов <SPAN class="keyword">транспортного уровня</SPAN>, а лишь кратко рассмотрим их основные характеристики. К протоколам <SPAN class="keyword">транспортного уровня</SPAN> относятся <SPAN class="keyword">протоколы TCP</SPAN> и <SPAN class="keyword">UDP</SPAN>. </P><DIV class="lecture_mark" id="mark_44"></DIV><P id="id_45"><A name="keyword-context.7"></A><SPAN class="keyword_def">Протокол TCP</SPAN> реализует потоковую модель передачи информации, хотя в его основе, как и в основе <SPAN class="keyword">протокола UDP</SPAN>, лежит обмен информацией через пакеты данных. Он представляет собой ориентированный на установление логической связи (connection-oriented), надежный (обеспечивающий проверку контрольных сумм, передачу подтверждения в случае правильного приема сообщения, повторную передачу пакета данных в случае неполучения подтверждения в течение определенного промежутка времени, правильную последовательность получения информации, полный контроль скорости передачи данных) дуплексный способ связи между процессами в сети. <A name="keyword-context.8"></A><SPAN class="keyword_def">Протокол UDP</SPAN>, наоборот, является способом связи ненадежным, ориентированным на передачу сообщений (<SPAN class="keyword">датаграмм</SPAN>). От <SPAN class="keyword">протокола IP</SPAN> он отличается двумя основными чертами: использованием для проверки правильности принятого сообщения контрольной суммы, насчитанной по всему сообщению, и передачей информации не от узла сети к другому узлу, а от отправителя к получателю. </P><DIV class="lecture_mark" id="mark_45"></DIV><P id="id_46">Полный адрес удаленного процесса или промежуточного объекта для конкретного способа связи с точки зрения операционных систем определяется парой адресов: <SPAN class="texample">&lt;числовой адрес компьютера в сети, локальный адрес&gt;</SPAN>.</P><DIV class="lecture_mark" id="mark_46"></DIV><P id="id_48">Такая пара получила название socket (гнездо, панель), так как по сути дела является виртуальным коммуникационным узлом (можно представить себе виртуальный разъем или ящик для приема/отправки писем), ведущим от объекта во внешний мир и наоборот. При непрямой адресации сами промежуточные объекты для организации взаимодействия процессов также именуются <SPAN class="keyword">сокетами</SPAN>.</P><DIV class="lecture_mark" id="mark_48"></DIV><P id="id_49">Поскольку <SPAN class="keyword">уровень Internet</SPAN> <SPAN class="keyword">семейства протоколов TCP/IP</SPAN> умеет доставлять информацию только от компьютера к компьютеру, данные, полученные с его помощью, должны содержать тип использованного протокола <SPAN class="keyword">транспортного уровня</SPAN> и локальные адреса отправителя и получателя. И протокол TCP, и <SPAN class="keyword">протокол UDP</SPAN> используют непрямую адресацию.</P><DIV class="lecture_mark" id="mark_49"></DIV><P id="id_50">Для того чтобы избежать путаницы, мы в дальнейшем термин "<SPAN class="keyword">сокет</SPAN>" будем употреблять только для обозначения самих промежуточных объектов, а полные адреса таких объектов будем называть <SPAN class="keyword">адресами сокетов</SPAN>. </P><DIV class="lecture_mark" id="mark_50"></DIV><P id="id_51"><A name="keyword-context.9"></A>Для каждого транспортного протокола в стеке TCP/IP существуют собственные <SPAN class="keyword">сокеты</SPAN>: <SPAN class="keyword">UDP сокеты</SPAN> и <SPAN class="keyword">TCP сокеты</SPAN>, имеющие различные адресные пространства своих локальных адресов – <SPAN class="keyword_def">портов</SPAN>. В <SPAN class="keyword">семействе протоколов TCP/IP</SPAN> адресные пространства <SPAN class="keyword">портов</SPAN> представляют собой положительные значения целого 16-битового числа. Поэтому, говоря о локальном <SPAN class="keyword">адресе сокета</SPAN>, мы часто будем использовать термин <B>"номер</B> <SPAN class="keyword">порта</SPAN><B>"</B>. Из различия адресных пространств <SPAN class="keyword">портов</SPAN> следует, что <SPAN class="keyword">порт</SPAN> 1111 TCP – это совсем не тот же самый локальный адрес, что и <SPAN class="keyword">порт</SPAN> 1111 UDP. О том, как назначаются номера <SPAN class="keyword">портов</SPAN>

 различным <SPAN class="keyword">сокетам</SPAN>, мы поговорим позже.</P><DIV class="lecture_mark" id="mark_51"></DIV><P id="id_52">Итак, мы описали иерархическую систему адресации, используемую в <SPAN class="keyword">семействе протоколов TCP/IP</SPAN>, которая включает в себя несколько уровней:</P><DIV class="lecture_mark" id="mark_52"></DIV><UL id="id_53"><LI>Физический пакет данных, передаваемый по сети, содержит физические адреса узлов сети (<SPAN class="keyword">MAC-адреса</SPAN>) с указанием на то, какой протокол <SPAN class="keyword">уровня Internet</SPAN> должен использоваться для обработки передаваемых данных (поскольку пользователя интересуют только данные, доставляемые затем на <SPAN class="keyword">уровень приложений/процессов</SPAN>, то для него это всегда IP). </LI><LI>IP-пакет данных содержит 32-битовые <SPAN class="keyword">IP-адреса</SPAN> компьютера-отправителя и компьютера-получателя, и указание на то, какой вышележащий протокол (TCP, <SPAN class="keyword">UDP</SPAN> или еще что-нибудь) должен использоваться для их дальнейшей обработки. </LI><LI>Служебная информация транспортных протоколов (UDP-заголовок к данным и TCP-заголовок к данным) должна содержать 16-битовые номера <SPAN class="keyword">портов</SPAN> для <SPAN class="keyword">сокета</SPAN> отправителя и сокета получателя. </LI></UL><DIV class="lecture_mark" id="mark_53"></DIV><P id="id_57"><A name="keyword-context.10"></A>Добавление необходимой информации к данным при переходе от верхних уровней семейства протоколов к нижним принято называть английским словом <SPAN class="keyword_def">encapsulation</SPAN> (дословно: герметизация). На <A href="http://www.intuit.ru/department/os/osintropractice/10/osintropractice_10.html#image.15-16.5">рисунке 15–16.5</A> приведена схема <SPAN class="keyword">encapsulation</SPAN> при использовании <SPAN class="keyword">протокола UDP</SPAN> на сети Ethernet.</P><DIV class="lecture_mark" id="mark_57"></DIV><P align="left" id="id_58"><A name="image.15-16.5"></A></P><DIV><IMG src="./10. Семейство протоколов TCP-IP. Сокеты (sockets) в UNIX и основы работы с ними_files/15-16-5.gif" alt="Encapsulation для UDP-протокола на сети Ethernet" width="447" height="310"></DIV><BR><B>Рис. 15-16.5.</B>&nbsp;
        Encapsulation для UDP-протокола на сети Ethernet<P></P><DIV class="lecture_mark" id="mark_58"></DIV><P id="id_59">Поскольку между <SPAN class="keyword">MAC-адресами</SPAN> и <SPAN class="keyword">IP-адресами</SPAN> существует взаимно однозначное соответствие, известное <SPAN class="keyword">семейству протоколов TCP/IP</SPAN>, то фактически для полного задания адреса доставки и адреса отправления, необходимых для установления двусторонней связи, нужно указать пять параметров:</P><DIV class="lecture_mark" id="mark_59"></DIV><P id="id_60"><SPAN class="texample">&lt;транспортный протокол, <SPAN class="keyword">IP-адрес</SPAN> отправителя, <SPAN class="keyword">порт</SPAN> отправителя, <SPAN class="keyword">IP-адрес</SPAN> получателя, <SPAN class="keyword">порт</SPAN> получателя&gt;</SPAN></P><DIV class="lecture_mark" id="mark_60"></DIV><A name="sect6"></A><H3>Уровень приложений/процессов </H3><P id="id_62">К этому уровню можно отнести протоколы TFTP (Trivial File Transfer Protocol), FTP (File Transfer Protocol), telnet, SMTP (Simple Mail Transfer Protocol) и другие, которые поддерживаются соответствующими системными утилитами. Об их использовании подробно рассказано в UNIX Manual, и останавливаться на них мы не будем.</P><DIV class="lecture_mark" id="mark_62"></DIV><P id="id_63">Нас будет интересовать в дальнейшем программный интерфейс между <SPAN class="keyword">уровнем приложений/процессов</SPAN> и <SPAN class="keyword">транспортным уровнем</SPAN> для того, чтобы мы могли создавать собственные процессы, общающиеся через сеть. Но прежде чем заняться программным интерфейсом, нам необходимо вспомнить особенности взаимодействия процессов в модели клиент-сервер.</P><DIV class="lecture_mark" id="mark_63"></DIV><A name="sect7"></A><H3>Использование модели клиент-сервер для взаимодействия удаленных процессов </H3><P id="id_64">В материалах семинара 9 при обсуждении мультиплексирования сообщений (раздел "Понятие мультиплексирования. Мультиплексирование сообщений. Модель взаимодействия процессов клиент-сервер. Неравноправность клиента и сервера") говорилось об использовании модели клиент-сервер для организации взаимодействия локальных процессов. Эта же модель, изначально предполагающая неравноправность взаимодействующих процессов, наиболее часто используется для организации сетевых приложений. Напомним основные отличия процессов клиента и сервера применительно к удаленному взаимодействию:</P><DIV class="lecture_mark" id="mark_64"></DIV><UL id="id_65"><LI>Сервер, как правило, работает постоянно, на всем протяжении жизни приложения, а клиенты могут работать эпизодически. </LI><LI>Сервер ждет запроса от клиентов, инициатором же взаимодействия выступает клиент. </LI><LI>Как правило, клиент обращается к одному серверу за раз, в то время как к серверу могут одновременно поступить запросы от нескольких клиентов. </LI><LI>Клиент должен знать полный адрес сервера (его локальную и удаленную части) перед началом организации запроса (до начала общения), в то время как сервер может получить информацию о полном адресе клиента из пришедшего запроса (после начала общения).</LI><LI>И клиент, и сервер должны использовать один и тот же протокол <SPAN class="keyword">транспортного уровня</SPAN>.</LI></UL><DIV class="lecture_mark" id="mark_65"></DIV><P id="id_71">Неравноправность процессов в модели клиент-сервер, как мы увидим далее, накладывает свой отпечаток на программный интерфейс, используемый между <SPAN class="keyword">уровнем приложений/процессов</SPAN> и <SPAN class="keyword">транспортным уровнем</SPAN>. </P><DIV class="lecture_mark" id="mark_71"></DIV><P id="id_72">Поступающие запросы сервер может обрабатывать последовательно – запрос за запросом – или параллельно, запуская для обработки каждого из них свой процесс или thread. Как правило, серверы, ориентированные на связь клиент-сервер с помощью установки <SPAN class="keyword">логического соединения</SPAN> (TCP-протокол), ведут обработку запросов параллельно, а серверы, ориентированные на связь клиент-сервер без установления соединения (UDP-протокол), обрабатывают запросы последовательно. </P><DIV class="lecture_mark" id="mark_72"></DIV><P id="id_73">Рассмотрим основные действия, которые нам необходимы в терминах абстракции socket для того, чтобы организовать взаимодействие между клиентом и сервером, используя транспортные протоколы стека TCP/IP. </P><DIV class="lecture_mark" id="mark_73"></DIV><A name="sect8"></A><H3>Организация связи между удаленными процессами с помощью датаграмм </H3><P id="id_74">Как уже упоминалось в лекциях, более простой для взаимодействия удаленных процессов является схема организации общения клиента и сервера с помощью <SPAN class="keyword">датаграмм</SPAN>, т. е. использование <SPAN class="keyword">протокола UDP</SPAN>. </P><DIV class="lecture_mark" id="mark_74"></DIV><P id="id_75">Рассмотрение этой схемы мы начнем с некоторой житейской аналогии, а затем убедимся, что каждому житейски обоснованному действию в операционной системе UNIX соответствует определенный системный вызов.</P><DIV class="lecture_mark" id="mark_75"></DIV><P id="id_76">С точки зрения обычного человека общение процессов посредством <SPAN class="keyword">датаграмм</SPAN> напоминает общение людей в письмах. Каждое письмо представляет собой законченное сообщение, содержащее адрес получателя, адрес отправителя и указания, кто написал письмо и кто должен его получить. Письма могут теряться, доставляться в неправильном порядке, быть поврежденными в дороге и т.д.</P><DIV class="lecture_mark" id="mark_76"></DIV><P id="id_77">Что в первую очередь должен сделать человек, проживающий в отдаленной местности, для того чтобы принимать и отправлять письма? Он должен изготовить почтовый ящик, который одновременно будет служить и для приема корреспонденции, и для ее отправки. Пришедшие письма почтальон будет помещать в этот ящик и забирать из него письма, подготовленные к отправке. </P><DIV class="lecture_mark" id="mark_77"></DIV><P id="id_78">Изготовленный почтовый ящик нужно где-то прикрепить. Это может быть парадная дверь дома или вход со двора, изгородь, столб, дерево и т.п. Потенциально может быть изготовлено несколько почтовых ящиков и размещено в разных местах с тем, чтобы письма от различных адресатов прибывали в различные ящики. Этим ящикам будут соответствовать разные адреса: "г. Иванову, почтовый ящик на конюшне", "г. Иванову, почтовый ящик, что на дубе". </P><DIV class="lecture_mark" id="mark_78"></DIV><P id="id_79">После закрепления ящика мы готовы к обмену корреспонденцией. Человек-клиент пишет письмо с запросом по заранее известному ему адресу человека-сервера и ждет получения ответного письма. После получения ответа он читает его и перерабатывает полученную информацию.</P><DIV class="lecture_mark" id="mark_79"></DIV><P id="id_80">Человек-сервер изначально находится в состоянии ожидания запроса. Получив письмо, он читает текст запроса и определяет адрес отправителя. После обработки запроса он пишет ответ и отправляет его по обратному адресу, после чего начинает ждать следующего запроса.</P><DIV class="lecture_mark" id="mark_80"></DIV><P id="id_81">Все эти модельные действия имеют аналоги при общении удаленных процессов по <SPAN class="keyword">протоколу UDP</SPAN>. </P><DIV class="lecture_mark" id="mark_81"></DIV><P id="id_82">Процесс-сервер должен сначала совершить подготовительные действия: создать <SPAN class="keyword">UDP-сокет</SPAN> (изготовить почтовый ящик) и связать его с определенным номером <SPAN class="keyword">порта</SPAN> и <SPAN class="keyword">IP-адресом</SPAN> сетевого интерфейса (прикрепить почтовый ящик в определенном месте) – настроить <SPAN class="keyword">адрес сокета</SPAN>. При этом сокет может быть привязан к конкретному сетевому интерфейсу (к конюшне, к дубу) или к компьютеру в целом, то есть в полном <SPAN class="keyword">адресе сокета</SPAN> может быть либо указан <SPAN class="keyword">IP-адрес</SPAN> конкретного сетевого интерфейса, либо дано указание операционной системе, что информация может поступить через любой сетевой интерфейс, имеющийся в наличии. После настройки <SPAN class="keyword">адреса сокета</SPAN> операционная система начинает принимать сообщения, пришедшие на этот адрес и складывать их в <SPAN class="keyword">сокет</SPAN>. Сервер 
дожидается поступления сообщения, читает его, определяет, от кого оно поступило и через какой сетевой интерфейс, обрабатывает полученную информацию и отправляет результат по обратному адресу. После чего процесс готов к приему новой информации от того же или другого клиента.</P><DIV class="lecture_mark" id="mark_82"></DIV><P id="id_83">Процесс-клиент должен сначала совершить те же самые подготовительные действия: создать <SPAN class="keyword">сокет</SPAN> и настроить его адрес. Затем он передает сообщение, указав, кому оно предназначено (<SPAN class="keyword">IP-адрес</SPAN> сетевого интерфейса и номер <SPAN class="keyword">порта</SPAN> сервера), ожидает от него ответа и продолжает свою деятельность.</P><DIV class="lecture_mark" id="mark_83"></DIV><P id="id_84">Схематично эти действия выглядят так, как показано на <A href="http://www.intuit.ru/department/os/osintropractice/10/5.html#image.15-16.6">рисунке 15–16.6</A>. Каждому из них соответствует определенный системный вызов. Названия вызовов написаны справа от блоков соответствующих действий.</P><DIV class="lecture_mark" id="mark_84"></DIV><P id="id_85"><A name="keyword-context.11"></A>Создание <SPAN class="keyword">сокета</SPAN> производится с помощью системного вызова <SPAN class="texample"><SPAN class="keyword_def">socket()</SPAN></SPAN>. <A name="keyword-context.12"></A>Для привязки созданного <SPAN class="keyword">сокета</SPAN> к <SPAN class="keyword">IP-адресу</SPAN> и номеру <SPAN class="keyword">порта</SPAN> (настройка адреса) служит системный вызов <SPAN class="texample"><SPAN class="keyword_def">bind()</SPAN></SPAN>. <A name="keyword-context.13"></A>Ожиданию получения информации, ее чтению и, при необходимости, определению адреса отправителя соответствует системный вызов <SPAN class="texample"><SPAN class="keyword_def">recvfrom()</SPAN></SPAN>. <A name="keyword-context.14"></A>За отправку <SPAN class="keyword">датаграммы</SPAN> отвечает системный вызов <SPAN class="texample"><SPAN class="keyword_def">sendto()</SPAN></SPAN>. </P><DIV class="lecture_mark" id="mark_85"></DIV><P id="id_90">Прежде чем приступить к подробному рассмотрению этих системных вызовов и примеров программ нам придется остановиться на нескольких вспомогательных функциях, которые мы должны будем использовать при программировании.</P><DIV class="lecture_mark" id="mark_90"></DIV><A name="sect9"></A><H3>Сетевой порядок байт. Функции htons(), htonl(), ntohs(), ntohl() </H3><P id="id_91">Передача от одного вычислительного комплекса к другому символьной информации, как правило (когда один символ занимает один байт), не вызывает проблем. Однако для числовой информации ситуация усложняется.</P><DIV class="lecture_mark" id="mark_91"></DIV><P align="left" id="id_92"><A name="image.15-16.6"></A></P><DIV><IMG src="./10. Семейство протоколов TCP-IP. Сокеты (sockets) в UNIX и основы работы с ними_files/15-16-6.gif" alt="Схема взаимодействия клиента и сервера для протокола UDP" width="447" height="373"></DIV><BR><B>Рис. 15-16.6.</B>&nbsp;
        Схема взаимодействия клиента и сервера для протокола UDP<P></P><DIV class="lecture_mark" id="mark_92"></DIV><P id="id_93">Как известно, порядок байт в целых числах, представление которых занимает более одного байта, может быть для различных компьютеров неодинаковым. Есть вычислительные системы, в которых старший байт числа имеет меньший адрес, чем младший байт (big-endian byte order), а есть вычислительные системы, в которых старший байт числа имеет больший адрес, чем младший байт (little-endian byte order). При передаче целой числовой информации от машины, имеющей один порядок байт, к машине с другим порядком байт мы можем неправильно истолковать принятую информацию. Для того чтобы этого не произошло, было введено понятие сетевого порядка байт, т.е. порядка байт, в котором должна представляться целая числовая информация в процессе передачи ее по сети (на самом деле – это big-endian byte order). Целые числовые данные из представления, принятого на компьютере-отправителе, переводятся пользовательским процессом в сетевой порядок байт, в таком виде путешествуют по сети и переводятся в нужный порядок байт на машине-получателе 
процессом, которому они предназначены. Для перевода целых чисел из машинного представления в сетевое и обратно используется четыре функции: <SPAN class="texample"><SPAN class="keyword">htons()</SPAN></SPAN>, <SPAN class="texample"><SPAN class="keyword">htonl()</SPAN></SPAN>, <SPAN class="texample"><SPAN class="keyword">ntohs()</SPAN></SPAN>, <SPAN class="texample"><SPAN class="keyword">ntohl()</SPAN></SPAN>.</P><DIV class="lecture_mark" id="mark_93"></DIV><DIV class="xml_table_env" id="id_98"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_99"><B>Функции преобразования порядка байт</B></P><DIV class="lecture_mark" id="mark_99"></DIV>

<P id="id_100"><B>Прототипы функций</B></P><DIV class="lecture_mark" id="mark_100"></DIV>

<DIV class="example"><PRE>#include &lt;netinet/in.h&gt;
unsigned long int htonl(
    unsigned long int hostlong);
unsigned short int htons(
    unsigned short int hostshort);
unsigned long int ntohl(
    unsigned long int netlong);
unsigned short int ntohs(
    unsigned short int netshort);
</PRE></DIV>

<P id="id_102"><B>Описание функций</B></P><DIV class="lecture_mark" id="mark_102"></DIV>

<P id="id_103"><A name="keyword-context.15"></A>Функция <SPAN class="texample"><SPAN class="keyword_def">htonl</SPAN></SPAN> осуществляет перевод целого длинного числа из порядка байт, принятого на компьютере, в сетевой порядок байт. </P><DIV class="lecture_mark" id="mark_103"></DIV>

<P id="id_105"><A name="keyword-context.16"></A>Функция <SPAN class="texample"><SPAN class="keyword_def">htons</SPAN></SPAN> осуществляет перевод целого короткого числа из порядка байт, принятого на компьютере, в сетевой порядок байт. </P><DIV class="lecture_mark" id="mark_105"></DIV>

<P id="id_107"><A name="keyword-context.17"></A>Функция <SPAN class="texample"><SPAN class="keyword_def">ntohl</SPAN></SPAN> осуществляет перевод целого длинного числа из сетевого порядка байт в порядок байт, принятый на компьютере. </P><DIV class="lecture_mark" id="mark_107"></DIV>

<P id="id_109"><A name="keyword-context.18"></A>Функция <SPAN class="texample"><SPAN class="keyword_def">ntohs</SPAN></SPAN> осуществляет перевод целого короткого числа из сетевого порядка байт в порядок байт, принятый на компьютере. </P><DIV class="lecture_mark" id="mark_109"></DIV>

<P id="id_111">В архитектуре компьютеров i80x86 принят порядок байт, при котором младшие байты целого числа имеют младшие адреса. При сетевом порядке байт, принятом в Internet, младшие адреса имеют старшие байты числа.</P><DIV class="lecture_mark" id="mark_111"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_98"></DIV><P id="id_112">Параметр у них – значение, которое мы собираемся конвертировать. Возвращаемое значение – то, что получается в результате конвертации. Направление конвертации определяется порядком букв h (host) и n (network) в названии функции, размер числа – последней буквой названия, то есть <SPAN class="texample">htons</SPAN> – это host to network short, <SPAN class="texample"><SPAN class="keyword">ntohl</SPAN></SPAN> – network to host long.</P><DIV class="lecture_mark" id="mark_112"></DIV><P id="id_115">Для чисел с плавающей точкой все обстоит гораздо хуже. На разных машинах могут различаться не только порядок байт, но и форма представления такого числа. Простых функций для их корректной передачи по сети не существует. Если требуется обмениваться действительными данными, то либо это нужно делать на гомогенной сети, состоящей из одинаковых компьютеров, либо использовать символьные и целые данные для передачи действительных значений. </P><DIV class="lecture_mark" id="mark_115"></DIV><A name="sect10"></A><H3>Функции преобразования IP-адресов inet_ntoa(), inet_aton() </H3><P id="id_116">Нам также понадобятся функции, осуществляющие перевод <SPAN class="keyword">IP-адресов</SPAN> из символьного представления (в виде четверки чисел, разделенных точками) в числовое представление и обратно. <A name="keyword-context.19"></A>Функция <SPAN class="texample"><SPAN class="keyword_def">inet_aton()</SPAN></SPAN> переводит символьный <SPAN class="keyword">IP-адрес</SPAN> в числовое представление в сетевом порядке байт. </P><DIV class="lecture_mark" id="mark_116"></DIV><P id="id_118">Функция возвращает 1, если в символьном виде записан правильный <SPAN class="keyword">IP-адрес</SPAN>, и 0 в противном случае – <B>для большинства системных вызовов и функций это нетипичная ситуация. Обратите внимание на использование указателя на структуру</B> <SPAN class="texample">struct in_addr</SPAN> <B>в качестве одного из параметров данной функции. Эта структура используется для хранения</B> <SPAN class="keyword">IP-адресов</SPAN> <B>в сетевом порядке байт. То, что используется структура, состоящая из одной переменной, а не сама 32-битовая переменная, сложилось исторически, и авторы в этом не виноваты.</B></P><DIV class="lecture_mark" id="mark_118"></DIV><P id="id_120">Для обратного преобразования применяется функция <SPAN class="texample"><SPAN class="keyword">inet_ntoa()</SPAN></SPAN>.</P><DIV class="lecture_mark" id="mark_120"></DIV><DIV class="xml_table_env" id="id_122"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_123"><B>Функции преобразования IP-адресов</B></P><DIV class="lecture_mark" id="mark_123"></DIV>

<P id="id_124"><B>Прототипы функций</B></P><DIV class="lecture_mark" id="mark_124"></DIV>

<DIV class="example"><PRE>#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;
int inet_aton(const char *strptr, 
    struct in_addr *addrptr);
char *inet_ntoa(struct in_addr *addrptr);
</PRE></DIV>

<P id="id_126"><B>Описание функций</B></P><DIV class="lecture_mark" id="mark_126"></DIV>

<P id="id_127">Функция <SPAN class="texample"><SPAN class="keyword">inet_aton</SPAN></SPAN> переводит символьный <SPAN class="keyword">IP-адрес</SPAN>, расположенный по указателю <SPAN class="texample">strptr</SPAN>, в числовое представление в сетевом порядке байт и заносит его в структуру, расположенную по адресу <SPAN class="texample">addrptr</SPAN>. Функция возвращает значение <SPAN class="texample">1</SPAN>, если в строке записан правильный <SPAN class="keyword">IP-адрес</SPAN>, и значение <SPAN class="texample">0</SPAN> в противном случае. Структура типа <SPAN class="texample">struct in_addr</SPAN> используется для хранения <SPAN class="keyword">IP-адресов</SPAN> в сетевом порядке байт и выглядит так:</P><DIV class="lecture_mark" id="mark_127"></DIV>

<DIV class="example"><PRE>struct in_addr {
    in_addr_t s_addr; 
}; 
</PRE></DIV>

<P id="id_135">То, что используется адрес такой структуры, а не просто адрес переменной типа <SPAN class="texample">in_addr_t</SPAN>, сложилось исторически. </P><DIV class="lecture_mark" id="mark_135"></DIV>

<P id="id_137">Функция <SPAN class="texample"><SPAN class="keyword">inet_ntoa</SPAN></SPAN> применяется для обратного преобразования. Числовое представление адреса в сетевом порядке байт должно быть занесено в структуру типа <SPAN class="texample">struct in_addr</SPAN>, адрес которой <SPAN class="texample">addrptr</SPAN> передается функции как аргумент. Функция возвращает указатель на строку, содержащую символьное представление адреса. Эта строка располагается в статическом буфере, при последующих вызовах ее новое содержимое заменяет старое содержимое.</P><DIV class="lecture_mark" id="mark_137"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_122"></DIV><A name="sect11"></A><H3>Функция bzero()</H3><P id="id_141">Функция 2 настолько проста, что про нее нечего рассказывать. Все видно из описания.</P><DIV class="lecture_mark" id="mark_141"></DIV><DIV class="xml_table_env" id="id_142"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_143"><B>Функция bzero</B></P><DIV class="lecture_mark" id="mark_143"></DIV>

<P id="id_144"><B>Прототип функции</B></P><DIV class="lecture_mark" id="mark_144"></DIV>

<DIV class="example"><PRE>#include &lt;string.h&gt;
void bzero(void *addr, int n);
</PRE></DIV>

<P id="id_146"><B>Описание функции</B></P><DIV class="lecture_mark" id="mark_146"></DIV>

<P id="id_147"><A name="keyword-context.20"></A>Функция <SPAN class="texample"><SPAN class="keyword_def">bzero</SPAN></SPAN> заполняет первые n байт, начиная с адреса <SPAN class="texample">addr</SPAN>, нулевыми значениями. Функция ничего не возвращает. </P><DIV class="lecture_mark" id="mark_147"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_142"></DIV><P id="id_150">Теперь мы можем перейти к системным вызовам, образующим интерфейс между пользовательским уровнем стека протоколов TCP/IP и транспортным <SPAN class="keyword">протоколом UDP</SPAN>.</P><DIV class="lecture_mark" id="mark_150"></DIV><A name="sect12"></A><H3>Создание сокета. Системный вызов socket()</H3><P id="id_151">Для создания <SPAN class="keyword">сокета</SPAN> в операционной системе служит системный вызов <SPAN class="texample"><SPAN class="keyword">socket()</SPAN></SPAN>. Для транспортных протоколов <SPAN class="keyword">семейства TCP/IP</SPAN> существует два вида <SPAN class="keyword">сокетов</SPAN>: <SPAN class="keyword">UDP-сокет</SPAN> – <SPAN class="keyword">сокет</SPAN> для работы с <SPAN class="keyword">датаграммами</SPAN>, и TCP сокет – потоковый <SPAN class="keyword">сокет</SPAN>. Однако понятие <SPAN class="keyword">сокета</SPAN> (см. лекцию 14, раздел "Полные адреса. Понятие <SPAN class="keyword">сокета</SPAN> (socket)") не ограничивается рамками только этого семейства протоколов. Рассматриваемый интерфейс сетевых системных вызовов (<SPAN class="texample"><SPAN class="keyword">socket()</SPAN></SPAN>, <SPAN class="texample"><SPAN class="keyword">bind()</SPAN></SPAN>, <SPAN class="texample"><SPAN class="keyword">recvfrom()
</SPAN></SPAN>, <SPAN class="texample"><SPAN class="keyword">sendto()</SPAN></SPAN> и т. д.) в операционной системе UNIX может применяться и для других стеков протоколов (и для протоколов, лежащих ниже <SPAN class="keyword">транспортного уровня</SPAN>). </P><DIV class="lecture_mark" id="mark_151"></DIV><P id="id_157">При создании <SPAN class="keyword">сокета</SPAN> необходимо точно специфицировать его тип. Эта спецификация производится с помощью трех параметров вызова <SPAN class="texample"><SPAN class="keyword">socket()</SPAN></SPAN>. Первый параметр указывает, к какому семейству протоколов относится создаваемый <SPAN class="keyword">сокет</SPAN>, а второй и третий параметры определяют конкретный протокол внутри данного семейства.</P><DIV class="lecture_mark" id="mark_157"></DIV><P id="id_159">Второй параметр служит для задания вида интерфейса работы с <SPAN class="keyword">сокетом</SPAN> – будет это потоковый <SPAN class="keyword">сокет</SPAN>, <SPAN class="keyword">сокет</SPAN> для работы с <SPAN class="keyword">датаграммами</SPAN> или какой-либо иной. Третий параметр указывает протокол для заданного типа интерфейса. В <SPAN class="keyword">стеке протоколов TCP/IP</SPAN> существует только один протокол для потоковых <SPAN class="keyword">сокетов</SPAN> – TCP и только один протокол для датаграммных <SPAN class="keyword">сокетов</SPAN> – UDP, поэтому для транспортных <SPAN class="keyword">протоколов TCP/IP</SPAN> третий параметр игнорируется.</P><DIV class="lecture_mark" id="mark_159"></DIV><P id="id_160">В других стеках протоколов может быть несколько протоколов с одинаковым видом интерфейса, например, датаграммных, различающихся по степени надежности.</P><DIV class="lecture_mark" id="mark_160"></DIV><P id="id_161">Для транспортных <SPAN class="keyword">протоколов TCP/IP</SPAN> мы всегда в качестве первого параметра будем указывать предопределенную константу <SPAN class="texample">AF_INET</SPAN> (Address family – Internet) или ее синоним <SPAN class="texample">PF_INET</SPAN> (Protocol family – Internet).</P><DIV class="lecture_mark" id="mark_161"></DIV><P id="id_164">Второй параметр будет принимать предопределенные значения <SPAN class="texample">SOCK_STREAM</SPAN> для потоковых <SPAN class="keyword">сокетов</SPAN> и <SPAN class="texample">SOCK_DGRAM</SPAN> – для датаграммных. </P><DIV class="lecture_mark" id="mark_164"></DIV><P id="id_167">Поскольку третий параметр в нашем случае не учитывается, в него мы будем подставлять значение <SPAN class="texample">0</SPAN>.</P><DIV class="lecture_mark" id="mark_167"></DIV><P id="id_169">Ссылка на информацию о созданном <SPAN class="keyword">сокете</SPAN> помещается в таблицу открытых файлов процесса подобно тому, как это делалось для pip’ов и FIFO (см. семинар 5). Системный вызов возвращает пользователю файловый дескриптор, соответствующий заполненному элементу таблицы, который далее мы будем называть дескриптором <SPAN class="keyword">сокета</SPAN>. Такой способ хранения информации о <SPAN class="keyword">сокете</SPAN> позволяет, во-первых, процессам-детям наследовать ее от процессов-родителей, а, во-вторых, использовать для <SPAN class="keyword">сокетов</SPAN> часть системных вызовов, которые уже знакомы нам по работе с pip’ами и FIFO: <SPAN class="texample">close()</SPAN>, <SPAN class="texample">read()</SPAN>, <SPAN class="texample">write()</SPAN>.</P><DIV class="lecture_mark" id="mark_169"></DIV><DIV class="xml_table_env" id="id_173"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_174"><B>Системный вызов для создания сокета</B></P><DIV class="lecture_mark" id="mark_174"></DIV>

<P id="id_175"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_175"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt; 
int socket(int domain, int type, 
           int protocol);
</PRE></DIV>

<P id="id_177"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_177"></DIV>

<P id="id_178">Системный вызов <SPAN class="texample"><SPAN class="keyword">socket</SPAN></SPAN> служит для создания виртуального коммуникационного узла в операционной системе. Данное описание не является полным описанием системного вызова, а предназначено только для использования в нашем курсе. За полной информацией обращайтесь к UNIX Manual.</P><DIV class="lecture_mark" id="mark_178"></DIV>

<P id="id_180">Параметр <SPAN class="texample">domain</SPAN> определяет семейство протоколов, в рамках которого будет осуществляться передача информации. Мы рассмотрим только два таких семейства из нескольких существующих. Для них имеются предопределенные значения параметра:</P><DIV class="lecture_mark" id="mark_180"></DIV>

<UL id="id_182"><LI><SPAN class="texample">PF_INET</SPAN>     – для <SPAN class="keyword">семейства протоколов TCP/IP</SPAN>;</LI><LI><SPAN class="texample">PF_UNIX</SPAN>     – для семейства внутренних протоколов UNIX, иначе называемого еще UNIX domain.</LI></UL><DIV class="lecture_mark" id="mark_182"></DIV>

<P id="id_187">Параметр <SPAN class="texample">type</SPAN> определяет семантику обмена информацией: будет ли осуществляться связь через сообщения (datagrams), с помощью установления <SPAN class="keyword">виртуального соединения</SPAN> или еще каким-либо способом. Мы будем пользоваться только двумя способами обмена информацией с предопределенными значениями для параметра <SPAN class="texample">type</SPAN>:</P><DIV class="lecture_mark" id="mark_187"></DIV>

<UL id="id_190"><LI><SPAN class="texample">SOCK_STREAM</SPAN>     – для связи с помощью установления <SPAN class="keyword">виртуального соединения</SPAN>;</LI><LI><SPAN class="texample">SOCK_DGRAM</SPAN>     – для обмена информацией через сообщения.</LI></UL><DIV class="lecture_mark" id="mark_190"></DIV>

<P id="id_195">Параметр <SPAN class="texample">protocol</SPAN> специфицирует конкретный протокол для выбранного семейства протоколов и способа обмена информацией. Он имеет значение только в том случае, когда таких протоколов существует несколько. В нашем случае семейство протоколов и тип обмена информацией определяют протокол однозначно. Поэтому данный параметр мы будем полагать равным <SPAN class="texample">0</SPAN>.</P><DIV class="lecture_mark" id="mark_195"></DIV>

<P id="id_198"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_198"></DIV>

<P id="id_199">В случае успешного завершения системный вызов возвращает файловый дескриптор (значение большее или равное <SPAN class="texample">0</SPAN>), который будет использоваться как ссылка на созданный коммуникационный узел при всех дальнейших сетевых вызовах. При возникновении какой-либо ошибки возвращается отрицательное значение. </P><DIV class="lecture_mark" id="mark_199"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_173"></DIV><A name="sect13"></A><H3>Адреса сокетов. Настройка адреса сокета. Системный вызов bind()</H3><P id="id_201">Когда <SPAN class="keyword">сокет</SPAN> создан, необходимо настроить его адрес. Для этого используется системный вызов <SPAN class="texample"><SPAN class="keyword">bind()</SPAN></SPAN>. Первый параметр вызова должен содержать дескриптор <SPAN class="keyword">сокета</SPAN>, для которого производится настройка адреса. Второй и третий параметры задают этот адрес.</P><DIV class="lecture_mark" id="mark_201"></DIV><P id="id_203">Во втором параметре должен быть указатель на структуру <SPAN class="texample">struct sockaddr</SPAN>, содержащую удаленную и локальные части полного адреса.</P><DIV class="lecture_mark" id="mark_203"></DIV><P id="id_205">Указатели типа <SPAN class="texample">struct sockaddr</SPAN> * встречаются во многих сетевых системных вызовах; они используются для передачи информации о том, к какому адресу привязан или должен быть привязан <SPAN class="keyword">сокет</SPAN>. Рассмотрим этот тип данных подробнее. Структура <SPAN class="texample">struct sockaddr</SPAN> описана в файле <SPAN class="texample">&lt;sys/socket.h&gt;</SPAN> следующим образом:</P><DIV class="lecture_mark" id="mark_205"></DIV><DIV class="example"><PRE>struct sockaddr {
    short sa_family;
    char sa_data[14];
};
</PRE></DIV><P id="id_210">Такой состав структуры обусловлен тем, что сетевые системные вызовы могут применяться для различных семейств протоколов, которые по-разному определяют адресные пространства для удаленных и локальных <SPAN class="keyword">адресов сокета</SPAN>. По сути дела, этот тип данных представляет собой лишь общий шаблон для передачи системным вызовам структур данных, специфических для каждого семейства протоколов. Общим элементом этих структур остается только поле <SPAN class="texample">short sa_family</SPAN> (которое в разных структурах, естественно, может иметь разные имена, важно лишь, чтобы все они были одного типа и были первыми элементами своих структур) для описания семейства протоколов. Содержимое этого поля системный вызов анализирует для точного определения состава поступившей информации.</P><DIV class="lecture_mark" id="mark_210"></DIV><P id="id_212">Для работы с <SPAN class="keyword">семейством протоколов TCP/IP</SPAN> мы будем использовать <SPAN class="keyword">адрес сокета</SPAN> следующего вида, описанного в файле <SPAN class="texample">&lt;netinet/in.h&gt;</SPAN>:</P><DIV class="lecture_mark" id="mark_212"></DIV><DIV class="example"><PRE>struct sockaddr _in{
    short sin_family; 
    /* Избранное семейство протоколов 
       – всегда AF_INET */
    unsigned short sin_port; 
    /* 16-битовый номер порта в сетевом 
       порядке байт */
    struct in_addr sin_addr; 
    /* Адрес сетевого интерфейса */
    char sin_zero[8]; 
    /* Это поле не используется, но должно
       всегда быть заполнено нулями */
};
</PRE></DIV><P id="id_215">Первый элемент структуры – <SPAN class="texample">sin_family</SPAN> задает семейство протоколов. В него мы будем заносить уже известную нам предопределенную константу <SPAN class="texample">AF_INET</SPAN> (см. предыдущий раздел).</P><DIV class="lecture_mark" id="mark_215"></DIV><P id="id_218">Удаленная часть полного адреса – <SPAN class="keyword">IP-адрес</SPAN> – содержится в структуре типа <SPAN class="texample">struct in_addr</SPAN>, с которой мы встречались в разделе "Функции преобразования <SPAN class="keyword">IP-адресов</SPAN> <SPAN class="texample"><SPAN class="keyword">inet_ntoa()</SPAN></SPAN>, <SPAN class="texample"><SPAN class="keyword">inet_aton()</SPAN></SPAN>" .</P><DIV class="lecture_mark" id="mark_218"></DIV><P id="id_222">Для указания номера <SPAN class="keyword">порта</SPAN> предназначен элемент структуры <SPAN class="texample">sin_port</SPAN>, в котором номер <SPAN class="keyword">порта</SPAN> должен храниться <B>в сетевом порядке байт</B>. Существует два варианта задания номера <SPAN class="keyword">порта</SPAN>: фиксированный <SPAN class="keyword">порт</SPAN> по желанию пользователя и <SPAN class="keyword">порт</SPAN>, который произвольно назначает операционная система. Первый вариант требует указания в качестве номера <SPAN class="keyword">порта</SPAN> положительного заранее известного числа и для <SPAN class="keyword">протокола UDP</SPAN> обычно используется при настройке <SPAN class="keyword">адресов сокетов</SPAN> и при передаче информации с помощью системного вызова <SPAN class="texample"><SPAN class="keyword">sendto()</SPAN></SPAN> (см. следующий раздел). Второй вариант требует указания в качестве номера <SPAN class="keyword">порта</SPAN> значения 0. В этом случае операционная система сама 

привязывает <SPAN class="keyword">сокет</SPAN> к свободному номеру <SPAN class="keyword">порта</SPAN>. Этот способ обычно используется при настройке <SPAN class="keyword">сокетов</SPAN> программ клиентов, когда заранее точно знать номер <SPAN class="keyword">порта</SPAN> для программисту необязательно. </P><DIV class="lecture_mark" id="mark_222"></DIV><P id="id_225">Какой номер <SPAN class="keyword">порта</SPAN> может задействовать пользователь при фиксированной настройке? Номера <SPAN class="keyword">портов</SPAN> с 1 по 1023 могут назначать <SPAN class="keyword">сокетам</SPAN> только процессы, работающие с привилегиями системного администратора. Как правило, эти номера закреплены за системными сетевыми службами независимо от вида используемой операционной системы, для того чтобы пользовательские клиентские программы могли запрашивать обслуживание всегда по одним и тем же локальным адресам. Существует также ряд широко применяемых сетевых программ, которые запускают процессы с полномочиями обычных пользователей (например, X-Windows). Для таких программ корпорацией Internet по присвоению имен и номеров (ICANN) выделяется диапазон адресов с 1024 по 49151, который нежелательно использовать во избежание возможных конфликтов. Номера <SPAN class="keyword">портов</SPAN> с 49152 по 65535 предназначены для процессов обычных пользователей. Во всех наших примерах при фиксированном задании номера <SPAN class="keyword">порта</SPAN> у сервера мы будем использовать номер 51000.</P><DIV class="lecture_mark" id="mark_225"></DIV><P id="id_226">IP–адрес при настройке также может быть определен двумя способами. Он может быть привязан к конкретному сетевому интерфейсу (т.е. сетевой плате), заставляя операционную систему принимать/передавать информацию только через этот сетевой интерфейс, а может быть привязан и ко всей вычислительной системе в целом (информация может быть получена/отослана через любой сетевой интерфейс). В первом случае в качестве значения поля структуры <SPAN class="texample">sin_addr.s_addr</SPAN> используется числовое значение <SPAN class="keyword">IP-адреса</SPAN> конкретного сетевого интерфейса в сетевом порядке байт. Во втором случае это значение должно быть равно значению предопределенной константы <SPAN class="texample">INADDR_ANY</SPAN>, приведенному к сетевому порядку байт.</P><DIV class="lecture_mark" id="mark_226"></DIV><P id="id_229">Третий параметр системного вызова <SPAN class="texample"><SPAN class="keyword">bind()</SPAN></SPAN> должен содержать фактическую длину структуры, адрес которой передается в качестве второго параметра. Эта длина меняется в зависимости от семейства протоколов и даже различается в пределах одного семейства протоколов. Размер структуры, содержащей <SPAN class="keyword">адрес сокета</SPAN>, для <SPAN class="keyword">семейства протоколов TCP/IP</SPAN> может быть определен как <SPAN class="texample">sizeof(struct sockaddr_in)</SPAN>.</P><DIV class="lecture_mark" id="mark_229"></DIV><DIV class="xml_table_env" id="id_232"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_233"><B>Системный вызов для привязки сокета к конкретному адресу</B></P><DIV class="lecture_mark" id="mark_233"></DIV>

<P id="id_234"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_234"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int bind(int sockd, 
         struct sockaddr *my_addr, 
         int addrlen);
</PRE></DIV>

<P id="id_236"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_236"></DIV>

<P id="id_237">Системный вызов <SPAN class="texample"><SPAN class="keyword">bind</SPAN></SPAN> служит для привязки созданного <SPAN class="keyword">сокета</SPAN> к определенному полному адресу вычислительной сети.</P><DIV class="lecture_mark" id="mark_237"></DIV>

<P id="id_239">Параметр <SPAN class="texample">sockd</SPAN> является дескриптором созданного ранее коммуникационного узла, т. е. значением, которое вернул системный вызов <SPAN class="texample"><SPAN class="keyword">socket()</SPAN></SPAN>.</P><DIV class="lecture_mark" id="mark_239"></DIV>

<P id="id_242">Параметр <SPAN class="texample">my_addr</SPAN> представляет собой адрес структуры, содержащей информацию о том, куда именно мы хотим привязать наш <SPAN class="keyword">сокет</SPAN> – то, что принято называть <SPAN class="keyword">адресом сокета</SPAN>. Он имеет тип указателя на структуру-шаблон struct <SPAN class="texample">sockaddr</SPAN>, которая должна быть конкретизирована в зависимости от используемого семейства протоколов и заполнена перед вызовом. </P><DIV class="lecture_mark" id="mark_242"></DIV>

<P id="id_245">Параметр <SPAN class="texample">addrlen</SPAN> должен содержать фактическую длину структуры, адрес которой передается в качестве второго параметра. Эта длина в разных семействах протоколов и даже в пределах одного семейства протоколов может быть различной (например, для UNIX Domain).</P><DIV class="lecture_mark" id="mark_245"></DIV>

<P id="id_247"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_247"></DIV>

<P id="id_248">Системный вызов возвращает значение <SPAN class="texample">0</SPAN> при нормальном завершении и отрицательное значение – в случае ошибки. </P><DIV class="lecture_mark" id="mark_248"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_232"></DIV><A name="sect14"></A><H3>Системные вызовы sendto() и recvfrom()</H3><P id="id_250">Для отправки <SPAN class="keyword">датаграмм</SPAN> применяется системный вызов <SPAN class="texample"><SPAN class="keyword">sendto()</SPAN></SPAN>. В число параметров этого вызова входят: </P><DIV class="lecture_mark" id="mark_250"></DIV><UL id="id_252"><LI>дескриптор <SPAN class="keyword">сокета</SPAN>, через который отсылается <SPAN class="keyword">датаграмма</SPAN>; </LI><LI>адрес области памяти, где лежат данные, которые должны составить содержательную часть <SPAN class="keyword">датаграммы</SPAN>, и их длина; </LI><LI>флаги, определяющие поведение системного вызова (в нашем случае они всегда будут иметь значение <SPAN class="texample">0</SPAN>); </LI><LI>указатель на структуру, содержащую <SPAN class="keyword">адрес сокета</SPAN> получателя, и ее фактическая длина. </LI></UL><DIV class="lecture_mark" id="mark_252"></DIV><P id="id_258">Системный вызов возвращает отрицательное значение при возникновении ошибки и количество реально отосланных байт при нормальной работе. <B>Нормальное завершение системного вызова не означает, что</B> <SPAN class="keyword">датаграмма</SPAN> <B>уже покинула ваш компьютер!</B> <SPAN class="keyword">Датаграмма</SPAN> сначала помещается в системный сетевой буфер, а ее реальная отправка может произойти после возврата из системного вызова. <SPAN class="keyword">Вызов sendto()</SPAN> может блокироваться, если в сетевом буфере не хватает места для <SPAN class="keyword">датаграммы</SPAN>.</P><DIV class="lecture_mark" id="mark_258"></DIV><P id="id_259">Для чтения принятых <SPAN class="keyword">датаграмм</SPAN> и определения адреса получателя (при необходимости) служит системный вызов <SPAN class="texample"><SPAN class="keyword">recvfrom()</SPAN></SPAN>. В число параметров этого вызова входят: </P><DIV class="lecture_mark" id="mark_259"></DIV><UL id="id_261"><LI>Дескриптор <SPAN class="keyword">сокета</SPAN>, через который принимается <SPAN class="keyword">датаграмма</SPAN>. </LI><LI>Адрес области памяти, куда следует положить данные, составляющие содержательную часть <SPAN class="keyword">датаграммы</SPAN>. </LI><LI>Максимальная длина, допустимая для <SPAN class="keyword">датаграммы</SPAN>. Если количество данных <SPAN class="keyword">датаграммы</SPAN> превышает заданную максимальную длину, то вызов по умолчанию рассматривает это как ошибочную ситуацию.</LI><LI>Флаги, определяющие поведение системного вызова (в нашем случае они будут полагаться равными <SPAN class="texample">0</SPAN>). </LI><LI>Указатель на структуру, в которую при необходимости может быть занесен <SPAN class="keyword">адрес сокета</SPAN> отправителя. Если этот адрес не требуется, то можно указать значение <SPAN class="texample">NULL</SPAN>. </LI><LI>Указатель на переменную, содержащую максимально возможную длину адреса отправителя. После возвращения из системного вызова в нее будет занесена фактическая длина структуры, содержащей адрес отправителя. Если предыдущий параметр имеет значение <SPAN class="texample">NULL</SPAN>, то и этот параметр может иметь значение <SPAN class="texample">NULL</SPAN>.</LI></UL><DIV class="lecture_mark" id="mark_261"></DIV><P id="id_272">Системный вызов <SPAN class="texample"><SPAN class="keyword">recvfrom()</SPAN></SPAN> по умолчанию блокируется, если отсутствуют принятые <SPAN class="keyword">датаграммы</SPAN>, до тех пор, пока <SPAN class="keyword">датаграмма</SPAN> не появится. При возникновении ошибки он возвращает отрицательное значение, при нормальной работе – длину принятой <SPAN class="keyword">датаграммы</SPAN>.</P><DIV class="lecture_mark" id="mark_272"></DIV><DIV class="xml_table_env" id="id_274"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_275"><B>Системные вызовы sendto и recvfrom</B></P><DIV class="lecture_mark" id="mark_275"></DIV>

<P id="id_276"><B>Прототипы системных вызовов</B></P><DIV class="lecture_mark" id="mark_276"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt; 
int sendto(int sockd, char *buff, 
    int nbytes, int flags, 
    struct sockaddr *to, int addrlen);
int recvfrom(int sockd, char *buff, 
    int nbytes, int flags, 
    struct sockaddr *from, int *addrlen);
</PRE></DIV>

<P id="id_278"><B>Описание системных вызовов</B></P><DIV class="lecture_mark" id="mark_278"></DIV>

<P id="id_279">Системный вызов <SPAN class="texample"><SPAN class="keyword">sendto</SPAN></SPAN> предназначен для отправки <SPAN class="keyword">датаграмм</SPAN>. Системный вызов <SPAN class="texample"><SPAN class="keyword">recvfrom</SPAN></SPAN> предназначен для чтения пришедших <SPAN class="keyword">датаграмм</SPAN> и определения адреса отправителя. По умолчанию при отсутствии пришедших <SPAN class="keyword">датаграмм</SPAN> вызов <SPAN class="texample"><SPAN class="keyword">recvfrom</SPAN></SPAN> блокируется до тех пор, пока не появится <SPAN class="keyword">датаграмма</SPAN>. Вызов <SPAN class="texample"><SPAN class="keyword">sendto</SPAN></SPAN> может блокироваться при отсутствии места под <SPAN class="keyword">датаграмму</SPAN> в сетевом буфере. Данное описание не является полным описанием системных вызовов, а предназначено только для использования в нашем курсе. За полной информацией обращайтесь к UNIX Manual.</P><DIV class="lecture_mark" id="mark_279"></DIV>

<P id="id_284">Параметр <SPAN class="texample">sockd</SPAN> является дескриптором созданного ранее <SPAN class="keyword">сокета</SPAN>, т. е. значением, возвращенным системным вызовом <SPAN class="texample"><SPAN class="keyword">socket()</SPAN></SPAN>, через который будет отсылаться или получаться информация.</P><DIV class="lecture_mark" id="mark_284"></DIV>

<P id="id_287">Параметр <SPAN class="texample">buff</SPAN> представляет собой адрес области памяти, начиная с которого будет браться информация для передачи или размещаться принятая информация.</P><DIV class="lecture_mark" id="mark_287"></DIV>

<P id="id_289">Параметр <SPAN class="texample">nbytes</SPAN> для системного вызова <SPAN class="texample"><SPAN class="keyword">sendto</SPAN></SPAN> определяет количество байт, которое должно быть передано, начиная с адреса памяти <SPAN class="texample">buff</SPAN>. Параметр <SPAN class="texample">nbytes</SPAN> для системного вызова <SPAN class="texample"><SPAN class="keyword">recvfrom</SPAN></SPAN> определяет максимальное количество байт, которое может быть размещено в приемном буфере, начиная с адреса <SPAN class="texample">buff</SPAN>. </P><DIV class="lecture_mark" id="mark_289"></DIV>

<P id="id_296">Параметр <SPAN class="texample">to</SPAN> для системного вызова <SPAN class="texample"><SPAN class="keyword">sendto</SPAN></SPAN> определяет ссылку на структуру, содержащую <SPAN class="keyword">адрес сокета</SPAN> получателя информации, которая должна быть заполнена перед вызовом. Если параметр <SPAN class="texample">from</SPAN> для системного вызова <SPAN class="texample"><SPAN class="keyword">recvfrom</SPAN></SPAN> не равен <SPAN class="texample">NULL</SPAN>, то для случая установления связи через пакеты данных он определяет ссылку на структуру, в которую будет занесен <SPAN class="keyword">адрес сокета</SPAN> отправителя информации после завершения вызова. В этом случае перед вызовом эту структуру необходимо обнулить.</P><DIV class="lecture_mark" id="mark_296"></DIV>

<P id="id_302">Параметр <SPAN class="texample">addrlen</SPAN> для системного вызова <SPAN class="texample"><SPAN class="keyword">sendto</SPAN></SPAN> должен содержать фактическую длину структуры, адрес которой передается в качестве параметра <SPAN class="texample">to</SPAN>. Для системного вызова <SPAN class="texample"><SPAN class="keyword">recvfrom</SPAN></SPAN> параметр <SPAN class="texample">addrlen</SPAN> является ссылкой на переменную, в которую будет занесена фактическая длина структуры <SPAN class="keyword">адреса сокета</SPAN> отправителя, если это определено параметром <SPAN class="texample">from</SPAN>. <B>Заметим, что перед вызовом этот параметр должен указывать на переменную, содержащую максимально допустимое значение такой длины.</B> Если параметр <SPAN class="texample">from</SPAN> имеет значение <SPAN class="texample">NULL</SPAN>, то и параметр <SPAN class="texample">addrlen</SPAN> может иметь значение <SPAN class="texample">NULL</SPAN>.</P><DIV class="lecture_mark" id="mark_302"></DIV>

<P id="id_313">Параметр <SPAN class="texample">flags</SPAN> определяет режимы использования системных вызовов. Рассматривать его применение мы в данном курсе не будем, и поэтому берем значение этого параметра равным <SPAN class="texample">0</SPAN>.</P><DIV class="lecture_mark" id="mark_313"></DIV>

<P id="id_316"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_316"></DIV>

<P id="id_317">В случае успешного завершения системный вызов возвращает количество реально отосланных или принятых байт. При возникновении какой-либо ошибки возвращается отрицательное значение.</P><DIV class="lecture_mark" id="mark_317"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_274"></DIV><A name="sect15"></A><H3>Определение IP-адресов для вычислительного комплекса </H3><P id="id_318">Для определения <SPAN class="keyword">IP-адресов</SPAN> на компьютере можно воспользоваться утилитой <SPAN class="texample">/sbin/ifconfig</SPAN>. Эта утилита выдает всю информацию о сетевых интерфейсах, сконфигурированных в вычислительной системе. Пример выдачи утилиты показан ниже:</P><DIV class="lecture_mark" id="mark_318"></DIV><A name="example.15-16.0"></A><DIV class="example"><PRE>eth0     Link encap:Ethernet HWaddr 00:90:27:A7:1B:FE 
    inet addr:192.168.253.12 Bcast:192.168.253.255 
    Mask:255.255.255.0
    UP BROADCAST NOTRAILERS RUNNING MULTICAST MTU:1500 
    Metric:1 RX packets:122556059 errors:0 dropped:0 
    overruns:0 frame:0 TX packets:116085111 errors:0 
    dropped:0 overruns:0 carrier:0 collisions:0 
    txqueuelen:100 RX bytes:2240402748 (2136.6 Mb) 
    TX bytes:3057496950 (2915.8 Mb) Interrupt:10 
    Base address:0x1000 
lo     Link encap:Local Loopback 
    inet addr:127.0.0.1 Mask:255.0.0.0
    UP LOOPBACK RUNNING MTU:16436 Metric:1
    RX packets:403 errors:0 dropped:0 overruns:0 frame:0
    TX packets:403 errors:0 dropped:0 overruns:0 
    carrier:0 collisions:0 txqueuelen:0 
    RX bytes:39932 (38.9 Kb) TX bytes:39932 (38.9 Kb)
</PRE><SPAN class="objectName">
            Пример 
            15-16.0.
            Информация о сетевых интерфейсах.</SPAN></DIV><P id="id_321">Сетевой интерфейс <SPAN class="texample">eth0</SPAN> использует протокол Ethernet. Физический 48-битовый адрес, зашитый в сетевой карте, – <SPAN class="texample">00:90:27:A7:1B:FE</SPAN>. Его <SPAN class="keyword">IP-адрес</SPAN> – <SPAN class="texample">192.168.253.12</SPAN>.</P><DIV class="lecture_mark" id="mark_321"></DIV><P id="id_325">Сетевой интерфейс <SPAN class="texample">lo</SPAN> не относится ни к какой сетевой карте. Это так называемый локальный интерфейс, который через общую память эмулирует работу сетевой карты для взаимодействия процессов, находящихся на одной машине по полным сетевым адресам. Наличие этого интерфейса позволяет отлаживать сетевые программы на машинах, не имеющих сетевых карт. Его <SPAN class="keyword">IP-адрес</SPAN> обычно одинаков на всех компьютерах – <SPAN class="texample">127.0.0.1</SPAN>.</P><DIV class="lecture_mark" id="mark_325"></DIV><A name="sect16"></A><H3>Пример программы UDP-клиента</H3><P id="id_328">Рассмотрим, наконец, простой пример программы <SPAN class="texample">15–16-1.с</SPAN>. Эта программа является UDP-клиентом для стандартного системного сервиса <SPAN class="texample">echo</SPAN>. Стандартный сервис принимает от клиента текстовую <SPAN class="keyword">датаграмму</SPAN> и, не изменяя ее, отправляет обратно. За сервисом зарезервирован номер <SPAN class="keyword">порта</SPAN> 7. Для правильного запуска программы необходимо указать символьный <SPAN class="keyword">IP-адрес</SPAN> сетевого интерфейса компьютера, к сервису которого нужно обратиться, в качестве аргумента командной строки, например:</P><DIV class="lecture_mark" id="mark_328"></DIV><DIV class="example"><PRE>a.out 192.168.253.12
</PRE></DIV><P id="id_332">Ниже следует текст программы</P><DIV class="lecture_mark" id="mark_332"></DIV><A name="example.15-16.1"></A><DIV class="example"><PRE>/* Простой пример UDP клиента для сервиса echo */
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
int main(int argc, char **argv)
{
    int sockfd; /* Дескриптор сокета */
    int n, len; /* Переменные для различных длин и 
        количества символов */
    char sendline[1000], recvline[1000]; /* Массивы 
        для отсылаемой и принятой строки */
    struct sockaddr_in servaddr, cliaddr; /* Структуры для
    адресов сервера и клиента */
    /* Сначала проверяем наличие второго аргумента в 
    командной строке. При его отсутствии ругаемся и прекращаем 
    работу */
    if(argc != 2){
        printf("Usage: a.out &lt;IP address&gt;\n");
        exit(1);
    }
    /* Создаем UDP сокет */
    if((sockfd = socket(PF_INET, SOCK_DGRAM, 0)) &lt; 0){
        perror(NULL); /* Печатаем сообщение об ошибке */
        exit(1);
    }
    /* Заполняем структуру для адреса клиента: семейство 
    протоколов TCP/IP, сетевой интерфейс – любой, номер порта 
    по усмотрению операционной системы. Поскольку в структуре
    содержится дополнительное не нужное нам поле, которое 
    должно     быть нулевым, перед заполнением обнуляем ее всю */
    bzero(&amp;cliaddr, sizeof(cliaddr));
    cliaddr.sin_family = AF_INET;
    cliaddr.sin_port = htons(0);
    cliaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    /* Настраиваем адрес сокета */
    if(bind(sockfd, (struct sockaddr *) &amp;cliaddr, 
    sizeof(cliaddr)) &lt; 0){
        perror(NULL);
        close(sockfd); /* По окончании работы закрываем 
        дескриптор сокета */
        exit(1);
    }
    /* Заполняем структуру для адреса сервера: 
семейство протоколов TCP/IP, сетевой интерфейс – из аргумента
командной строки, номер порта 7. Поскольку в 
структуре содержится дополнительное не нужное нам
поле, которое должно быть нулевым, перед заполнением
обнуляем ее всю */
    bzero(&amp;servaddr, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(7);
    if(inet_aton(argv[1], &amp;servaddr.sin_addr) == 0){
        printf("Invalid IP address\n");
        close(sockfd); /* По окончании работы закрываем 
            дескриптор сокета */
        exit(1);
    }
    /* Вводим строку, которую отошлем серверу */
    printf("String =&gt; ");
    fgets(sendline, 1000, stdin);
    /* Отсылаем датаграмму */
    if(sendto(sockfd, sendline, strlen(sendline)+1, 
    0, (struct sockaddr *) &amp;servaddr, 
    sizeof(servaddr)) &lt; 0){
    perror(NULL);
    close(sockfd);
    exit(1);
    }
    /* Ожидаем ответа и читаем его. Максимальная 
допустимая длина датаграммы – 1000 символов, 
адрес отправителя нам не нужен */
    if((n = recvfrom(sockfd, recvline, 1000, 0, 
    (struct sockaddr *) NULL, NULL)) &lt; 0){
        perror(NULL);
        close(sockfd);
        exit(1);
    }
    /* Печатаем пришедший ответ и закрываем сокет */
    printf("%s\n", recvline);
    close(sockfd);
    return 0;
}
</PRE><SPAN class="objectName">
            Листинг 
            15-16.1.
            Программа 15–16-1.c . Простой пример UDP клиента для сервиса echo.</SPAN></DIV><P id="id_334">Наберите и откомпилируйте программу. Перед запуском <B>"узнайте у своего системного администратора"</B>, запущен ли в системе стандартный UDP-сервис <SPAN class="texample">echo</SPAN> и если нет, попросите стартовать его. Запустите программу с запросом к сервису своего компьютера, к сервисам других компьютеров. Если в качестве <SPAN class="keyword">IP-адреса</SPAN> указать несуществующий адрес, адрес выключенной машины или машины, на которой не работает сервис <SPAN class="texample">echo</SPAN>, то программа бесконечно блокируется в вызове <SPAN class="texample"><SPAN class="keyword">recvfrom()</SPAN></SPAN>, ожидая ответа. <SPAN class="keyword">Протокол UDP</SPAN> не является надежным протоколом. Если <SPAN class="keyword">датаграмму</SPAN> доставить по назначению не удалось, то отправитель никогда об этом не узнает!</P><DIV class="lecture_mark" id="mark_334"></DIV><A name="sect17"></A><H3>Пример программы UDP-сервера</H3><P id="id_338">Поскольку UDP-сервер использует те же самые системные вызовы, что и UDP-клиент, мы можем сразу приступить к рассмотрению примера UDP-сервера (программа <SPAN class="texample">15–16-2.с</SPAN>) для сервиса <SPAN class="texample">echo</SPAN>.</P><DIV class="lecture_mark" id="mark_338"></DIV><A name="example.15-16.2"></A><DIV class="example"><PRE>/* Простой пример UDP-сервера для сервиса echo */
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
int main()
{
    int sockfd; /* Дескриптор сокета */
    int clilen, n; /* Переменные для различных длин 
        и количества символов */
    char line[1000]; /* Массив для принятой и 
        отсылаемой строки */
    struct sockaddr_in servaddr, cliaddr; /* Структуры 
        для адресов сервера и клиента */
    /* Заполняем структуру для адреса сервера: семейство
    протоколов TCP/IP, сетевой интерфейс – любой, номер порта 
    51000. Поскольку в структуре содержится дополнительное не
    нужное нам поле, которое должно быть нулевым, перед 
    заполнением обнуляем ее всю */
    bzero(&amp;servaddr, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(51000);
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    /* Создаем UDP сокет */
    if((sockfd = socket(PF_INET, SOCK_DGRAM, 0)) &lt; 0){
        perror(NULL); /* Печатаем сообщение об ошибке */
        exit(1);
    }
    /* Настраиваем адрес сокета */
    if(bind(sockfd, (struct sockaddr *) &amp;servaddr, 
    sizeof(servaddr)) &lt; 0){
        perror(NULL);
        close(sockfd);
        exit(1);
    }
    while(1) {
        /* Основной цикл обслуживания*/
        /* В переменную clilen заносим максимальную длину
        для ожидаемого адреса клиента */
        clilen = sizeof(cliaddr);
        /* Ожидаем прихода запроса от клиента и читаем его. 
        Максимальная допустимая длина датаграммы – 999 
        символов, адрес отправителя помещаем в структуру 
        cliaddr, его реальная длина будет занесена в 
        переменную clilen */
        if((n = recvfrom(sockfd, line, 999, 0, 
        (struct sockaddr *) &amp;cliaddr, &amp;clilen)) &lt; 0){
            perror(NULL);
            close(sockfd);
            exit(1);
        }
        /* Печатаем принятый текст на экране */
        printf("%s\n", line);
        /* Принятый текст отправляем обратно по адресу 
        отправителя */
        if(sendto(sockfd, line, strlen(line), 0, 
        (struct sockaddr *) &amp;cliaddr, clilen) &lt; 0){
            perror(NULL);
            close(sockfd);
            exit(1);
        } /* Уходим ожидать новую датаграмму*/
    }
    return 0;
}
</PRE><SPAN class="objectName">
            Листинг 
            15-16.2.
            Программа 15–16-2.c . Простой пример UDP-сервера для сервиса echo.</SPAN></DIV><P id="id_342">Наберите и откомпилируйте программу. Запустите ее на выполнение. Модифицируйте текст программы UDP-клиента (<A href="http://www.intuit.ru/department/os/osintropractice/10/osintropractice_10.html#example.15-16.1">программа</A> <SPAN class="texample">15–16-1.c</SPAN>), заменив номер <SPAN class="keyword">порта</SPAN> с 7 на 51000. Запустите клиента с другого виртуального терминала или с другого компьютера и убедитесь, что клиент и сервер взаимодействуют корректно.</P><DIV class="lecture_mark" id="mark_342"></DIV><A name="sect18"></A><H3>Организация связи между процессами с помощью установки логического соединения </H3><P id="id_344">Теперь посмотрим, какие действия нам понадобятся для организации взаимодействия процессов с помощью протокола TCP , то есть при помощи создания логического соединения. И начнем, как и в разделе "Использование модели клиент-сервер для взаимодействия удаленных процессов" текущего семинара, с простой жизненной аналогии. Если взаимодействие процессов через датаграммы напоминает общение людей по переписке, то для протокола TCP лучшей аналогией является общение людей по телефону. </P><DIV class="lecture_mark" id="mark_344"></DIV><P id="id_345">Какие действия должен выполнить клиент для того, чтобы связаться по телефону с сервером? Во-первых, необходимо приобрести телефон (создать <SPAN class="keyword">сокет</SPAN>), во-вторых, подключить его на АТС – получить номер (настроить <SPAN class="keyword">адрес сокета</SPAN>). Далее требуется позвонить серверу (установить <SPAN class="keyword">логическое соединение</SPAN>). После установления соединения можно неоднократно обмениваться с сервером информацией (писать и читать из потока данных). По окончании взаимодействия нужно повесить трубку (закрыть <SPAN class="keyword">сокет</SPAN>).</P><DIV class="lecture_mark" id="mark_345"></DIV><P id="id_346">Первые действия сервера аналогичны действиям клиента. Он должен приобрести телефон и подключить его на АТС (создать <SPAN class="keyword">сокет</SPAN> и настроить его адрес). А вот дальше поведение клиента и сервера различно. Представьте себе, что телефоны изначально продаются с выключенным звонком. Звонить по ним можно, а вот принять звонок – нет. Для того чтобы вы могли пообщаться, необходимо включить звонок. В терминах <SPAN class="keyword">сокетов</SPAN> это означает, что <SPAN class="keyword">TCP-сокет</SPAN> по умолчанию создается в активном состоянии и предназначен не для приема, а для установления соединения. Для того чтобы соединение принять, <SPAN class="keyword">сокет</SPAN> требуется перевести в пассивное состояние.</P><DIV class="lecture_mark" id="mark_346"></DIV><P id="id_347">Если два человека беседуют по телефону, то попытка других людей дозвониться до них окажется неудачной. Будет идти сигнал "занято", и соединение не установится. В то же время хотелось бы, чтобы клиент в такой ситуации не получал отказ в обслуживании, а ожидал своей очереди. Подобное наблюдается в различных телефонных справочных, когда вы слышите "Ждите, пожалуйста, ответа. Вам обязательно ответит оператор". Поэтому следующее действие сервера – это создание очереди для обслуживания клиентов. Далее сервер должен дождаться установления соединения, прочитать информацию, переданную по линии связи, обработать ее и отправить полученный результат обратно. Обмен информацией может осуществляться неоднократно. Заметим, что <SPAN class="keyword">сокет</SPAN>, находящийся в пассивном состоянии, не предназначен для операций приема и передачи информации. Для общения на сервере во время установления соединения автоматически создается новый потоковый <SPAN class="keyword">сокет</SPAN>, через который и производится 
обмен данными с клиентами. По окончании общения сервер "кладет трубку" (закрывает этот новый <SPAN class="keyword">сокет</SPAN>) и отправляется ждать очередного звонка.</P><DIV class="lecture_mark" id="mark_347"></DIV><P id="id_348">Схематично эти действия выглядят так, как показано на <A href="http://www.intuit.ru/department/os/osintropractice/10/osintropractice_10.html#image.15-16.7">рисунке 15–16.7</A>. Как и в случае <SPAN class="keyword">протокола UDP</SPAN> отдельным действиям или их группам соответствуют системные вызовы, частично совпадающие с вызовами для <SPAN class="keyword">протокола UDP</SPAN>. Их названия написаны справа от блоков соответствующих действий. </P><DIV class="lecture_mark" id="mark_348"></DIV><P id="id_349">Для <SPAN class="keyword">протокола TCP</SPAN> неравноправность процессов клиента и сервера видна особенно отчетливо в различии используемых системных вызовов. Для создания <SPAN class="keyword">сокетов</SPAN> и там, и там по-прежнему используется системный вызов <SPAN class="texample"><SPAN class="keyword">socket()</SPAN></SPAN>. Затем наборы системных вызовов становятся различными.</P><DIV class="lecture_mark" id="mark_349"></DIV><P id="id_351">Для привязки сервера к <SPAN class="keyword">IP-адресу</SPAN> и номеру <SPAN class="keyword">порта</SPAN>, как и в случае <SPAN class="keyword">UDP- протокола</SPAN>, используется системный вызов <SPAN class="texample"><SPAN class="keyword">bind()</SPAN></SPAN>. Для процесса клиента эта привязка объединена с процессом установления соединения с сервером в новом системном вызове <SPAN class="texample"><SPAN class="keyword">connect()</SPAN></SPAN> и скрыта от глаз пользователя. Внутри этого вызова операционная система осуществляет настройку <SPAN class="keyword">сокета</SPAN> на выбранный ею <SPAN class="keyword">порт</SPAN> и на адрес любого сетевого интерфейса. Для перевода <SPAN class="keyword">сокета</SPAN> на сервере в пассивное состояние и для создания очереди соединений служит системный вызов <SPAN class="texample"><SPAN class="keyword">listen()</SPAN></SPAN>. Сервер ожидает соединения и получает информацию об адресе соединившегося с ним клиента с помощью си
стемного вызова <SPAN class="texample"><SPAN class="keyword">accept()</SPAN></SPAN>. Поскольку установленное <SPAN class="keyword">логическое соединение</SPAN> выглядит со стороны процессов как канал связи, позволяющий обмениваться данными с помощью потоковой модели, для передачи и чтения информации оба системных вызова используют уже известные нам системные вызовы <SPAN class="texample">read()</SPAN> и <SPAN class="texample">write()</SPAN>, а для завершения соединения – системный вызов <SPAN class="texample">close()</SPAN>. Необходимо отметить, что при работе с <SPAN class="keyword">сокетами</SPAN> вызовы <SPAN class="texample">read()</SPAN> и <SPAN class="texample">write()</SPAN> обладают теми же особенностями поведения, что и при работе с pip’ами и FIFO (см. семинар 5).</P><DIV class="lecture_mark" id="mark_351"></DIV><P align="left" id="id_361"><A name="image.15-16.7"></A></P><DIV><IMG src="./10. Семейство протоколов TCP-IP. Сокеты (sockets) в UNIX и основы работы с ними_files/15-16-7.gif" alt="Схема взаимодействия клиента и сервера для протокола TCP" width="447" height="639"></DIV><BR><B>Рис. 15-16.7.</B>&nbsp;
        Схема взаимодействия клиента и сервера для протокола TCP<P></P><DIV class="lecture_mark" id="mark_361"></DIV><A name="sect19"></A><H3>Установление логического соединения. Системный вызов connect()</H3><P id="id_362">Среди системных вызовов со стороны клиента появляется только один новый – <SPAN class="texample"><SPAN class="keyword">connect()</SPAN></SPAN>. Системный вызов <SPAN class="texample"><SPAN class="keyword">connect()</SPAN></SPAN> при работе с <SPAN class="keyword">TCP-сокетами</SPAN> служит для установления <SPAN class="keyword">логического соединения</SPAN> со стороны клиента. Вызов <SPAN class="texample"><SPAN class="keyword">connect()</SPAN></SPAN> скрывает внутри себя настройку <SPAN class="keyword">сокета</SPAN> на выбранный системой <SPAN class="keyword">порт</SPAN> и произвольный сетевой интерфейс (по сути дела, вызов <SPAN class="texample"><SPAN class="keyword">bind()</SPAN></SPAN> с нулевым номером <SPAN class="keyword">порта</SPAN> и <SPAN class="keyword">IP-адресом</SPAN> <SPAN class="texample">INADDR_ANY</SPAN>). Вызов блокируется до тех пор, пока не будет установлено <SPAN class="keyword">логическое 
соединение</SPAN>, или пока не пройдет определенный промежуток времени, который может регулироваться системным администратором. </P><DIV class="lecture_mark" id="mark_362"></DIV><P id="id_368">Для установления соединения необходимо задать три параметра: дескриптор активного <SPAN class="keyword">сокета</SPAN>, через который будет устанавливаться соединение, полный <SPAN class="keyword">адрес сокета</SPAN> сервера и его длину.</P><DIV class="lecture_mark" id="mark_368"></DIV><DIV class="xml_table_env" id="id_369"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_370"><B>Системный вызов connect()</B></P><DIV class="lecture_mark" id="mark_370"></DIV>

<P id="id_371"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_371"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int connect(int sockd, 
    struct sockaddr *servaddr, 
    int addrlen);
</PRE></DIV>

<P id="id_373"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_373"></DIV>

<P id="id_374"><A name="keyword-context.21"></A>Системный вызов <SPAN class="texample"><SPAN class="keyword_def">connect</SPAN></SPAN> служит для организации связи клиента с сервером. Чаще всего он используется для установления <SPAN class="keyword">логического соединения</SPAN>, хотя может быть применен и при связи с помощью <SPAN class="keyword">датаграмм</SPAN> (connectionless). Данное описание не является полным описанием системного вызова, а предназначено только для использования в нашем курсе. Полную информацию можно найти в UNIX Manual.</P><DIV class="lecture_mark" id="mark_374"></DIV>

<P id="id_376">Параметр <SPAN class="texample">sockd</SPAN> является дескриптором созданного ранее коммуникационного узла, т. е. значением, которое вернул системный вызов <SPAN class="texample"><SPAN class="keyword">socket()</SPAN></SPAN>.</P><DIV class="lecture_mark" id="mark_376"></DIV>

<P id="id_379">Параметр <SPAN class="texample">servaddr</SPAN> представляет собой адрес структуры, содержащей информацию о полном <SPAN class="keyword">адресе сокета</SPAN> сервера. Он имеет тип указателя на структуру-шаблон <SPAN class="texample">struct sockaddr</SPAN>, которая должна быть конкретизирована в зависимости от используемого семейства протоколов и заполнена перед вызовом. </P><DIV class="lecture_mark" id="mark_379"></DIV>

<P id="id_382">Параметр <SPAN class="texample">addrlen</SPAN> должен содержать фактическую длину структуры, адрес которой передается в качестве второго параметра. Эта длина меняется в зависмости от семейства протоколов и различается даже в пределах одного семейства протоколов (например, для UNIX Domain).</P><DIV class="lecture_mark" id="mark_382"></DIV>

<P id="id_384">При установлении <SPAN class="keyword">виртуального соединения</SPAN> системный вызов не возвращается до его установления или до истечения установленного в системе времени – <SPAN class="texample">timeout</SPAN>. При использовании его в <SPAN class="texample">connectionless</SPAN> связи вызов возвращается немедленно.</P><DIV class="lecture_mark" id="mark_384"></DIV>

<P id="id_387"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_387"></DIV>

<P id="id_388">Системный вызов возвращает значение <SPAN class="texample">0</SPAN> при нормальном завершении и отрицательное значение, если в процессе его выполнения возникла ошибка. </P><DIV class="lecture_mark" id="mark_388"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_369"></DIV><A name="sect20"></A><H3>Пример программы TCP-клиента</H3><P id="id_390">Рассмотрим пример – программу <SPAN class="texample">15–16-3.с</SPAN>. Это простой TCP-клиент, обращающийся к стандартному системному сервису <SPAN class="texample">echo</SPAN>. Стандартный сервис принимает от клиента текстовую <SPAN class="keyword">датаграмму</SPAN> и, не изменяя ее, отправляет обратно. За сервисом зарезервирован номер <SPAN class="keyword">порта</SPAN> 7. Заметим, что это <SPAN class="keyword">порт</SPAN> 7 TCP – не путать с <SPAN class="keyword">портом</SPAN> 7 UDP из примера в разделе "Пример программы UDP-клиента"! Для правильного запуска программы необходимо указать символьный <SPAN class="keyword">IP-адрес</SPAN> сетевого интерфейса компьютера, к сервису которого требуется обратиться, в качестве аргумента командной строки, например:</P><DIV class="lecture_mark" id="mark_390"></DIV><DIV class="example"><PRE>a.out 192.168.253.12</PRE></DIV><P id="id_394">Для того чтобы подчеркнуть, что после установления <SPAN class="keyword">логического соединения</SPAN> клиент и сервер могут обмениваться информацией неоднократно, клиент трижды запрашивает текст с экрана, отсылает его серверу и печатает полученный ответ. Ниже представлен текст программы.</P><DIV class="lecture_mark" id="mark_394"></DIV><A name="example.15-16.3"></A><DIV class="example"><PRE>/* Простой пример TCP-клиента для сервиса echo */
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
void main(int argc, char **argv)
{
    int sockfd; /* Дескриптор сокета */
    int n; /* Количество переданных или прочитанных 
        символов */
    int i; /* Счетчик цикла */
    char sendline[1000],recvline[1000]; /* Массивы 
        для отсылаемой и принятой строки */
    struct sockaddr_in servaddr; /* Структура для 
        адреса сервера */
    /* Сначала проверяем наличие второго аргумента в
    командной строке. При его отсутствии прекращаем 
    работу */
    if(argc != 2){
        printf("Usage: a.out &lt;IP address&gt;\n");
        exit(1);
    }
    /* Обнуляем символьные массивы */
    bzero(sendline,1000);
    bzero(recvline,1000);
    /* Создаем TCP сокет */
    if((sockfd = socket(PF_INET, SOCK_STREAM, 0)) &lt; 0){
        perror(NULL); /* Печатаем сообщение об ошибке */
        exit(1);
    }
    /* Заполняем структуру для адреса сервера: семейство 
    протоколов TCP/IP, сетевой интерфейс – из аргумента 
    командной строки, номер порта 7. Поскольку в структуре
    содержится дополнительное не нужное нам поле, 
    которое должно быть нулевым, перед заполнением обнуляем 
    ее всю */
    bzero(&amp;servaddr, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(51000);
    if(inet_aton(argv[1], &amp;servaddr.sin_addr) == 0){
        printf("Invalid IP address\n");
        close(sockfd);
        exit(1);
    }
    /* Устанавливаем логическое соединение через 
созданный сокет с сокетом сервера, адрес которого мы занесли
в структуру */
    if(connect(sockfd, (struct sockaddr *) &amp;servaddr, 
    sizeof(servaddr)) &lt; 0){
        perror(NULL);
        close(sockfd);
        exit(1);
    }
    /* Три раза в цикле вводим строку с клавиатуры, отправляем 
    ее серверу и читаем полученный ответ */
    for(i=0; i&lt;3; i++){
        printf("String =&gt; ");
        fflush(stdin);
        fgets(sendline, 1000, stdin);
        if( (n = write(sockfd, sendline, 
        strlen(sendline)+1)) &lt; 0){
            perror("Can\'t write\n");
            close(sockfd);
            exit(1);
        }
        if ( (n = read(sockfd,recvline, 999)) &lt; 0){
            perror("Can\'t read\n");
            close(sockfd);
            exit(1);
        }
        printf("%s", recvline);
    }
    /* Завершаем соединение */
    close(sockfd);
}
</PRE><SPAN class="objectName">
            Листинг 
            15-16.3.
            Программа 15–16-3.c . Простой пример TCP-клиента для сервиса echo.</SPAN></DIV><P id="id_396">Наберите и откомпилируйте программу. Перед запуском <B>"узнайте у своего системного администратора"</B>, запущен ли в системе стандартный TCP-сервис <SPAN class="texample">echo</SPAN> и, если нет, попросите это сделать. Запустите программу с запросом к сервису своего компьютера, к сервисам других компьютеров. Если в качестве <SPAN class="keyword">IP-адреса</SPAN> указать несуществующий адрес или адрес выключенной машины, то программа сообщит об ошибке при работе вызова <SPAN class="texample"><SPAN class="keyword">connect()</SPAN></SPAN> (правда, возможно, придется подождать окончания timeout’а). При задании адреса компьютера, на котором не работает сервис <SPAN class="texample">echo</SPAN>, об ошибке станет известно сразу же. <SPAN class="keyword">Протокол TCP</SPAN> является надежным протоколом. Если <SPAN class="keyword">логическое соединение</SPAN> установить не удалось, то отправитель будет знать об этом.</P><DIV class="lecture_mark" id="mark_396"></DIV><A name="sect21"></A><H3>Как происходит установление виртуального соединения</H3><P id="id_400"><SPAN class="keyword">Протокол TCP</SPAN> является надежным дуплексным протоколом. С точки зрения пользователя работа через <SPAN class="keyword">протокол TCP</SPAN> выглядит как обмен информацией через поток данных. Внутри сетевых частей операционных систем поток данных отправителя нарезается на пакеты данных, которые, собственно, путешествуют по сети и на машине-получателе вновь собираются в выходной поток данных. В лекции 4 речь шла о том, каким образом может обеспечиваться надежность передачи информации в средствах связи, использующих в своей основе передачу пакетов данных. В <SPAN class="keyword">протоколе TCP</SPAN> используются приемы нумерации передаваемых пакетов и контроля порядка их получения, подтверждения о приеме пакета со стороны получателя и насчет контрольных сумм по передаваемой информации. Для правильного порядка получения пакетов получатель должен знать начальный номер первого пакета отправителя. Поскольку связь является дуплексной, и в роли отправителя 
пакетов данных могут выступать обе взаимодействующие стороны, они до передачи пакетов данных должны обменяться, по крайней мере, информацией об их начальных номерах. Согласование начальных номеров происходит по инициативе клиента при выполнении системного вызова <SPAN class="texample"><SPAN class="keyword">connect()</SPAN></SPAN>.</P><DIV class="lecture_mark" id="mark_400"></DIV><P id="id_402">Для такого согласования клиент посылает серверу специальный пакет информации, который принято называть SYN (от слова synchronize – синхронизировать). Он содержит, как минимум, начальный номер для пакетов данных, который будет использовать клиент. Сервер должен подтвердить получение пакета SYN от клиента и отправить ему свой пакет SYN с начальным номером для пакетов данных, в виде единого пакета с сегментами SYN и ACK (от слова acknowledgement – подтверждение). В ответ клиент пакетом данных ACK должен подтвердить прием пакета данных от сервера. </P><DIV class="lecture_mark" id="mark_402"></DIV><P id="id_403">Описанная выше <A name="keyword-context.22"></A>процедура, получившая название <SPAN class="keyword_def">трехэтапного рукопожатия</SPAN> (three-way handshake), схематично изображена на <A href="http://www.intuit.ru/department/os/osintropractice/10/10.html#image.15-16.8">рисунке 15–16.8</A>. При приеме на машине-сервере пакета SYN, направленного на <SPAN class="keyword">пассивный (слушающий) сокет</SPAN>, сетевая часть операционной системе создает копию этого <SPAN class="keyword">сокета</SPAN> – <SPAN class="keyword">присоединенный сокет</SPAN> – для последующего общения, отмечая его как <SPAN class="keyword">сокет</SPAN> с <SPAN class="keyword">не полностью установленным соединением</SPAN>. После приема от клиента пакета ACK этот <SPAN class="keyword">сокет</SPAN> переводится в состояние <SPAN class="keyword">полностью установленного соединения</SPAN>, и тогда он готов к дальнейшей работе с использованием вызовов <SPAN class="texample">read()</SPAN> и 
<SPAN class="texample">write()</SPAN>.</P><DIV class="lecture_mark" id="mark_403"></DIV><A name="sect22"></A><H3>Системный вызов listen()</H3><P id="id_406">Системный вызов <SPAN class="texample"><SPAN class="keyword">listen()</SPAN></SPAN> является первым из еще неизвестных нам вызовов, применяемым на TCP–сервере. В его задачу входит перевод <SPAN class="keyword">TCP–сокета</SPAN> в <SPAN class="keyword">пассивное (слушающее)</SPAN> состояние и создание очередей для порождаемых при установлении соединения <SPAN class="keyword">присоединенных сокетов</SPAN>, находящихся в состоянии <SPAN class="keyword">не полностью установленного соединения</SPAN> и <SPAN class="keyword">полностью установленного соединения</SPAN>. Для этого вызов имеет два параметра: дескриптор <SPAN class="keyword">TCP–сокета</SPAN> и число, определяющее глубину создаваемых очередей. </P><DIV class="lecture_mark" id="mark_406"></DIV><P align="left" id="id_408"><A name="image.15-16.8"></A></P><DIV><IMG src="./10. Семейство протоколов TCP-IP. Сокеты (sockets) в UNIX и основы работы с ними_files/15-16-8.gif" alt="Схема установления TCP соединения" width="447" height="272"></DIV><BR><B>Рис. 15-16.8.</B>&nbsp;
        Схема установления TCP соединения<P></P><DIV class="lecture_mark" id="mark_408"></DIV><DIV class="xml_table_env" id="id_409"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_410"><B>Системный вызов listen()</B></P><DIV class="lecture_mark" id="mark_410"></DIV>

<P id="id_411"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_411"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt; 
int listen(int sockd, int backlog);
</PRE></DIV>

<P id="id_413"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_413"></DIV>

<P id="id_414"><A name="keyword-context.23"></A>Системный вызов <SPAN class="texample"><SPAN class="keyword_def">listen</SPAN></SPAN> используется сервером, ориентированным на установление связи путем <SPAN class="keyword">виртуального соединения</SPAN>, для перевода <SPAN class="keyword">сокета</SPAN> в пассивный режим и установления глубины очереди для соединений. </P><DIV class="lecture_mark" id="mark_414"></DIV>

<P id="id_416">Параметр <SPAN class="texample">sockd</SPAN> является дескриптором созданного ранее <SPAN class="keyword">сокета</SPAN>, который должен быть переведен в пассивный режим, т. е. значением, которое вернул системный вызов <SPAN class="texample"><SPAN class="keyword">socket()</SPAN></SPAN>. Системный вызов <SPAN class="texample"><SPAN class="keyword">listen</SPAN></SPAN> требует предварительной настройки <SPAN class="keyword">адреса сокета</SPAN> с помощью системного вызова <SPAN class="texample"><SPAN class="keyword">bind()</SPAN></SPAN>.</P><DIV class="lecture_mark" id="mark_416"></DIV>

<P id="id_421">Параметр <SPAN class="texample">backlog</SPAN> определяет максимальный размер очередей для <SPAN class="keyword">сокетов</SPAN>, находящихся в состояниях <SPAN class="keyword">полностью</SPAN> и <SPAN class="keyword">не полностью установленных соединений</SPAN>. </P><DIV class="lecture_mark" id="mark_421"></DIV>

<P id="id_423"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_423"></DIV>

<P id="id_424">Системный вызов возвращает значение <SPAN class="texample">0</SPAN> при нормальном завершении и значение <SPAN class="texample">-1</SPAN> при возникновении ошибки.</P><DIV class="lecture_mark" id="mark_424"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_409"></DIV><P id="id_427">Последний параметр на разных UNIX-подобных операционных системах и даже на разных версиях одной и той же системы может иметь различный смысл. Где-то это суммарная длина обеих очередей, где-то он относится к очереди <SPAN class="keyword">не полностью установленных соединений</SPAN> (например, Linux до версии ядра 2.2) где-то – к очереди <SPAN class="keyword">полностью установленных соединений</SPAN> (например, Linux, начиная с версии ядра 2.2), где-то – вообще игнорируется. </P><DIV class="lecture_mark" id="mark_427"></DIV><A name="sect23"></A><H3>Системный вызов accept()</H3><P id="id_428">Системный вызов <SPAN class="texample"><SPAN class="keyword">accept()</SPAN></SPAN> позволяет серверу получить информацию о <SPAN class="keyword">полностью установленных соединениях</SPAN>. Если очередь <SPAN class="keyword">полностью установленных соединений</SPAN> не пуста, то он возвращает дескриптор для первого <SPAN class="keyword">присоединенного сокета</SPAN> в этой очереди, одновременно удаляя его из очереди. Если очередь пуста, то вызов ожидает появления <SPAN class="keyword">полностью установленного соединения</SPAN>. Системный вызов также позволяет серверу узнать полный адрес клиента, установившего соединение. У вызова есть три параметра: дескриптор слушающего <SPAN class="keyword">сокета</SPAN>, через который ожидается установление соединения; указатель на структуру, в которую при необходимости будет занесен полный <SPAN class="keyword">адрес сокета</SPAN> 
клиента, установившего соединение; указатель на целую переменную, содержащую максимально допустимую длину этого адреса. Как и в случае вызова <SPAN class="texample"><SPAN class="keyword">recvfrom()</SPAN></SPAN>, последний параметр является модернизируемым, а если нас не интересует, кто с нами соединился, то вместо второго и третьего параметров можно указать значение <SPAN class="texample">NULL</SPAN>. </P><DIV class="lecture_mark" id="mark_428"></DIV><DIV class="xml_table_env" id="id_432"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_433"><B>Системный вызов accept()</B></P><DIV class="lecture_mark" id="mark_433"></DIV>

<P id="id_434"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_434"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt; 
int accept(int sockd, 
    struct sockaddr *cliaddr, 
    int *clilen);
</PRE></DIV>

<P id="id_436"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_436"></DIV>

<P id="id_437"><A name="keyword-context.24"></A>Системный вызов <SPAN class="texample"><SPAN class="keyword_def">accept</SPAN></SPAN> используется сервером, ориентированным на установление связи путем <SPAN class="keyword">виртуального соединения</SPAN>, для приема <SPAN class="keyword">полностью установленного соединения</SPAN>. </P><DIV class="lecture_mark" id="mark_437"></DIV>

<P id="id_439">Параметр <SPAN class="texample">sockd</SPAN> является дескриптором созданного и настроенного <SPAN class="keyword">сокета</SPAN>, предварительного переведенного в <SPAN class="keyword">пассивный (слушающий)</SPAN> режим с помощью системного вызова <SPAN class="texample"><SPAN class="keyword">listen()</SPAN></SPAN>. </P><DIV class="lecture_mark" id="mark_439"></DIV>

<P id="id_442">Системный вызов <SPAN class="texample"><SPAN class="keyword">accept</SPAN></SPAN> требует предварительной настройки <SPAN class="keyword">адреса сокета</SPAN> с помощью системного вызова <SPAN class="texample"><SPAN class="keyword">bind()</SPAN></SPAN>.</P><DIV class="lecture_mark" id="mark_442"></DIV>

<P id="id_445">Параметр <SPAN class="texample">cliaddr</SPAN> служит для получения адреса клиента, установившего <SPAN class="keyword">логическое соединение</SPAN>, и должен содержать указатель на структуру, в которую будет занесен этот адрес.</P><DIV class="lecture_mark" id="mark_445"></DIV>

<P id="id_447">Параметр <SPAN class="texample">clilen</SPAN> содержит указатель на целую переменную, которая после возвращения из вызова будет содержать фактическую длину адреса клиента. <B>Заметим, что перед вызовом эта переменная должна содержать максимально допустимое значение такой длины</B>. Если параметр <SPAN class="texample">cliaddr</SPAN> имеет значение <SPAN class="texample">NULL</SPAN>, то и параметр <SPAN class="texample">clilen</SPAN> может иметь значение <SPAN class="texample">NULL</SPAN>.</P><DIV class="lecture_mark" id="mark_447"></DIV>

<P id="id_453"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_453"></DIV>

<P id="id_454">Системный вызов возвращает при нормальном завершении дескриптор <SPAN class="keyword">присоединенного сокета</SPAN>, созданного при установлении соединения для последующего общения клиента и сервера, и значение <SPAN class="texample">-1</SPAN> при возникновении ошибки.</P><DIV class="lecture_mark" id="mark_454"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_432"></DIV><A name="sect24"></A><H3>Пример простого TCP-сервера</H3><P id="id_456">Рассмотрим программу <SPAN class="texample">15–16-4.c</SPAN>, реализующую простой TCP-сервер для сервиса <SPAN class="texample">echo</SPAN>.</P><DIV class="lecture_mark" id="mark_456"></DIV><A name="example.15-16.4"></A><DIV class="example"><PRE>/* Пример простого TCP-сервера для сервиса echo */
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
void main()
{
    int sockfd, newsockfd; /* Дескрипторы для 
слушающего и присоединенного сокетов */
    int clilen; /* Длина адреса клиента */
    int n; /* Количество принятых символов */
    char line[1000]; /* Буфер для приема информации */
    struct sockaddr_in servaddr, cliaddr; /* Структуры 
        для размещения полных адресов сервера и 
        клиента */
    /* Создаем TCP-сокет */
    if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0){
        perror(NULL);
        exit(1);
    }
    /* Заполняем структуру для адреса сервера: семейство
    протоколов TCP/IP, сетевой интерфейс – любой, номер 
    порта 51000. Поскольку в структуре содержится 
    дополнительное не нужное нам поле, которое должно 
    быть нулевым, побнуляем ее всю перед заполнением */
    bzero(&amp;servaddr, sizeof(servaddr));
    servaddr.sin_family= AF_INET;
    servaddr.sin_port= htons(51000);
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    /* Настраиваем адрес сокета */
    if(bind(sockfd, (struct sockaddr *) &amp;servaddr, 
    sizeof(servaddr)) &lt; 0){
        perror(NULL);
        close(sockfd);
        exit(1);
    }
    /* Переводим созданный сокет в пассивное (слушающее) 
    состояние. Глубину очереди для установленных 
    соединений описываем значением 5 */
    if(listen(sockfd, 5) &lt; 0){
        perror(NULL);
        close(sockfd);
        exit(1);
    }
    /* Основной цикл сервера */
    while(1){
        /* В переменную clilen заносим максимальную
        длину ожидаемого адреса клиента */
        clilen = sizeof(cliaddr);
        /* Ожидаем полностью установленного соединения
        на слушающем сокете. При нормальном завершении 
        у нас в структуре cliaddr будет лежать полный 
        адрес клиента, установившего соединение, а в 
        переменной clilen – его фактическая длина. Вызов
        же вернет дескриптор присоединенного сокета, через
        который будет происходить общение с клиентом. 
        Заметим, что информация о клиенте у нас в
        дальнейшем никак не используется, поэтому 
        вместо второго и третьего параметров можно 
        было поставить значения NULL. */
        if((newsockfd = accept(sockfd, 
        (struct sockaddr *) &amp;cliaddr, &amp;clilen)) &lt; 0){
            perror(NULL);
            close(sockfd);
            exit(1);
        }
        /* В цикле принимаем информацию от клиента до
        тех пор, пока не произойдет ошибки (вызов read()
        вернет отрицательное значение) или клиент не
        закроет соединение (вызов read() вернет 
        значение 0). Максимальную длину одной порции 
        данных от клиента ограничим 999 символами. В
        операциях чтения и записи пользуемся дескриптором
        присоединенного сокета, т. е. значением, которое
        вернул вызов accept().*/
        while((n = read(newsockfd, line, 999)) &gt; 0){
            /* Принятые данные отправляем обратно */
            if((n = write(newsockfd, line, 
            strlen(line)+1)) &lt; 0){
                perror(NULL);
                close(sockfd);
                close(newsockfd);
                exit(1);
            }
        }
    /* Если при чтении возникла ошибка – завершаем работу */
    if(n &lt; 0){
            perror(NULL);
            close(sockfd);
            close(newsockfd);
            exit(1);
        }
        /* Закрываем дескриптор присоединенного сокета и
        уходим ожидать нового соединения */
        close(newsockfd);
    }
}
</PRE><SPAN class="objectName">
            Листинг 
            15-16.4.
            Программа 15–16-4.c . Пример простого TCP-сервера для сервиса echo.</SPAN></DIV><P id="id_460">Наберите и откомпилируйте программу. Запустите ее на выполнение. Модифицируйте текст программы TCP-клиента (<A href="http://www.intuit.ru/department/os/osintropractice/10/9.html#example.15-16.3">программа</A> <SPAN class="texample">15–16-3.c</SPAN>), заменив номер <SPAN class="keyword">порта</SPAN> с 7 на 51000. Запустите клиента с другого виртуального терминала или с другого компьютера и убедитесь, что клиент и сервер взаимодействуют корректно.</P><DIV class="lecture_mark" id="mark_460"></DIV><A name="sect25"></A><H3>Создание программы с параллельной обработкой запросов клиентов</H3><P id="id_462">В приведенном выше примере сервер осуществлял последовательную обработку запросов от разных клиентов. При таком подходе клиенты могут подолгу простаивать после установления соединения, ожидая обслуживания. Поэтому обычно применяется схема псевдопараллельной обработки запросов. После приема установленного соединения сервер порождает процесс-ребенок, которому и поручает дальнейшую работу с клиентом. Процесс-родитель закрывает <SPAN class="keyword">присоединенный сокет</SPAN> и уходит на ожидание нового соединения. Схематично организация такого сервера изображена на <A href="http://www.intuit.ru/department/os/osintropractice/10/osintropractice_10.html#image.15-16.9">рис. 15–16.9</A>. </P><DIV class="lecture_mark" id="mark_462"></DIV><P id="id_463">Напишите, откомпилируйте и запустите такой параллельный сервер. Убедитесь в его работоспособности. Не забудьте о необходимости удаления зомби-процессов.</P><DIV class="lecture_mark" id="mark_463"></DIV><A name="sect26"></A><H3>Применение интерфейса сетевых вызовов для других семейств протоколов. UNIX Domain протоколы. Файлы типа "сокет"</H3><P id="id_464">Рассмотренный нами интерфейс умеет работать не только со <SPAN class="keyword">стеком протоколов TCP/IP</SPAN>, но и с другими семействами протоколов. При этом требуется лишь незначительное изменение написанных с его помощью программ. Рассмотрим действия, которые необходимо выполнить для модернизации написанных для TCP/IP программ под другое семейство протоколов.</P><DIV class="lecture_mark" id="mark_464"></DIV><OL id="id_465"><LI>Изменяется тип <SPAN class="keyword">сокета</SPAN>, поэтому для его точной спецификации нужно задавать другие параметры в системном вызове <SPAN class="texample"><SPAN class="keyword">socket()</SPAN></SPAN>.</LI><LI>В различных семействах протоколов применяются различные адресные пространства для удаленных и локальных <SPAN class="keyword">адресов сокетов</SPAN>. Поэтому меняется состав структуры для хранения полного <SPAN class="keyword">адреса сокета</SPAN>, название ее типа, наименования полей и способ их заполнения.</LI><LI>Описание типов данных и предопределенных констант будет находиться в других include-файлах, поэтому потребуется заменить include-файлы <SPAN class="texample">&lt;netinet/in.h&gt;</SPAN> и <SPAN class="texample">&lt;arpa/inet.h&gt;</SPAN> на файлы, относящиеся к выбранному семейству протоколов.</LI><LI>Может измениться способ вычисления фактической длины полного <SPAN class="keyword">адреса сокета</SPAN> и указания его максимального размера.</LI></OL><DIV class="lecture_mark" id="mark_465"></DIV><P id="id_473">И все!!!</P><DIV class="lecture_mark" id="mark_473"></DIV><P align="left" id="id_474"><A name="image.15-16.9"></A></P><DIV><IMG src="./10. Семейство протоколов TCP-IP. Сокеты (sockets) в UNIX и основы работы с ними_files/15-16-9.gif" alt="Схема работы TCP-сервера с параллельной обработкой запросов" width="447" height="489"></DIV><BR><B>Рис. 15-16.9.</B>&nbsp;
        Схема работы TCP-сервера с параллельной обработкой запросов<P></P><DIV class="lecture_mark" id="mark_474"></DIV><P id="id_475">Давайте подробнее рассмотрим эти изменения на примере семейства <SPAN class="keyword">UNIX Domain протоколов</SPAN>. Семейство <SPAN class="keyword">UNIX Domain протоколов</SPAN> предназначено для общения локальных процессов с использованием интерфейса системных вызовов. Оно содержит один потоковый и один датаграммный протокол. Никакой сетевой интерфейс при этом не используется, а вся передача информации реально происходит через адресное пространство ядра операционной системы. Многие программы, взаимодействующие и с локальными, и с удаленными процессами (например, X-Windows), для локального общения используют этот стек протоколов.</P><DIV class="lecture_mark" id="mark_475"></DIV><P id="id_476">Поскольку общение происходит в рамках одной вычислительной системы, в полном <SPAN class="keyword">адресе сокета</SPAN> его удаленная часть отсутствует. В качестве адресного пространства <SPAN class="keyword">портов</SPAN> – локальной части адреса – выбрано адресное пространство, совпадающее с множеством всех допустимых имен файлов в файловой системе. </P><DIV class="lecture_mark" id="mark_476"></DIV><P id="id_477">При этом в качестве имени <SPAN class="keyword">сокета</SPAN> требуется задавать имя несуществующего еще файла в директории, к которой у вас есть права доступа как на запись, так и на чтение. При настройке адреса (системный вызов <SPAN class="texample"><SPAN class="keyword">bind()</SPAN></SPAN>) под этим именем будет создан <SPAN class="keyword">файл типа "сокет"</SPAN> – последний еще неизвестный нам тип файла. Этот файл для <SPAN class="keyword">сокетов</SPAN> играет роль файла-метки типа FIFO для именованных pip’ов. Если на вашей машине функционируют X-Windows, то вы сможете обнаружить такой файл в директории с именем <SPAN class="texample">/tmp/.X11-unix</SPAN> – это <SPAN class="keyword">файл типа "сокет"</SPAN>, служащий для взаимодействия локальных процессов с оконным сервером.</P><DIV class="lecture_mark" id="mark_477"></DIV><P id="id_480">Для хранения полного <SPAN class="keyword">адреса сокета</SPAN> используется структура следующего вида, описанного в файле <SPAN class="texample">&lt;sys/un.h&gt;</SPAN>:</P><DIV class="lecture_mark" id="mark_480"></DIV><DIV class="example"><PRE>struct sockaddr_un{
    short sun_family; 
    /* Избранное семейство 
       протоколов – всегда AF_UNIX */
    
    char sun_path[108]; 
    /* Имя файла типа "сокет" */
};
</PRE></DIV><P id="id_483">Выбранное имя файла мы будем копировать внутрь структуры, используя функцию <SPAN class="texample">strcpy()</SPAN>.</P><DIV class="lecture_mark" id="mark_483"></DIV><P id="id_485">Фактическая длина полного <SPAN class="keyword">адреса сокета</SPAN>, хранящегося в структуре с именем <SPAN class="texample">my_addr</SPAN>, может быть вычислена следующим образом: <SPAN class="texample">sizeof(short)+strlen(my_addr.sun_path)</SPAN>. В Linux для этих целей можно использовать специальный макрос языка С</P><DIV class="lecture_mark" id="mark_485"></DIV><DIV class="example"><PRE>SUN_LEN(struct sockaddr_un*)
</PRE></DIV><P id="id_489">Ниже приведены тексты переписанных под семейство <SPAN class="keyword">UNIX Domain протоколов</SPAN> клиента и сервера для сервиса <SPAN class="texample">echo</SPAN> (программы <SPAN class="texample">15–16-5.c</SPAN> и <SPAN class="texample">15–16-6.c</SPAN>), общающиеся через <SPAN class="keyword">датаграммы</SPAN>. Клиент использует <SPAN class="keyword">сокет</SPAN> с именем <SPAN class="texample">AAAA</SPAN> в текущей директории, а сервер – <SPAN class="keyword">сокет</SPAN> с именем <SPAN class="texample">BBBB</SPAN>. Как следует из описания типа данных, эти имена (полные или относительные) не должны по длине превышать 107 символов. Комментарии даны лишь для изменений по сравнению с программами <SPAN class="texample">15–16-1.c</SPAN> и <SPAN class="texample">15–16-2.c</SPAN>.</P><DIV class="lecture_mark" id="mark_489"></DIV><A name="example.15-16.5"></A><DIV class="example"><PRE>/* A simple echo UNIX Domain datagram server */
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/un.h&gt; /* Новый include-файл вместо 
    netinet/in.h и arpa/inet.h */
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
int main()
{
    int sockfd;
    int clilen, n;
    char line[1000];
    struct sockaddr_un servaddr, cliaddr; /* новый 
        тип данных под адреса сокетов */
    if((sockfd = socket(AF_UNIX, SOCK_DGRAM, 0)) &lt; 0) 
    /* Изменен тип семейства протоколов */
    {
        perror(NULL);
        exit(1);
    }
    bzero(&amp;servaddr, sizeof(servaddr));
    servaddr.sun_family = AF_UNIX; /* Изменен тип 
        семейства протоколов и имя поля в структуре */
    strcpy(servaddr.sun_path,"BBBB"); /* Локальный 
        адрес сокета сервера – BBBB – в текущей 
        директории */
    if(bind(sockfd, (struct sockaddr *) &amp;servaddr, 
    SUN_LEN(&amp;servaddr)) &lt; 0) /* Изменено вычисление 
        фактической длины адреса */
    {
        perror(NULL);
        close(sockfd);
        exit(1);
    }
    while(1) {
        clilen = sizeof(struct sockaddr_un); /* Изменено 
            вычисление максимальной длины для адреса
            клиента */
        if((n = recvfrom(sockfd, line, 999, 0, 
        (struct sockaddr *) &amp;cliaddr, &amp;clilen)) &lt; 0){
            perror(NULL);
            close(sockfd);
            exit(1);
        }
        if(sendto(sockfd, line, strlen(line), 0, 
        (struct sockaddr *) &amp;cliaddr, clilen) &lt; 0){
            perror(NULL);
            close(sockfd);
            exit(1);
        }
    }
    return 0;
}
</PRE><SPAN class="objectName">
            Листинг 
            15-16.5.
            Программа 15–16-5.c . A simple echo UNIX Domain datagram server</SPAN></DIV><A name="example.15-16.6"></A><DIV class="example"><PRE>
/* A simple echo UNIX Domain datagram client */
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/un.h&gt; /* Новый include-файл вместо 
    netinet/in.h и arpa/inet.h */
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
int main() /* Аргументы командной строки не нужны,
     так как сервис является локальным, и не нужно 
    указывать, к какой машине мы обращаемся с запросом */
{
    int sockfd;
    int n, len;
    char sendline[1000], recvline[1000];
    struct sockaddr_un servaddr, cliaddr; /* новый тип 
    данных под адреса сокетов */
    if((sockfd = socket(AF_UNIX, SOCK_DGRAM, 0)) &lt; 0) 
    /* Изменен тип семейства протоколов */
    {
        perror(NULL);
        exit(1);
    }
    bzero(&amp;cliaddr, sizeof(cliaddr));
    cliaddr.sun_family= AF_UNIX; /* Изменен тип 
        семейства протоколов и имя поля в структуре */
    strcpy(cliaddr.sun_path,"AAAA");/* Локальный адрес 
        сокета клиента – AAAA – в текущей директории */
    if(bind(sockfd, (struct sockaddr *) &amp;cliaddr, 
    SUN_LEN(&amp;cliaddr)) &lt; 0) /* Изменено вычисление 
        фактической длины адреса */
    {
        perror(NULL);
        close(sockfd);
        exit(1);
    }
    bzero(&amp;servaddr, sizeof(servaddr));
    servaddr.sun_family = AF_UNIX; /* Изменен тип 
        семейства протоколов и имя поля в структуре */
    strcpy(servaddr.sun_path,"BBBB"); /* Локальный адрес 
        сокета сервера – BBBB – в текущей директории */
    printf("String =&gt; ");
    fgets(sendline, 1000, stdin);
    if(sendto(sockfd, sendline, strlen(sendline)+1, 
    0, (struct sockaddr *) &amp;servaddr, 
    SUN_LEN(&amp;servaddr)) &lt; 0) /* Изменено вычисление 
        фактической длины адреса */
    {
        perror(NULL);
        close(sockfd);
        exit(1);
    }
    if((n = recvfrom(sockfd, recvline, 1000, 0, 
    (struct sockaddr *) NULL, NULL)) &lt; 0){
        perror(NULL);
        close(sockfd);
        exit(1);
    }
    recvline[n] = 0;
    printf("%s", recvline);
    close(sockfd);
    return 0;
}
</PRE><SPAN class="objectName">
            Листинг 
            15-16.6.
            Программа 15–16-6.c . A simple echo UNIX Domain datagram client.</SPAN></DIV><P id="id_499">Наберите программы, откомпилируйте их и убедитесь в работоспособности.</P><DIV class="lecture_mark" id="mark_499"></DIV><A name="sect27"></A><H3>Создание потоковых клиента и сервера для стека UNIX Domain протоколов </H3><P id="id_500">По аналогии с программами в предыдущем примере модифицируйте тексты программ TCP клиента и сервера для сервиса <SPAN class="texample">echo</SPAN> (<A href="http://www.intuit.ru/department/os/osintropractice/10/9.html#example.15-16.3">программа</A><SPAN class="texample">15–16-3.c</SPAN> и <A href="http://www.intuit.ru/department/os/osintropractice/10/10.html#example.15-16.4">программа</A><SPAN class="texample">15–16-4.c</SPAN>) для потокового общения в семействе <SPAN class="keyword">UNIX Domain протоколов</SPAN>. Откомпилируйте их и убедитесь в правильном функционировании.</P><DIV class="lecture_mark" id="mark_500"></DIV>


	</TD>
	</TR>
	<TR><TD height="8"><IMG src="./10. Семейство протоколов TCP-IP. Сокеты (sockets) в UNIX и основы работы с ними_files/empty.gif" width="1" height="8"></TD></TR>
	</TBODY></TABLE>
	<!-- /content -->

</TD>
<TD><IMG src="./10. Семейство протоколов TCP-IP. Сокеты (sockets) в UNIX и основы работы с ними_files/empty.gif" width="8" height="1"></TD>
</TR>
</TBODY></TABLE>
<!-- /bottom -->
<TABLE border="0" cellpadding="0" cellspacing="0" width="100%">
<TBODY><TR><TD class="orang" height="1"><IMG src="./10. Семейство протоколов TCP-IP. Сокеты (sockets) в UNIX и основы работы с ними_files/empty.gif" width="1" height="1"></TD></TR>
<TR><TD class="ltxt" align="center">© INTUIT.ru, 2003-2009. Все права защищены.</TD>
</TR>
</TBODY></TABLE>
<!-- /bottom -->

<SCRIPT src="./10. Семейство протоколов TCP-IP. Сокеты (sockets) в UNIX и основы работы с ними_files/urchin.js" type="text/javascript">
</SCRIPT>
<SCRIPT type="text/javascript">
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>


</BODY></HTML>