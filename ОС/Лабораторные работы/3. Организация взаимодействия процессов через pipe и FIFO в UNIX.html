
<!-- saved from url=(0075)http://www.intuit.ru/department/os/osintropractice/3/osintropractice_3.html -->
<HTML><HEAD><META http-equiv="Content-Type" content="text/html; charset=windows-1251">

<TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<LINK href="./3. Организация взаимодействия процессов через pipe и FIFO в UNIX_files/printable.css" type="text/css" rel="stylesheet">
</HEAD><BODY leftmargin="6" topmargin="6" marginheight="6" marginwidth="6">

<DIV align="left">
<SPAN style="color: #000000; font-weight: bold;">
&nbsp;&nbsp;
<SPAN style="font-size:12pt;">Интернет-Университет Информационных Технологий</SPAN>
</SPAN>
</DIV>

&nbsp;&nbsp;
<SPAN align="rright" style="color: #330066; text-decoration:underline;">http://www.INTUIT.ru</SPAN>


<TABLE border="0" cellpadding="0" cellspacing="0" width="100%">
<TBODY><TR><TD height="8" colspan="3"><IMG src="./3. Организация взаимодействия процессов через pipe и FIFO в UNIX_files/empty.gif" width="1" height="8"></TD></TR>
<TR><TD class="orang" height="1" colspan="3"><IMG src="./3. Организация взаимодействия процессов через pipe и FIFO в UNIX_files/empty.gif" width="1" height="1"></TD></TR>
<TR><TD height="8" colspan="3"><IMG src="./3. Организация взаимодействия процессов через pipe и FIFO в UNIX_files/empty.gif" width="1" height="8"></TD></TR>
<TR valign="top">
<TD><IMG src="./3. Организация взаимодействия процессов через pipe и FIFO в UNIX_files/empty.gif" width="8" height="1"></TD>
<TD>
	<!-- content -->
	<TABLE border="0" cellpadding="0" cellspacing="0" width="100%">
	<TBODY><TR><TD class="head">Основы операционных систем. Практикум</TD></TR>
<TR><TD height="4"><IMG src="./3. Организация взаимодействия процессов через pipe и FIFO в UNIX_files/empty.gif" width="1" height="4"></TD></TR>
	<TR><TD class="orang" height="1"><IMG src="./3. Организация взаимодействия процессов через pipe и FIFO в UNIX_files/empty.gif" width="1" height="1"></TD></TR>
	<TR><TD height="8"><IMG src="./3. Организация взаимодействия процессов через pipe и FIFO в UNIX_files/empty.gif" width="1" height="8"></TD></TR>
	<TR><TD><SPAN class="headsub">


3. Лекция:

 Организация взаимодействия процессов через pipe и FIFO в UNIX: версия для печати и PDA</SPAN>

<BR>
<SPAN class="rtxt">Понятие потока ввода-вывода. Представление о работе с файлами через системные вызовы и стандартную библиотеку ввода-вывода. Понятие файлового дескриптора. Открытие файла. Системный вызов open(). Системные вызовы close(), read(), write(). Понятие pipe. Системный вызов pipe(). Организация связи через pipe между процессом-родителем и процессом-потомком. Наследование файловых дескрипторов при вызовах fork() и exec(). Особенности поведения вызовов read() и write() для pip’а. Понятие FIFO. Использование системного вызова mknod() для создания FIFO. Функция mkfifo(). Особенности поведения вызова open() при открытии FIFO.
</SPAN>

</TD></TR>

	<TR><TD height="8"><IMG src="./3. Организация взаимодействия процессов через pipe и FIFO в UNIX_files/empty.gif" width="1" height="8"></TD></TR>
	<TR><TD class="orang" height="1"><IMG src="./3. Организация взаимодействия процессов через pipe и FIFO в UNIX_files/empty.gif" width="1" height="1"></TD></TR>
	<TR><TD height="8"><IMG src="./3. Организация взаимодействия процессов через pipe и FIFO в UNIX_files/empty.gif" width="1" height="8"></TD></TR>
	<TR><TD>


<A name="sect1"></A><H3>Понятие о потоке ввода-вывода </H3><P id="id_1">Среди всех категорий средств коммуникации наиболее употребительными являются каналы связи, обеспечивающие достаточно безопасное и достаточно информативное взаимодействие процессов. </P><DIV class="lecture_mark" id="mark_1"></DIV><P id="id_2">Существует две модели передачи данных по каналам связи – <SPAN class="keyword">поток ввода-вывода</SPAN> и сообщения. Из них более простой является потоковая модель, в которой операции передачи/приема информации вообще не интересуются содержимым того, что передается или принимается. Вся информация в канале связи рассматривается как непрерывный поток байт, не обладающий никакой внутренней структурой. Изучению механизмов, обеспечивающих потоковую передачу данных в операционной системе UNIX, и будет посвящен этот семинар.</P><DIV class="lecture_mark" id="mark_2"></DIV><A name="sect2"></A><H3>Понятие о работе с файлами через системные вызовы и стандартную библиотеку ввода-вывода для языка C </H3><P id="id_3">Потоковая передача информации может осуществляться не только между процессами, но и между процессом и устройством ввода-вывода, например между процессом и диском, на котором данные представляются в виде файла. Поскольку понятие файла должно быть знакомо изучающим этот курс, а системные вызовы, использующиеся для потоковой работы с файлом, во многом соответствуют системным вызовам, применяемым для потокового общения процессов, мы начнем наше рассмотрение именно с механизма потокового обмена между процессом и файлом.</P><DIV class="lecture_mark" id="mark_3"></DIV><P id="id_4">Как мы надеемся, из курса программирования на языке C вам известны функции работы с файлами из стандартной библиотеки ввода-вывода, такие как <SPAN class="texample">fopen()</SPAN>, <SPAN class="texample">fread()</SPAN>, <SPAN class="texample">fwrite()</SPAN>, <SPAN class="texample">fprintf()</SPAN>, <SPAN class="texample">fscanf()</SPAN>, <SPAN class="texample">fgets()</SPAN> и т.д. Эти функции входят как неотъемлемая часть в стандарт ANSI на язык C и позволяют программисту получать информацию из файла или записывать ее в файл при условии, что программист обладает определенными знаниями о содержимом передаваемых данных. Так, например, функция <SPAN class="texample">fgets()</SPAN> используется для ввода из файла последовательности символов, заканчивающейся символом <SPAN class="texample">'\n'</SPAN> – перевод каретки. Функция <SPAN class="texample">fscanf()</SPAN> производит ввод информации, соответствующей заданному формату, и т. д. С точки зрения потоковой модели операции, определяемые функциями стандартной 
библиотеки ввода-вывода, не являются потоковыми операциями, так как каждая из них требует наличия некоторой структуры передаваемых данных.</P><DIV class="lecture_mark" id="mark_4"></DIV><P id="id_14">В операционной системе UNIX эти функции представляют собой надстройку – сервисный интерфейс – над системными вызовами, осуществляющими прямые потоковые операции обмена информацией между процессом и файлом и не требующими никаких знаний о том, что она содержит. Чуть позже мы кратко познакомимся с системными вызовами <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN>, <SPAN class="texample"><SPAN class="keyword">read()</SPAN></SPAN>, <SPAN class="texample"><SPAN class="keyword">write()</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">close()</SPAN></SPAN>, которые применяются для такого обмена, но сначала нам нужно ввести еще одно понятие – понятие <SPAN class="keyword">файлового дескриптора</SPAN>. </P><DIV class="lecture_mark" id="mark_14"></DIV><A name="sect3"></A><H3>Файловый дескриптор</H3><P id="id_19">На лекции 2 мы говорили, что информация о файлах, используемых процессом, входит в состав его системного контекста и хранится в его блоке управления – PCB. В операционной системе UNIX можно упрощенно полагать, что <A name="keyword-context.1"></A><A name="keyword-context.2"></A>информация о файлах, с которыми процесс осуществляет операции потокового обмена, наряду с информацией о потоковых линиях связи, соединяющих процесс с другими процессами и устройствами ввода-вывода, хранится в некотором массиве, получившем название <SPAN class="keyword_def">таблицы открытых файлов</SPAN> или таблицы <SPAN class="keyword">файловых дескрипторов</SPAN>. Индекс элемента этого массива, соответствующий определенному <SPAN class="keyword">потоку ввода-вывода</SPAN>, получил название <SPAN class="keyword_def">файлового дескриптора</SPAN> для этого потока. Таким образом, <SPAN class="keyword">файловый дескриптор</SPAN> представляет собой небольшое целое неотрицательное число, 
которое для текущего процесса в данный момент времени однозначно определяет некоторый действующий канал ввода-вывода. Некоторые <SPAN class="keyword">файловые дескрипторы</SPAN> на этапе старта любой программы ассоциируются со стандартными <SPAN class="keyword">потоками ввода-вывода</SPAN>. Так, например, <SPAN class="keyword">файловый дескриптор</SPAN>  0 соответствует <SPAN class="keyword">стандартному потоку ввода</SPAN>, <SPAN class="keyword">файловый дескриптор</SPAN> 1 – <SPAN class="keyword">стандартному потоку вывода</SPAN>, <SPAN class="keyword">файловый дескриптор</SPAN> 2 – <SPAN class="keyword">стандартному потоку для вывода ошибок</SPAN>. <A name="keyword-context.3"></A><A name="keyword-context.4"></A><A name="keyword-context.5"></A>В нормальном интерактивном режиме работы <SPAN class="keyword_def">стандартный поток ввода</SPAN> связывает процесс с клавиатурой, а 
<SPAN class="keyword_def">стандартные потоки вывода</SPAN> и <SPAN class="keyword_def">вывода ошибок</SPAN> – с текущим терминалом.</P><DIV class="lecture_mark" id="mark_19"></DIV><P id="id_20">Более детально строение структур данных, содержащих информацию о <SPAN class="keyword">потоках ввода-вывода</SPAN>, ассоциированных с процессом, мы будем рассматривать позже, при изучении организации файловых систем в UNIX (семинары 11–12 и 13–14). </P><DIV class="lecture_mark" id="mark_20"></DIV><A name="sect4"></A><H3>Открытие файла. Системный вызов open()</H3><P id="id_21"><SPAN class="keyword">Файловый дескриптор</SPAN> используется в качестве параметра, описывающего <SPAN class="keyword">поток ввода-вывода</SPAN>, для системных вызовов, выполняющих операции над этим потоком. Поэтому прежде чем совершать операции чтения данных из файла и записи их в файл, мы должны поместить информацию о файле в <SPAN class="keyword">таблицу открытых файлов</SPAN> и определить соответствующий <SPAN class="keyword">файловый дескриптор</SPAN>. Для этого применяется процедура <SPAN class="keyword">открытия файла</SPAN>, осуществляемая системным вызовом <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN>. </P><DIV class="lecture_mark" id="mark_21"></DIV><DIV class="xml_table_env" id="id_23"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_24"><B>Системный вызов open</B></P><DIV class="lecture_mark" id="mark_24"></DIV>

<P id="id_25"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_25"></DIV>

<DIV class="example"><PRE>#include &lt;fcntl.h&gt;
int open(char *path, int flags);
int open(char *path, int flags, int mode);
</PRE></DIV>

<P id="id_27"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_27"></DIV>

<P id="id_28">Системный вызов <SPAN class="texample"><SPAN class="keyword">open</SPAN></SPAN> предназначен для выполнения операции открытия файла и, в случае ее удачного осуществления, возвращает файловый дескриптор открытого файла (небольшое неотрицательное целое число, которое используется в дальнейшем для других операций с этим файлом).</P><DIV class="lecture_mark" id="mark_28"></DIV>

<P id="id_30">Параметр <SPAN class="texample">path</SPAN> является указателем на строку, содержащую полное или относительное имя файла.</P><DIV class="lecture_mark" id="mark_30"></DIV>

<P id="id_32">Параметр <SPAN class="texample">flags</SPAN> может принимать одно из следующих трех значений:</P><DIV class="lecture_mark" id="mark_32"></DIV>

<UL id="id_34"><LI><SPAN class="texample">O_RDONLY</SPAN> – если над файлом в дальнейшем будут совершаться только операции чтения;</LI><LI><SPAN class="texample">O_WRONLY</SPAN> – если над файлом в дальнейшем будут осуществляться только операции записи;</LI><LI><SPAN class="texample">O_RDWR</SPAN> – если над файлом будут осуществляться и операции чтения, и операции записи.</LI></UL><DIV class="lecture_mark" id="mark_34"></DIV>

<P id="id_41">Каждое из этих значений может быть скомбинировано посредством операции "побитовое или ( | )" с одним или несколькими флагами:</P><DIV class="lecture_mark" id="mark_41"></DIV>

<UL id="id_42"><LI><SPAN class="texample">O_CREAT</SPAN> – если файла с указанным именем не существует, он должен быть создан;</LI><LI><SPAN class="texample">O_EXCL</SPAN> – применяется совместно с флагом <SPAN class="texample">O_CREAT</SPAN>. При совместном их использовании и существовании файла с указанным именем, открытие файла не производится и констатируется ошибочная ситуация;</LI><LI><SPAN class="texample">O_NDELAY</SPAN> – запрещает перевод процесса в состояние ожидание при выполнении операции открытия и любых последующих операциях над этим файлом;</LI><LI><SPAN class="texample">O_APPEND</SPAN> – при открытии файла и перед выполнением каждой операции записи (если она, конечно, разрешена) указатель текущей позиции в файле устанавливается на конец файла;</LI><LI><SPAN class="texample">O_TRUNC</SPAN> – если файл существует, уменьшить его размер до <SPAN class="texample">0</SPAN>, с сохранением существующих атрибутов файла, кроме, быть может, времен последнего доступа к файлу и его последней модификации.</LI></UL><DIV class="lecture_mark" id="mark_42"></DIV>

<P id="id_55">Кроме того, в некоторых версиях операционной системы UNIX могут применяться дополнительные значения флагов:</P><DIV class="lecture_mark" id="mark_55"></DIV>

<UL id="id_56"><LI><SPAN class="texample">O_SYNC</SPAN> – любая операция записи в файл будет блокироваться (т. е. процесс будет переведен в состояние ожидание) до тех пор, пока записанная информация не будет физически помещена на соответсвующий нижележащий уровень hardware;</LI><LI><SPAN class="texample">O_NOCTTY</SPAN> – если имя файла относится к терминальному устройству, оно не становится управляющим терминалом процесса, даже если до этого процесс не имел управляющего терминала.</LI></UL><DIV class="lecture_mark" id="mark_56"></DIV>

<P id="id_61">Параметр <SPAN class="texample">mode</SPAN> устанавливает атрибуты прав доступа различных категорий пользователей к новому файлу при его создании. Он обязателен, если среди заданных флагов присутствует флаг <SPAN class="texample">O_CREAT</SPAN>, и может быть опущен в противном случае. Этот параметр задается как сумма следующих восьмеричных значений:</P><DIV class="lecture_mark" id="mark_61"></DIV>

<UL id="id_64"><LI><SPAN class="texample">0400</SPAN> – разрешено чтение для пользователя, создавшего файл;</LI><LI><SPAN class="texample">0200</SPAN> – разрешена запись для пользователя, создавшего файл;</LI><LI><SPAN class="texample">0100</SPAN> – разрешено исполнение для пользователя, создавшего файл;</LI><LI><SPAN class="texample">0040</SPAN> – разрешено чтение для группы пользователя, создавшего файл;</LI><LI><SPAN class="texample">0020</SPAN> – разрешена запись для группы пользователя, создавшего файл;</LI><LI><SPAN class="texample">0010</SPAN> – разрешено исполнение для группы пользователя, создавшего файл;</LI><LI><SPAN class="texample">0004</SPAN> – разрешено чтение для всех остальных пользователей;</LI><LI><SPAN class="texample">0002</SPAN> – разрешена запись для всех остальных пользователей;</LI><LI><SPAN class="texample">0001</SPAN> – разрешено исполнение для всех остальных пользователей.</LI></UL><DIV class="lecture_mark" id="mark_64"></DIV>

<P id="id_83">При создании файла реально устанавливаемые права доступа получаются из стандартной комбинации параметра <SPAN class="texample">mode</SPAN> и маски создания файлов текущего процесса <SPAN class="texample">umask</SPAN>, а именно – они равны <SPAN class="texample">mode &amp; ~umask</SPAN>.</P><DIV class="lecture_mark" id="mark_83"></DIV>

<P id="id_87">При открытии файлов типа FIFO системный вызов имеет некоторые особенности поведения по сравнению с открытием файлов других типов. Если FIFO открывается только для чтения, и не задан флаг <SPAN class="texample">O_NDELAY</SPAN>, то процесс, осуществивший системный вызов, блокируется до тех пор, пока какой-либо другой процесс не откроет FIFO на запись. Если флаг <SPAN class="texample">O_NDELAY</SPAN> задан, то возвращается значение файлового дескриптора, ассоциированного с FIFO. Если FIFO открывается только для записи, и не задан флаг <SPAN class="texample">O_NDELAY</SPAN>, то процесс, осуществивший системный вызов, блокируется до тех пор, пока какой-либо другой процесс не откроет FIFO на чтение. Если флаг <SPAN class="texample">O_NDELAY</SPAN> задан, то констатируется возникновение ошибки и возвращается значение <SPAN class="texample">-1</SPAN>.</P><DIV class="lecture_mark" id="mark_87"></DIV>

<P id="id_93"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_93"></DIV>

<P id="id_94">Системный вызов возвращает значение файлового дескриптора для открытого файла при нормальном завершении и значение <SPAN class="texample">-1</SPAN> при возникновении ошибки.</P><DIV class="lecture_mark" id="mark_94"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_23"></DIV><P id="id_96">Системный вызов <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN> использует набор флагов для того, чтобы специфицировать операции, которые предполагается применять к файлу в дальнейшем или которые должны быть выполнены непосредственно в момент <SPAN class="keyword">открытия файла</SPAN>. Из всего возможного набора флагов на текущем уровне знаний нас будут интересовать только флаги <SPAN class="texample">O_RDONLY</SPAN>, <SPAN class="texample">O_WRONLY</SPAN>, <SPAN class="texample">O_RDWR</SPAN>, <SPAN class="texample">O_CREAT</SPAN> и <SPAN class="texample">O_EXCL</SPAN>. Первые три флага являются взаимоисключающими: хотя бы один из них должен быть применен и наличие одного из них не допускает наличия двух других. Эти флаги описывают набор операций, которые, при успешном <SPAN class="keyword">открытии файла</SPAN>, будут разрешены над файлом в дальнейшем: только чтение, только запись, чтение и запись. Как вам известно из материалов семинаров 1-2, у каждого файла существуют атрибуты прав доступа для различных категорий пользователей. Если файл с заданным именем существует на диске, и права доступа к нему для пользователя, от имени которого работает текущий процесс, не противоречат запрошенному набору операций, то операционная система сканирует <SPAN class="keyword">таблицу открытых файлов</SPAN> от ее начала к концу в поисках первого свободного элемента, заполняет его и возвращает индекс этого элемента в качестве <SPAN class="keyword">файлового дескриптора</SPAN> открытого файла. Если файла на диске нет, не хватает прав или отсутствует свободное место в <SPAN class="keyword">таблице открытых файлов</SPAN>, то констатируется возникновение ошибки. </P><DIV class="lecture_mark" id="mark_96"></DIV><P id="id_103">В случае, когда мы <B>допускаем</B>, что файл на диске может отсутствовать, и хотим, чтобы он был создан, флаг для набора операций должен использоваться в комбинации с флагом <SPAN class="texample">O_CREAT</SPAN>. Если файл существует, то все происходит по рассмотренному выше сценарию. Если файла нет, сначала выполняется создание файла с набором прав, указанным в параметрах системного вызова. Проверка соответствия набора операций объявленным правам доступа может и не производиться (как, например, в Linux).</P><DIV class="lecture_mark" id="mark_103"></DIV><P id="id_105">В случае, когда мы <B>требуем</B>, чтобы файл на диске отсутствовал и был создан в момент открытия, флаг для набора операций должен использоваться в комбинации с флагами <SPAN class="texample">O_CREAT</SPAN> и <SPAN class="texample">O_EXCL</SPAN>. </P><DIV class="lecture_mark" id="mark_105"></DIV><P id="id_108">Подробнее об операции <SPAN class="keyword">открытия файла</SPAN> и ее месте среди набора всех файловых операций будет рассказываться на лекции 7 "Файловая система с точки зрения пользователя". Работу системного вызова <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN> с флагами <SPAN class="texample">O_APPEND</SPAN> и <SPAN class="texample">O_TRUNC</SPAN> мы разберем на семинарах 11–12, посвященных организации файловых систем в UNIX.</P><DIV class="lecture_mark" id="mark_108"></DIV><A name="sect5"></A><H3>Системные вызовы read(), write(), close()</H3><P id="id_112"><A name="keyword-context.6"></A><A name="keyword-context.7"></A>Для совершения потоковых операций чтения информации из файла и ее записи в файл применяются системные вызовы <SPAN class="texample"><SPAN class="keyword_def">read()</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword_def">write()</SPAN></SPAN>. </P><DIV class="lecture_mark" id="mark_112"></DIV><DIV class="xml_table_env" id="id_115"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_116"><B>Системные вызовы read и write</B></P><DIV class="lecture_mark" id="mark_116"></DIV>

<P id="id_117"><B>Прототипы системных вызовов</B></P><DIV class="lecture_mark" id="mark_117"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
size_t read(int fd, void *addr, 
            size_t nbytes);
size_t write(int fd, void *addr, 
             size_t nbytes);
</PRE></DIV>

<P id="id_119"><B>Описание системных вызовов</B></P><DIV class="lecture_mark" id="mark_119"></DIV>

<P id="id_120">Системные вызовы <SPAN class="texample"><SPAN class="keyword">read</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">write</SPAN></SPAN> предназначены для осуществления потоковых операций ввода (чтения) и вывода (записи) информации над каналами связи, описываемыми файловыми дескрипторами, т.е. для файлов, pipe, FIFO и socket.</P><DIV class="lecture_mark" id="mark_120"></DIV>

<P id="id_123">Параметр <SPAN class="texample">fd</SPAN> является файловым дескриптором созданного ранее потокового канала связи, через который будет отсылаться или получаться информация, т. е. значением, которое вернул один из системных вызовов <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN>, <SPAN class="texample">pipe()</SPAN> или <SPAN class="texample">socket()</SPAN>.</P><DIV class="lecture_mark" id="mark_123"></DIV>

<P id="id_128">Параметр <SPAN class="texample">addr</SPAN> представляет собой адрес области памяти, начиная с которого будет браться информация для передачи или размещаться принятая информация.</P><DIV class="lecture_mark" id="mark_128"></DIV>

<P id="id_130">Параметр <SPAN class="texample">nbytes</SPAN> для системного вызова <SPAN class="texample"><SPAN class="keyword">write</SPAN></SPAN> определяет количество байт, которое должно быть передано, начиная с адреса памяти <SPAN class="texample">addr</SPAN>. Параметр <SPAN class="texample">nbytes</SPAN> для системного вызова <SPAN class="texample"><SPAN class="keyword">read</SPAN></SPAN> определяет количество байт, которое мы хотим получить из канала связи и разместить в памяти, начиная с адреса <SPAN class="texample">addr</SPAN>.</P><DIV class="lecture_mark" id="mark_130"></DIV>

<P id="id_137"><B>Возвращаемые значения</B></P><DIV class="lecture_mark" id="mark_137"></DIV>

<P id="id_138">В случае успешного завершения системный вызов возвращает количество реально посланных или принятых байт. Заметим, что это значение (большее или равное <SPAN class="texample">0</SPAN>) может не совпадать с заданным значением параметра <SPAN class="texample">nbytes</SPAN>, а быть меньше, чем оно, в силу отсутствия места на диске или в линии связи при передаче данных или отсутствия информации при ее приеме. При возникновении какой-либо ошибки возвращается отрицательное значение.</P><DIV class="lecture_mark" id="mark_138"></DIV>

<P id="id_141"><B>Особенности поведения при работе с файлами</B></P><DIV class="lecture_mark" id="mark_141"></DIV>

<P id="id_142">При работе с файлами информация записывается в файл или читается из файла, начиная с места, определяемого указателем текущей позиции в файле. Значение указателя увеличивается на количество реально прочитанных или записанных байт. При чтении информации из файла она не пропадает из него. Если системный вызов <SPAN class="texample"><SPAN class="keyword">read</SPAN></SPAN> возвращает значение <SPAN class="texample">0</SPAN>, то это означает, что файл прочитан до конца.</P><DIV class="lecture_mark" id="mark_142"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_115"></DIV><P id="id_145">Мы сейчас не акцентируем внимание на понятии указателя текущей позиции в файле и взаимном влиянии значения этого указателя и поведения системных вызовов. Этот вопрос будет обсуждаться в дальнейшем на семинарах 11–12.</P><DIV class="lecture_mark" id="mark_145"></DIV><P id="id_146">После завершения потоковых операций процесс должен выполнить операцию закрытия <SPAN class="keyword">потока ввода-вывода</SPAN>, во время которой произойдет окончательный сброс буферов на линии связи, освободятся выделенные ресурсы операционной системы, и элемент <SPAN class="keyword">таблицы открытых файлов</SPAN>, соответствующий <SPAN class="keyword">файловому дескриптору</SPAN>, будет отмечен как свободный. За эти действия отвечает системный вызов <SPAN class="texample"><SPAN class="keyword">close()</SPAN></SPAN>. Надо отметить, что при завершении работы процесса (см. семинар 3–4) с помощью явного или неявного вызова функции <SPAN class="texample">exit()</SPAN> происходит автоматическое закрытие всех открытых <SPAN class="keyword">потоков ввода-вывода</SPAN>.</P><DIV class="lecture_mark" id="mark_146"></DIV><DIV class="xml_table_env" id="id_149"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_150"><B>Системный вызов close</B></P><DIV class="lecture_mark" id="mark_150"></DIV>

<P id="id_151"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_151"></DIV>

<DIV class="example"><PRE>#include &lt;unistd.h&gt;
int close(int fd);
</PRE></DIV>

<P id="id_153"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_153"></DIV>

<P id="id_154">Системный вызов <SPAN class="texample"><SPAN class="keyword">close</SPAN></SPAN> предназначен для корректного завершения работы с файлами и другими объектами ввода-вывода, которые описываются в операционной системе через файловые дескрипторы: pipe, FIFO, socket.</P><DIV class="lecture_mark" id="mark_154"></DIV>

<P id="id_156">Параметр <SPAN class="texample">fd</SPAN> является дескриптором соответствующего объекта, т. е. значением, которое вернул один из системных вызовов <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN>, <SPAN class="texample">pipe()</SPAN> или <SPAN class="texample">socket()</SPAN>.</P><DIV class="lecture_mark" id="mark_156"></DIV>

<P id="id_161"><B>Возвращаемые значения</B></P><DIV class="lecture_mark" id="mark_161"></DIV>

<P id="id_162">Системный вызов возвращает значение <SPAN class="texample">0</SPAN> при нормальном завершении и значение <SPAN class="texample">-1</SPAN> при возникновении ошибки.</P><DIV class="lecture_mark" id="mark_162"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_149"></DIV><A name="sect6"></A><H3>Прогон программы для записи информации в файл</H3><P id="id_165">Для иллюстрации сказанного давайте рассмотрим следующую программу:</P><DIV class="lecture_mark" id="mark_165"></DIV><A name="example.5.1"></A><DIV class="example"><PRE>/*Программа 05-1.с, иллюстрирующая использование системных вызовов 
open(), write() и close() для записи информации в файл */ 
#include &lt;sys/types.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
int main(){
    int fd; 
    size_t size;
    char string[] = "Hello, world!";
    /* Обнуляем маску создания файлов текущего процесса для того, 
    чтобы права доступа у создаваемого файла точно соответствовали 
    чпараметру вызова open() */
    (void)umask(0); 
    /* Попытаемся открыть файл с именем myfile в текущей директории
     только для операций вывода. Если файла не существует, попробуем
     его создать с правами доступа 0666, т. е. read-write для всех
     категорий пользователей */
    if((fd = open("myfile", O_WRONLY | O_CREAT, 
        0666)) &lt; 0){
        /* Если файл открыть не удалось, печатаем об этом сообщение 
        и прекращаем работу */
        printf("Can\'t open file\n");
        exit(-1); 
    } 
    /* Пробуем записать в файл 14 байт из нашего массива, т.е. всю 
    строку "Hello, world!" вместе с признаком конца 
строки */
    size = write(fd, string, 14);
    if(size != 14){
        /* Если записалось меньшее количество байт, сообщаем об 
        ошибке */
        printf("Can\'t write all string\n"); 
        exit(-1); 
    } 
    /* Закрываем файл */
    if(close(fd) &lt; 0){ 
        printf("Can\'t close file\n");
    }
    return 0; 
} 
</PRE><SPAN class="objectName">
            Листинг 
            5.1.
            Программа 05-1.с, иллюстрирующая использование системных вызовов  open(), write() и close() для записи информации в файл</SPAN></DIV><P id="id_167">Наберите, откомпилируйте эту программу и запустите ее на исполнение. Обратите внимание на использование системного вызова <SPAN class="texample">umask()</SPAN> с параметром <SPAN class="texample">0</SPAN> для того, чтобы права доступа к созданному файлу точно соответствовали указанным в системном вызове <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN>. </P><DIV class="lecture_mark" id="mark_167"></DIV><A name="sect7"></A><H3>Написание, компиляция и запуск программы для чтения информации из файла</H3><P id="id_171">Измените программу из предыдущего раздела так, чтобы она читала записанную ранее в файл информацию и печатала ее на экране. Все лишние операторы желательно удалить.</P><DIV class="lecture_mark" id="mark_171"></DIV><A name="sect8"></A><H3>Понятие о pipe. Системный вызов pipe()</H3><P id="id_172"><A name="keyword-context.8"></A>Наиболее простым способом для передачи информации с помощью потоковой модели между различными процессами или даже внутри одного процесса в операционной системе UNIX является <SPAN class="texample"><SPAN class="keyword_def">pipe</SPAN></SPAN> (канал, труба, конвейер). </P><DIV class="lecture_mark" id="mark_172"></DIV><P id="id_174"><B>Важное отличие pip’а от файла заключается в том, что прочитанная информация немедленно удаляется из него и не может быть прочитана повторно. </B></P><DIV class="lecture_mark" id="mark_174"></DIV><P id="id_175"><A name="keyword-context.9"></A><SPAN class="texample"><SPAN class="keyword">Pipe</SPAN></SPAN> можно представить себе в виде трубы ограниченной емкости, расположенной внутри адресного пространства операционной системы, доступ к входному и выходному отверстию которой осуществляется с помощью системных вызовов. В действительности <SPAN class="texample"><SPAN class="keyword">pipe</SPAN></SPAN> представляет собой область памяти, недоступную пользовательским процессам напрямую, зачастую организованную в виде кольцевого буфера (хотя существуют и другие виды организации). По буферу при операциях чтения и записи перемещаются два указателя, соответствующие входному и выходному потокам. При этом выходной указатель никогда не может перегнать входной и наоборот. Для создания нового экземпляра такого кольцевого буфера внутри операционной системы используется системный вызов <SPAN class="texample"><SPAN class="keyword">pipe</SPAN>()</SPAN>. </P><DIV class="lecture_mark" id="mark_175"></DIV><DIV class="xml_table_env" id="id_179"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_180"><B>Системный вызов pipe</B></P><DIV class="lecture_mark" id="mark_180"></DIV>

<P id="id_181"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_181"></DIV>

<DIV class="example"><PRE>#include &lt;unistd.h&gt;
int pipe(int *fd);
</PRE></DIV>

<P id="id_183"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_183"></DIV>

<P id="id_184">Системный вызов <SPAN class="texample">pipe</SPAN> предназначен для создания pip'а внутри операционной системы. </P><DIV class="lecture_mark" id="mark_184"></DIV>

<P id="id_186">Параметр <SPAN class="texample">fd</SPAN> является указателем на массив из двух целых переменных. При нормальном завершении вызова в первый элемент массива – <SPAN class="texample">fd[0]</SPAN> – будет занесен файловый дескриптор, соответствующий выходному потоку данных pip’а и позволяющий выполнять только операцию чтения, а во второй элемент массива – <SPAN class="texample">fd[1]</SPAN> – будет занесен файловый дескриптор, соответствующий входному потоку данных и позволяющий выполнять только операцию записи.</P><DIV class="lecture_mark" id="mark_186"></DIV>

<P id="id_190"><B>Возвращаемые значения</B></P><DIV class="lecture_mark" id="mark_190"></DIV>

<P id="id_191">Системный вызов возвращает значение <SPAN class="texample">0</SPAN> при нормальном завершении и значение <SPAN class="texample">-1</SPAN> при возникновении ошибок.</P><DIV class="lecture_mark" id="mark_191"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_179"></DIV><P id="id_194">В процессе работы системный вызов организует выделение области памяти под буфер и указатели и заносит информацию, соответствующую входному и выходному потокам данных, в два элемента <SPAN class="keyword">таблицы открытых файлов</SPAN>, связывая тем самым с каждым pip’ом два <SPAN class="keyword">файловых дескриптора</SPAN>. Для одного из них разрешена только операция чтения из pip’а, а для другого – только операция записи в <SPAN class="texample"><SPAN class="keyword">pipe</SPAN></SPAN>. Для выполнения этих операций мы можем использовать те же самые системные вызовы <SPAN class="texample"><SPAN class="keyword">read()</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">write()</SPAN></SPAN>, что и при работе с файлами. Естественно, по окончании использования входного или/и выходного потока данных, нужно закрыть соответствующий поток с помощью системного вызова <SPAN class="texample"><SPAN class="keyword">close()</SPAN></SPAN> для освобождения системных ресурсов. Необходимо отметить, что, когда все процессы, использующие <SPAN class="texample"><SPAN class="keyword">pipe</SPAN></SPAN>, закрывают все ассоциированные с ним <SPAN class="keyword">файловые дескрипторы</SPAN>, операционная система ликвидирует <SPAN class="texample"><SPAN class="keyword">pipe</SPAN></SPAN>. Таким образом, время существования pip’а в системе не может превышать время жизни процессов, работающих с ним. </P><DIV class="lecture_mark" id="mark_194"></DIV><A name="sect9"></A><H3>Прогон программы для pipe в одном процессе</H3><P id="id_201">Достаточно яркой иллюстрацией действий по созданию pip'a, записи в него данных, чтению из него и освобождению выделенных ресурсов может служить программа, организующая работу с pip’ом в рамках одного процесса, приведенная ниже:</P><DIV class="lecture_mark" id="mark_201"></DIV><A name="example.5.2"></A><DIV class="example"><PRE>/* Программа 05-2.с, иллюстрирующая работу с pip'ом в рамках одного 
процесса */ 
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
int main(){
    int fd[2]; 
    size_t size;
    char string[] = "Hello, world!";
    char resstring[14]; 
    /* Попытаемся создать pipe */
    if(pipe(fd) &lt; 0){
        /* Если создать pipe не удалось, печатаем об этом сообщение 
        и прекращаем работу */
        printf("Can\'t create pipe\n");
        exit(-1); 
    }
    /* Пробуем записать в pipe 14 байт из нашего массива, т.е. всю
    строку "Hello, world!" вместе с признаком конца строки */
    size = write(fd[1], string, 14);
    if(size != 14){
        /* Если записалось меньшее количество байт, сообщаем об 
        ошибке */
        printf("Can\'t write all string\n"); 
        exit(-1); 
    } 
    /* Пробуем прочитать из pip'а 14 байт в другой массив, т.е. всю 
    записанную строку */
    size = read(fd[0], resstring, 14);
    if(size &lt; 0){
        /* Если прочитать не смогли, сообщаем об ошибке */
        printf("Can\'t read string\n"); 
        exit(-1); 
    } 
    /* Печатаем прочитанную строку */
    printf("%s\n",resstring);
    /* Закрываем входной поток*/
    if(close(fd[0]) &lt; 0){ 
        printf("Can\'t close input stream\n");
    }
    /* Закрываем выходной поток*/
    if(close(fd[1]) &lt; 0){ 
        printf("Can\'t close output stream\n");
    }
    return 0; 
} 
</PRE><SPAN class="objectName">
            Листинг 
            5.2.
            Программа 05-2.с, иллюстрирующая работу с pip'ом в рамках одного процесса</SPAN></DIV><P id="id_203">Наберите программу, откомпилируйте ее и запустите на исполнение.</P><DIV class="lecture_mark" id="mark_203"></DIV><A name="sect10"></A><H3>Организация связи через pipe между процессом-родителем и процессом-потомком. Наследование файловых дескрипторов при вызовах fork() и exec()</H3><P id="id_204">Понятно, что если бы все достоинство pip'ов сводилось к замене функции копирования из памяти в память внутри одного процесса на пересылку информации через операционную систему, то овчинка не стоила бы выделки. Однако <SPAN class="keyword">таблица открытых файлов</SPAN> наследуется процессом-ребенком при порождении нового процесса системным вызовом <SPAN class="texample">fork()</SPAN> и входит в состав неизменяемой части системного контекста процесса при системном вызове <SPAN class="texample">exec()</SPAN> (за исключением тех потоков данных, для <SPAN class="keyword">файловых дескрипторов</SPAN> которых был специальными средствами выставлен признак, побуждающий операционную систему закрыть их при выполнении <SPAN class="texample">exec()</SPAN>, однако их рассмотрение выходит за рамки нашего курса). Это обстоятельство позволяет организовать передачу информации через <SPAN class="texample"><SPAN class="keyword">pipe</SPAN></SPAN> между родственными процессами, имеющими общего прародителя, создавшего <SPAN class="texample"><SPAN class="keyword">pipe</SPAN></SPAN>.</P><DIV class="lecture_mark" id="mark_204"></DIV><A name="sect11"></A><H3>Прогон программы для организации однонаправленной связи между родственными процессами через pipe </H3><P id="id_210">Давайте рассмотрим программу, осуществляющую однонаправленную связь между процессом-родителем и процессом-ребенком:</P><DIV class="lecture_mark" id="mark_210"></DIV><A name="example.5.3"></A><DIV class="example"><PRE>/* Программа 05-3.с, осуществляющая однонаправленную связь через pipe 
между процессом-родителем и процессом-ребенком */ 
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
int main(){
    int fd[2], result;
    size_t size;
    char resstring[14]; 
    /* Попытаемся создать pipe */
    if(pipe(fd) &lt; 0){
        /* Если создать pipe не удалось, печатаем об этом сообщение
        и прекращаем работу */
        printf("Can\'t create pipe\n");
        exit(-1); 
    } 
    /* Порождаем новый процесс */ 
    result = fork(); 
    if(result){ 
        /* Если создать процесс не удалось, сообщаем об этом и 
        завершаем работу */
        printf("Can\'t fork child\n");
        exit(-1);
    } else if (result &gt; 0) {
        /* Мы находимся в родительском процессе, который будет 
        передавать информацию процессу-ребенку. В этом процессе
        выходной поток данных нам не понадобится, поэтому 
        закрываем его.*/
        close(fd[0]);
        /* Пробуем записать в pipe 14 байт, т.е. всю строку 
        "Hello, world!" вместе с признаком конца строки */
        size = write(fd[1], "Hello, world!", 14);
        if(size != 14){
            /* Если записалось меньшее количество байт, сообщаем
            об ошибке и завершаем работу */
            printf("Can\'t write all string\n"); 
            exit(-1); 
        } 
        /* Закрываем входной поток данных, на этом 
        родитель прекращает работу */
        close(fd[1]);
        printf("Parent exit\n");
    } else {
        /* Мы находимся в порожденном процессе, который будет 
        получать информацию от процесса-родителя. Он унаследовал
        от родителя таблицу открытых файлов и, зная файловые 
        дескрипторы, соответствующие pip, иможет его использовать.
        В этом процессе входной поток данных нам не 
        ипонадобится, поэтому закрываем его.*/
        close(fd[1]);
        /* Пробуем прочитать из pip'а 14 байт в массив, т.е. всю
        записанную строку */
        size = read(fd[0], resstring, 14);
        if(size &lt; 0){

            /* Если прочитать не смогли, сообщаем об ошибке и
            завершаем работу */

            printf("Can\'t read string\n"); 
            exit(-1); 
        } 
        /* Печатаем прочитанную строку */
        printf("%s\n",resstring);
        /* Закрываем входной поток и завершаем работу */
        close(fd[0]);
    }    
    return 0; 
}
</PRE><SPAN class="objectName">
            Листинг 
            5.3.
            Программа 05-3.с, осуществляющая однонаправленную связь через pipe  между процессом-родителем и процессом-ребенком</SPAN></DIV><P id="id_212">Наберите программу, откомпилируйте ее и запустите на исполнение.</P><DIV class="lecture_mark" id="mark_212"></DIV><P id="id_213"><B>Задача повышенной сложности</B>: модифицируйте этот пример для связи между собой двух родственных процессов, исполняющих разные программы. </P><DIV class="lecture_mark" id="mark_213"></DIV><A name="sect12"></A><H3>Написание, компиляция и запуск программы для организации двунаправленной связи между родственными процессами через pipe</H3><P id="id_214"><SPAN class="texample"><SPAN class="keyword">Pipe</SPAN></SPAN> служит для организации однонаправленной или симплексной связи. Если бы в предыдущем примере мы попытались организовать через <SPAN class="texample"><SPAN class="keyword">pipe</SPAN></SPAN> двустороннюю связь, когда процесс-родитель пишет информацию в <SPAN class="texample"><SPAN class="keyword">pipe</SPAN></SPAN>, предполагая, что ее получит процесс-ребенок, а затем читает информацию из pip’а, предполагая, что ее записал порожденный процесс, то могла бы возникнуть ситуация, в которой процесс-родитель прочитал бы собственную информацию, а процесс-ребенок не получил бы ничего. Для использования одного pip’а в двух направлениях необходимы специальные средства синхронизации процессов, о которых речь идет в лекциях "Алгоритмы синхронизации" (лекция 5) и "Механизмы синхронизации" (лекция 6). Более простой способ организации двунаправленной связи между родственными процессами заключается в использовании двух pipe. Модифицируйте программу из предыдущего примера (раздел "Прогон программы для организации однонаправленной связи между родственными процессами через <SPAN class="texample"><SPAN class="keyword">pipe</SPAN></SPAN>") для организации такой двусторонней связи, откомпилируйте ее и запустите на исполнение.</P><DIV class="lecture_mark" id="mark_214"></DIV><P id="id_219">Необходимо отметить, что в некоторых UNIX-подобных системах (например, в Solaris2) реализованы полностью дуплексные pip’ы <A target="_blank" href="http://www.intuit.ru/department/os/osintropractice/popup.lit.html#27">[27]</A>.. В таких системах для обоих <SPAN class="keyword">файловых дескрипторов</SPAN>, ассоциированных с pip'ом, разрешены и операция чтения, и операция записи. Однако такое поведение не характерно для pip’ов и не является переносимым. </P><DIV class="lecture_mark" id="mark_219"></DIV><A name="sect13"></A><H3>Особенности поведения вызовов read() и write() для pip'а</H3><P id="id_220">Системные вызовы <SPAN class="texample"><SPAN class="keyword">read()</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">write()</SPAN></SPAN> имеют определенные особенности поведения при работе с pip’ом, связанные с его ограниченным размером, задержками в передаче данных и возможностью блокирования обменивающихся информацией процессов. Организация запрета блокирования этих вызовов для <SPAN class="texample"><SPAN class="keyword">pipe</SPAN></SPAN> выходит за рамки нашего курса. </P><DIV class="lecture_mark" id="mark_220"></DIV><P id="id_224"><B>Будьте внимательны при написании программ, обменивающихся большими объемами информации через</B> <SPAN class="texample"><SPAN class="keyword">pipe</SPAN></SPAN>. <B>Помните, что за один раз из pip’а может прочитаться меньше информации, чем вы запрашивали, и за один раз в</B> <SPAN class="texample"><SPAN class="keyword">pipe</SPAN></SPAN> <B>может записаться меньше информации, чем вам хотелось бы. Проверяйте значения, возвращаемые вызовами!</B> </P><DIV class="lecture_mark" id="mark_224"></DIV><P id="id_227">Одна из особенностей поведения блокирующегося системного вызова <SPAN class="texample"><SPAN class="keyword">read()</SPAN></SPAN> связана с попыткой чтения из пустого pip'а. Если есть процессы, у которых этот <SPAN class="texample"><SPAN class="keyword">pipe</SPAN></SPAN> открыт для записи, то системный вызов блокируется и ждет появления информации. Если таких процессов нет, он вернет значение <SPAN class="texample">0</SPAN> без блокировки процесса. Эта особенность приводит к <B>необходимости закрытия</B> <SPAN class="keyword">файлового дескриптора</SPAN>, <B>ассоциированного с входным концом pip'a, в процессе, который будет использовать</B> <SPAN class="texample"><SPAN class="keyword">pipe</SPAN></SPAN> <B>для чтения (</B><SPAN class="texample"><SPAN class="keyword">close</SPAN>(fd[1]</SPAN><B>)</B> в процессе-ребенке в программе из раздела "Прогон программы для организации однонаправленной связи между родственными процессами через <SPAN class="texample"><SPAN class="keyword">pipe</SPAN></SPAN>"). Аналогичной особенностью поведения при отсутствии процессов, у которых <SPAN class="texample"><SPAN class="keyword">pipe</SPAN></SPAN> открыт для чтения, обладает и системный вызов <SPAN class="texample"><SPAN class="keyword">write()</SPAN></SPAN>, с чем связана <B>необходимость закрытия</B> <SPAN class="keyword">файлового дескриптора</SPAN>, <B>ассоциированного с выходным концом pip'a, в процессе, который будет использовать</B> <SPAN class="texample"><SPAN class="keyword">pipe</SPAN></SPAN> <B>для записи (</B><SPAN class="texample"><SPAN class="keyword">close</SPAN>(fd[0]</SPAN><B>)</B> в процессе-родителе в той же программе).</P><DIV class="lecture_mark" id="mark_227"></DIV><DIV class="xml_table_env" id="id_238"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD colspan="2" bgcolor="#eaeaea" valign="top">
<P id="id_239"><B>Системные вызовы read и write (продолжение)</B></P><DIV class="lecture_mark" id="mark_239"></DIV>

<P id="id_240"><B>Особенности поведения при работе с pipe, FIFO и socket</B></P><DIV class="lecture_mark" id="mark_240"></DIV>

<P id="id_241"><B>Системный вызов read</B></P><DIV class="lecture_mark" id="mark_241"></DIV>
</TD></TR><TR><TH bgcolor="#d8d8d8">Ситуация</TH><TH bgcolor="#d8d8d8">Поведение</TH></TR><TR><TD bgcolor="#eaeaea" valign="top">Попытка прочитать меньше байт, чем есть в наличии в канале связи.</TD><TD bgcolor="#eaeaea" valign="top">Читает требуемое количество байт и возвращает значение, соответствующее прочитанному количеству. Прочитанная информация удаляется из канала связи.</TD></TR><TR><TD bgcolor="#eaeaea" valign="top">В канале связи находится меньше байт, чем затребовано, но не нулевое количество.</TD><TD bgcolor="#eaeaea" valign="top">Читает все, что есть в канале связи, и возвращает значение, соответствующее прочитанному количеству. Прочитанная информация удаляется из канала связи.</TD></TR><TR><TD bgcolor="#eaeaea" valign="top">Попытка читать из канала связи, в котором нет информации. Блокировка вызова разрешена.</TD><TD bgcolor="#eaeaea" valign="top">Вызов блокируется до тех пор, пока не появится информация в канале связи и пока существует процесс, который может передать в него информацию. Если информация появилась, то процесс разблокируется, и поведение вызова определяется двумя предыдущими строками таблицы. Если в канал некому передать данные (нет ни одного процесса, у которого этот канал связи открыт для записи), то вызов возвращает значение <SPAN class="texample">0</SPAN>. Если канал связи полностью закрывается для записи во время блокировки читающего процесса, то процесс разблокируется, и системный вызов возвращает значение <SPAN class="texample">0</SPAN>.</TD></TR><TR><TD bgcolor="#eaeaea" valign="top">Попытка читать из канала связи, в котором нет информации. Блокировка вызова не разрешена.</TD><TD bgcolor="#eaeaea" valign="top">Если есть процессы, у которых канал связи открыт для записи, системный вызов возвращает значение <SPAN class="texample">-1</SPAN> и устанавливает переменную <SPAN class="texample">errno</SPAN> в значение <SPAN class="texample">EAGAIN</SPAN>. Если таких процессов нет, системный вызов возвращает значение <SPAN class="texample">0</SPAN>.</TD></TR><TR><TD colspan="2" bgcolor="#eaeaea" valign="top">
<P id="id_248">&nbsp;</P><DIV class="lecture_mark" id="mark_248"></DIV>
<P id="id_249"><B>Системный вызов write</B></P><DIV class="lecture_mark" id="mark_249"></DIV>

</TD></TR><TR><TH bgcolor="#d8d8d8">Ситуация</TH><TH bgcolor="#d8d8d8">Поведение</TH></TR><TR><TD bgcolor="#eaeaea" valign="top">Попытка записать в канал связи меньше байт, чем осталось до его заполнения.</TD><TD bgcolor="#eaeaea" valign="top">Требуемое количество байт помещается в канал связи, возвращается записанное количество байт.</TD></TR><TR><TD bgcolor="#eaeaea" valign="top">Попытка записать в канал связи больше байт, чем осталось до его заполнения. Блокировка вызова разрешена.</TD><TD bgcolor="#eaeaea" valign="top">Вызов блокируется до тех пор, пока все данные не будут помещены в канал связи. Если размер буфера канала связи меньше, чем передаваемое количество информации, то вызов тем самым будет ждать, пока часть информации не будет считана из канала связи. Возвращается записанное количество байт.</TD></TR><TR><TD bgcolor="#eaeaea" valign="top">Попытка записать в канал связи больше байт, чем осталось до его заполнения, но меньше, чем размер буфера канала связи. Блокировка вызова запрещена.</TD><TD bgcolor="#eaeaea" valign="top">Системный вызов возвращает значение <SPAN class="texample">-1</SPAN> и устанавливает переменную <SPAN class="texample">errno</SPAN> в значение <SPAN class="texample">EAGAIN</SPAN>.</TD></TR><TR><TD bgcolor="#eaeaea" valign="top">В канале связи есть место. Попытка записать в канал связи больше байт, чем осталось до его заполнения, и больше, чем размер буфера канала связи. Блокировка вызова запрещена.</TD><TD bgcolor="#eaeaea" valign="top">Записывается столько байт, сколько осталось до заполнения канала. Системный вызов возвращает количество записанных байт.</TD></TR><TR><TD bgcolor="#eaeaea" valign="top">Попытка записи в канал связи, в котором нет места. Блокировка вызова не разрешена.</TD><TD bgcolor="#eaeaea" valign="top">Системный вызов возвращает значение <SPAN class="texample">-1</SPAN> и устанавливает переменную <SPAN class="texample">errno</SPAN> в значение <SPAN class="texample">EAGAIN</SPAN>.</TD></TR><TR><TD bgcolor="#eaeaea" valign="top">Попытка записи в канал связи, из которого некому больше читать, или полное закрытие канала на чтение во время блокировки системного вызова. </TD><TD bgcolor="#eaeaea" valign="top">Если вызов был заблокирован, то он разблокируется. Процесс получает сигнал <SPAN class="texample">SIGPIPE</SPAN>. Если этот сигнал обрабатывается пользователем, то системный вызов вернет значение <SPAN class="texample">-1</SPAN> и установит переменную <SPAN class="texample">errno</SPAN> в значение <SPAN class="texample">EPIPE</SPAN>.</TD></TR><TR><TD colspan="2" bgcolor="#eaeaea" valign="top">Необходимо отметить дополнительную особенность системного вызова <SPAN class="texample"><SPAN class="keyword">write</SPAN></SPAN> при работе с pip’ами и FIFO. Запись информации, размер которой не превышает размер буфера, должна осуществляться атомарно – одним подряд лежащим куском. Этим объясняется ряд блокировок и ошибок в предыдущем перечне.
</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_238"></DIV><P id="id_261"><B>Задача повышенной сложности:</B> определите размер <SPAN class="texample"><SPAN class="keyword">pipe</SPAN></SPAN> для вашей операционной системы. </P><DIV class="lecture_mark" id="mark_261"></DIV><A name="sect14"></A><H3>Понятие FIFO. Использование системного вызова mknod() для создания FIFO. Функция mkfifo()</H3><P id="id_263">Как мы выяснили, доступ к информации о расположении pip'а в операционной системе и его состоянии может быть осуществлен только через <SPAN class="keyword">таблицу открытых файлов процесса</SPAN>, создавшего <SPAN class="texample"><SPAN class="keyword">pipe</SPAN></SPAN>, и через унаследованные от него <SPAN class="keyword">таблицы открытых файлов</SPAN> процессов-потомков. Поэтому изложенный выше механизм обмена информацией через <SPAN class="texample"><SPAN class="keyword">pipe</SPAN></SPAN> справедлив лишь для родственных процессов, имеющих общего прародителя, инициировавшего системный вызов <SPAN class="texample">pipe()</SPAN>, или для таких процессов и самого прародителя и не может использоваться для потокового общения с другими процессами. В операционной системе UNIX существует возможность использования pip'а для взаимодействия других процессов, но ее реализация достаточно сложна и лежит далеко за пределами наших занятий.</P><DIV class="lecture_mark" id="mark_263"></DIV><P id="id_267"><A name="keyword-context.10"></A>Для организации потокового взаимодействия любых процессов в операционной системе UNIX применяется средство связи, получившее название <SPAN class="keyword_def">FIFO</SPAN> (от First Input First Output) или именованный <SPAN class="texample"><SPAN class="keyword">pipe</SPAN></SPAN>. <SPAN class="keyword">FIFO</SPAN> во всем подобен pip’у, за одним исключением: данные о расположении <SPAN class="keyword">FIFO</SPAN> в адресном пространстве ядра и его состоянии процессы могут получать не через родственные связи, а через файловую систему. Для этого при создании именованного pip’а на диске заводится файл специального типа, обращаясь к которому процессы могут получить интересующую их информацию. <A name="keyword-context.11"></A><A name="keyword-context.12"></A>Для создания <SPAN class="keyword">FIFO</SPAN> используется системный вызов <SPAN class="texample"><SPAN class="keyword_def">mknod()</SPAN></SPAN> или существующая в некоторых версиях UNIX функция <SPAN class="texample"><SPAN class="keyword_def">mkfifo()</SPAN></SPAN>. </P><DIV class="lecture_mark" id="mark_267"></DIV><P id="id_271"><B>Следует отметить, что при их работе не происходит действительного выделения области адресного пространства операционной системы под именованный</B> <SPAN class="texample"><SPAN class="keyword">pipe</SPAN></SPAN>, <B>а только заводится файл-метка, существование которой позволяет осуществить реальную организацию</B> <SPAN class="keyword">FIFO</SPAN> <B>в памяти при его открытии с помощью уже известного нам ситемного вызова</B> <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN><B>.</B> </P><DIV class="lecture_mark" id="mark_271"></DIV><P id="id_274">После открытия именованный <SPAN class="texample"><SPAN class="keyword">pipe</SPAN></SPAN> ведет себя точно так же, как и неименованный. Для дальнейшей работы с ним применяются системные вызовы <SPAN class="texample"><SPAN class="keyword">read()</SPAN></SPAN>, <SPAN class="texample"><SPAN class="keyword">write()</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">close()</SPAN></SPAN>. Время существования <SPAN class="keyword">FIFO</SPAN> в адресном пространстве ядра операционной системы, как и в случае с pip’ом, не может превышать время жизни последнего из использовавших его процессов. Когда все процессы, работающие с <SPAN class="keyword">FIFO</SPAN>, закрывают все <SPAN class="keyword">файловые дескрипторы</SPAN>, ассоциированные с ним, система освобождает ресурсы, выделенные под <SPAN class="keyword">FIFO</SPAN>. Вся непрочитанная информация теряется. В то же время файл-метка остается на диске и может использоваться для новой реальной организации <SPAN class="keyword">FIFO</SPAN> в да
льнейшем.</P><DIV class="lecture_mark" id="mark_274"></DIV><DIV class="xml_table_env" id="id_279"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_280"><B>Использование системного вызова mknod для создания FIFO</B></P><DIV class="lecture_mark" id="mark_280"></DIV>

<P id="id_281"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_281"></DIV>

<DIV class="example"><PRE>#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
int mknod(char *path, int mode, int dev);
</PRE></DIV>

<P id="id_283"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_283"></DIV>

<P id="id_284">Нашей целью является не полное описание системного вызова <SPAN class="texample"><SPAN class="keyword">mknod</SPAN></SPAN>, а только описание его использования для создания FIFO. Поэтому мы будем рассматривать не все возможные варианты задания параметров, а только те из них, которые соответствуют этой специфической деятельности.</P><DIV class="lecture_mark" id="mark_284"></DIV>

<P id="id_286">Параметр <SPAN class="texample">dev</SPAN> является несущественным в нашей ситуации, и мы будем всегда задавать его равным <SPAN class="texample">0</SPAN>.</P><DIV class="lecture_mark" id="mark_286"></DIV>

<P id="id_289">Параметр <SPAN class="texample">path</SPAN> является указателем на строку, содержащую полное или относительное имя файла, который будет являться меткой FIFO на диске. Для успешного создания FIFO файла с таким именем перед вызовом существовать не должно.</P><DIV class="lecture_mark" id="mark_289"></DIV>

<P id="id_291">Параметр <SPAN class="texample">mode</SPAN> устанавливает атрибуты прав доступа различных категорий пользователей к FIFO. Этот параметр задается как результат побитовой операции "или" значения <SPAN class="texample">S_IFIFO</SPAN>, указывающего, что системный вызов должен создать FIFO, и некоторой суммы следующих восьмеричных значений:</P><DIV class="lecture_mark" id="mark_291"></DIV>

<UL id="id_294"><LI><SPAN class="texample">0400</SPAN> – разрешено чтение для пользователя, создавшего FIFO;</LI><LI><SPAN class="texample">0200</SPAN> – разрешена запись для пользователя, создавшего FIFO;</LI><LI><SPAN class="texample">0040</SPAN> – разрешено чтение для группы пользователя, создавшего FIFO;</LI><LI><SPAN class="texample">0020</SPAN> – разрешена запись для группы пользователя, создавшего FIFO;</LI><LI><SPAN class="texample">0004</SPAN> – разрешено чтение для всех остальных пользователей;</LI><LI><SPAN class="texample">0002</SPAN> – разрешена запись для всех остальных пользователей.</LI></UL><DIV class="lecture_mark" id="mark_294"></DIV>

<P id="id_307">При создании FIFO реально устанавливаемые права доступа получаются из стандартной комбинации параметра <SPAN class="texample">mode</SPAN> и маски создания файлов текущего процесса <SPAN class="texample">umask</SPAN>, а именно – они равны <SPAN class="texample">(0777 &amp; mode) &amp; ~umask</SPAN>.</P><DIV class="lecture_mark" id="mark_307"></DIV>

<P id="id_311"><B>Возвращаемые значения</B></P><DIV class="lecture_mark" id="mark_311"></DIV>

<P id="id_312">При успешном создании FIFO системный вызов возвращает значение <SPAN class="texample">0</SPAN>, при неуспешном – отрицательное значение.</P><DIV class="lecture_mark" id="mark_312"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_279"></DIV><P id="id_314"></P><DIV class="lecture_mark" id="mark_314"></DIV><DIV class="xml_table_env" id="id_315"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_316"><B>Функция mkfifo</B></P><DIV class="lecture_mark" id="mark_316"></DIV>

<P id="id_317"><B>Прототип функции</B></P><DIV class="lecture_mark" id="mark_317"></DIV>

<DIV class="example"><PRE>#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
int mkfifo(char *path, int mode);
</PRE></DIV>

<P id="id_319"><B>Описание функции</B></P><DIV class="lecture_mark" id="mark_319"></DIV>

<P id="id_320">Функция <SPAN class="texample"><SPAN class="keyword">mkfifo</SPAN></SPAN> предназначена для создания FIFO в операционной системе.</P><DIV class="lecture_mark" id="mark_320"></DIV>

<P id="id_322">Параметр <SPAN class="texample">path</SPAN> является указателем на строку, содержащую полное или относительное имя файла, который будет являться меткой FIFO на диске. Для успешного создания FIFO файла с таким именем перед вызовом функции не должно существовать.</P><DIV class="lecture_mark" id="mark_322"></DIV>

<P id="id_324">Параметр <SPAN class="texample">mode</SPAN> устанавливает атрибуты прав доступа различных категорий пользователей к FIFO. Этот параметр задается как некоторая сумма следующих восьмеричных значений:</P><DIV class="lecture_mark" id="mark_324"></DIV>

<UL id="id_326"><LI><SPAN class="texample">0400</SPAN> – разрешено чтение для пользователя, создавшего FIFO;</LI><LI><SPAN class="texample">0200</SPAN> – разрешена запись для пользователя, создавшего FIFO;</LI><LI><SPAN class="texample">0040</SPAN> – разрешено чтение для группы пользователя, создавшего FIFO;</LI><LI><SPAN class="texample">0020</SPAN> – разрешена запись для группы пользователя, создавшего FIFO;</LI><LI><SPAN class="texample">0004</SPAN> – разрешено чтение для всех остальных пользователей;</LI><LI><SPAN class="texample">0002</SPAN> – разрешена запись для всех остальных пользователей.</LI></UL><DIV class="lecture_mark" id="mark_326"></DIV>

<P id="id_339">При создании FIFO реально устанавливаемые права доступа получаются из стандартной комбинации параметра <SPAN class="texample">mode</SPAN> и маски создания файлов текущего процесса <SPAN class="texample">umask</SPAN>, а именно – они равны <SPAN class="texample">(0777 &amp; mode) &amp; ~umask</SPAN>.</P><DIV class="lecture_mark" id="mark_339"></DIV>

<P id="id_343"><B>Возвращаемые значения</B></P><DIV class="lecture_mark" id="mark_343"></DIV>

<P id="id_344">При успешном создании FIFO функция возвращает значение <SPAN class="texample">0</SPAN>, при неуспешном – отрицательное значение.</P><DIV class="lecture_mark" id="mark_344"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_315"></DIV><P id="id_346">Важно понимать, что <SPAN class="keyword">файл типа FIFO</SPAN> не служит для размещения на диске информации, которая записывается в именованный <SPAN class="texample"><SPAN class="keyword">pipe</SPAN></SPAN>. Эта информация располагается внутри адресного пространства операционной системы, а файл является только меткой, создающей предпосылки для ее размещения. </P><DIV class="lecture_mark" id="mark_346"></DIV><P id="id_348"><B>Не пытайтесь просмотреть содержимое этого файла с помощью Midnight Commander (mc)!!! Это приведет к его глубокому зависанию! </B></P><DIV class="lecture_mark" id="mark_348"></DIV><A name="sect15"></A><H3>Особенности поведения вызова open() при открытии FIFO</H3><P id="id_349">Системные вызовы <SPAN class="texample"><SPAN class="keyword">read()</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">write()</SPAN></SPAN> при работе с <SPAN class="keyword">FIFO</SPAN> имеют те же особенности поведения, что и при работе с pip’ом. Системный вызов <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN> при открытии <SPAN class="keyword">FIFO</SPAN> также ведет себя несколько иначе, чем при открытии других типов файлов, что связано с возможностью блокирования выполняющих его процессов. Если <SPAN class="keyword">FIFO</SPAN> открывается только для чтения, и флаг <SPAN class="texample">O_NDELAY</SPAN> не задан, то процесс, осуществивший системный вызов, блокируется до тех пор, пока какой-либо другой процесс не откроет <SPAN class="keyword">FIFO</SPAN> на запись. Если флаг <SPAN class="texample">O_NDELAY</SPAN> задан, то возвращается значение <SPAN class="keyword">файлового дескриптора</SPAN>, ассоциированного с <SPAN class="keyword">FIFO</SPAN>. Если <SPAN class="keyword">
FIFO</SPAN> открывается только для записи, и флаг <SPAN class="texample">O_NDELAY</SPAN> не задан, то процесс, осуществивший системный вызов, блокируется до тех пор, пока какой-либо другой процесс не откроет <SPAN class="keyword">FIFO</SPAN> на чтение. Если флаг <SPAN class="texample">O_NDELAY</SPAN> задан, то констатируется возникновение ошибки и возвращается значение <SPAN class="texample">-1</SPAN>. Задание флага <SPAN class="texample">O_NDELAY</SPAN> в параметрах системного вызова <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN> приводит и к тому, что процессу, открывшему <SPAN class="keyword">FIFO</SPAN>, запрещается блокировка при выполнении последующих операций чтения из этого потока данных и записи в него. </P><DIV class="lecture_mark" id="mark_349"></DIV><A name="sect16"></A><H3>Прогон программы c FIFO в родственных процессах</H3><P id="id_360">Для иллюстрации взаимодействия процессов через <SPAN class="keyword">FIFO</SPAN> рассмотрим такую программу:</P><DIV class="lecture_mark" id="mark_360"></DIV><A name="example.5.4"></A><DIV class="example"><PRE>/* Программа 05-4.с, осуществляющая однонаправленную связь через 
FIFO между процессом-родителем и процессом-ребенком */ 
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
int main(){
    int fd, result;
    size_t size;
    char resstring[14]; 
    char name[]="aaa.fifo";
    /* Обнуляем маску создания файлов текущего процесса для того, 
    чтобы права доступа у создаваемого FIFO точно соответствовали 
    параметру вызова mknod() */
    (void)umask(0); 
    /* Попытаемся создать FIFO с именем aaa.fifo в текущей 
    директории */
    if(mknod(name, S_IFIFO | 0666, 0) &lt; 0){
        /* Если создать FIFO не удалось, печатаем об этом
        сообщение и прекращаем работу */
        printf("Can\'t create FIFO\n");
        exit(-1); 
    } 
    /* Порождаем новый процесс */ 
    if((result = fork()) &lt; 0){ 
        /* Если создать процесс не удалось, сообщаем об этом и 
        завершаем работу */
        printf("Can\'t fork child\n");
        exit(-1);
    } else if (result &gt; 0) {
        /* Мы находимся в родительском процессе, который будет
        передавать информацию процессу-ребенку. В этом процессе
        открываем FIFO на запись.*/
        if((fd = open(name, O_WRONLY)) &lt; 0){
            /* Если открыть FIFO не удалось, печатаем об этом
            сообщение и прекращаем работу */
            printf("Can\'t open FIFO for writing\n");
            exit(-1); 
        } 
        /* Пробуем записать в FIFO 14 байт, т.е. всю строку
        "Hello, world!" вместе с признаком конца строки */
        size = write(fd, "Hello, world!", 14);
        if(size != 14){
        /* Если записалось меньшее количество байт,то сообщаем
        об ошибке и завершаем работу */
            printf("Can\'t write all string to FIFO\n");         
            exit(-1); 
        } 
        /* Закрываем входной поток данных и на этом родитель
        прекращает работу */
        close(fd);
        printf("Parent exit\n");
    } else {
        /* Мы находимся в порожденном процессе, который будет
        получать информацию от процесса-родителя. Открываем 
        FIFO на чтение.*/
        if((fd = open(name, O_RDONLY)) &lt; 0){
            /* Если открыть FIFO не удалось, печатаем об этом
            сообщение и прекращаем работу */
            printf("Can\'t open FIFO for reading\n");
            exit(-1); 
        } 
        /* Пробуем прочитать из FIFO 14 байт в массив, т.е.
        всю записанную строку */
        size = read(fd, resstring, 14);
        if(size &lt; 0){
            /* Если прочитать не смогли, сообщаем об ошибке
            и завершаем работу */
            printf("Can\'t read string\n"); 
            exit(-1); 
        } 
        /* Печатаем прочитанную строку */
        printf("%s\n",resstring);
        /* Закрываем входной поток и завершаем работу */
        close(fd);
    }
    return 0; 
}
</PRE><SPAN class="objectName">
            Листинг 
            5.4.
            Программа 05-4.с, осуществляющая однонаправленную связь через  FIFO между процессом-родителем и процессом-ребенком</SPAN></DIV><P id="id_362">Наберите программу, откомпилируйте ее и запустите на исполнение. В этой программе информацией между собой обмениваются процесс-родитель и процесс-ребенок. Обратим внимание, что повторный запуск этой программы приведет к ошибке при попытке создания <SPAN class="keyword">FIFO</SPAN>, так как файл с заданным именем уже существует. Здесь нужно либо удалять его перед каждым прогоном программы с диска вручную, либо после первого запуска модифицировать исходный текст, исключив из него все, связанное с системным вызовом <SPAN class="texample"><SPAN class="keyword">mknod()</SPAN></SPAN>. С системным вызовом, предназначенным для удаления файла при работе процесса, мы познакомимся позже (на семинарах 11–12) при изучении файловых систем.</P><DIV class="lecture_mark" id="mark_362"></DIV><A name="sect17"></A><H3>Написание, компиляция и запуск программы с FIFO в неродственных процессах</H3><P id="id_364">Для закрепления полученных знаний напишите на базе предыдущего примера две программы, одна из которых пишет информацию в <SPAN class="keyword">FIFO</SPAN>, а вторая – читает из него, так чтобы между ними не было ярко выраженных родственных связей (т.е. чтобы ни одна из них не была потомком другой). </P><DIV class="lecture_mark" id="mark_364"></DIV><A name="sect18"></A><H3>Неработающий пример для связи процессов на различных компьютерах</H3><P id="id_365">Если у вас есть возможность, найдите два компьютера, имеющих разделяемую файловую систему (например, смонтированную с помощью NFS), и запустите на них программы из предыдущего раздела так, чтобы каждая программа работала на своем компьютере, а <SPAN class="keyword">FIFO</SPAN> создавалось на разделяемой файловой системе. Хотя оба процесса видят один и тот же <SPAN class="keyword">файл с типом FIFO</SPAN>, взаимодействия между ними не происходит, так как они функционируют в физически разных адресных пространствах и пытаются открыть <SPAN class="keyword">FIFO</SPAN> внутри различных операционных систем. </P><DIV class="lecture_mark" id="mark_365"></DIV>


	</TD>
	</TR>
	<TR><TD height="8"><IMG src="./3. Организация взаимодействия процессов через pipe и FIFO в UNIX_files/empty.gif" width="1" height="8"></TD></TR>
	</TBODY></TABLE>
	<!-- /content -->

</TD>
<TD><IMG src="./3. Организация взаимодействия процессов через pipe и FIFO в UNIX_files/empty.gif" width="8" height="1"></TD>
</TR>
</TBODY></TABLE>
<!-- /bottom -->
<TABLE border="0" cellpadding="0" cellspacing="0" width="100%">
<TBODY><TR><TD class="orang" height="1"><IMG src="./3. Организация взаимодействия процессов через pipe и FIFO в UNIX_files/empty.gif" width="1" height="1"></TD></TR>
<TR><TD class="ltxt" align="center">© INTUIT.ru, 2003-2009. Все права защищены.</TD>
</TR>
</TBODY></TABLE>
<!-- /bottom -->

<SCRIPT src="./3. Организация взаимодействия процессов через pipe и FIFO в UNIX_files/urchin.js" type="text/javascript">
</SCRIPT>
<SCRIPT type="text/javascript">
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>


</BODY></HTML>