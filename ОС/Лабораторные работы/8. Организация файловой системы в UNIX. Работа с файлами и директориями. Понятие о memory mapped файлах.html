
<!-- saved from url=(0075)http://www.intuit.ru/department/os/osintropractice/8/osintropractice_8.html -->
<HTML><HEAD><META http-equiv="Content-Type" content="text/html; charset=windows-1251">

<TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<LINK href="./8. Организация файловой системы в UNIX. Работа с файлами и директориями. Понятие о memory mapped файлах_files/printable.css" type="text/css" rel="stylesheet">
</HEAD><BODY leftmargin="6" topmargin="6" marginheight="6" marginwidth="6">

<DIV align="left">
<SPAN style="color: #000000; font-weight: bold;">
&nbsp;&nbsp;
<SPAN style="font-size:12pt;">Интернет-Университет Информационных Технологий</SPAN>
</SPAN>
</DIV>

&nbsp;&nbsp;
<SPAN align="rright" style="color: #330066; text-decoration:underline;">http://www.INTUIT.ru</SPAN>


<TABLE border="0" cellpadding="0" cellspacing="0" width="100%">
<TBODY><TR><TD height="8" colspan="3"><IMG src="./8. Организация файловой системы в UNIX. Работа с файлами и директориями. Понятие о memory mapped файлах_files/empty.gif" width="1" height="8"></TD></TR>
<TR><TD class="orang" height="1" colspan="3"><IMG src="./8. Организация файловой системы в UNIX. Работа с файлами и директориями. Понятие о memory mapped файлах_files/empty.gif" width="1" height="1"></TD></TR>
<TR><TD height="8" colspan="3"><IMG src="./8. Организация файловой системы в UNIX. Работа с файлами и директориями. Понятие о memory mapped файлах_files/empty.gif" width="1" height="8"></TD></TR>
<TR valign="top">
<TD><IMG src="./8. Организация файловой системы в UNIX. Работа с файлами и директориями. Понятие о memory mapped файлах_files/empty.gif" width="8" height="1"></TD>
<TD>
	<!-- content -->
	<TABLE border="0" cellpadding="0" cellspacing="0" width="100%">
	<TBODY><TR><TD class="head">Основы операционных систем. Практикум</TD></TR>
<TR><TD height="4"><IMG src="./8. Организация файловой системы в UNIX. Работа с файлами и директориями. Понятие о memory mapped файлах_files/empty.gif" width="1" height="4"></TD></TR>
	<TR><TD class="orang" height="1"><IMG src="./8. Организация файловой системы в UNIX. Работа с файлами и директориями. Понятие о memory mapped файлах_files/empty.gif" width="1" height="1"></TD></TR>
	<TR><TD height="8"><IMG src="./8. Организация файловой системы в UNIX. Работа с файлами и директориями. Понятие о memory mapped файлах_files/empty.gif" width="1" height="8"></TD></TR>
	<TR><TD><SPAN class="headsub">


8. Лекция:

 Организация файловой системы в UNIX. Работа с файлами и директориями. Понятие о memory mapped файлах: версия для печати и PDA</SPAN>

<BR>
<SPAN class="rtxt">Разделы носителя информации (partitions) в UNIX. Логическая структура файловой системы и типы файлов в UNIX. Организация файла на диске в UNIX на примере файловой системы s5fs. Понятие индексного узла (inode). Организация директорий (каталогов) в UNIX. Понятие суперблока. Операции над файлами и директориями. Системные вызовы и команды для выполнения операций над файлами и директориями. Системный вызов open(). Системный вызов close(). Операция создания файла. Системный вызов creat(). Операция чтения атрибутов файла. Системные вызовы stat(), fstat() и lstat(). Операции изменения атрибутов файла. Операции чтения из файла и записи в файл. Операция изменения указателя текущей позиции. Системный вызов lseek(). Операция добавления информации в файл. Флаг O_APPEND. Операции создания связей. Команда ln, системные вызовы link() и symlink(). Операция удаления связей и файлов. Системный вызов unlink(). Специальные функции для работы с содержимым директорий. Понятие о файлах, отображаемых в память (memory 
mapped файлах). Системные вызовы mmap(), munmap(). 
</SPAN>

</TD></TR>

	<TR><TD height="8"><IMG src="./8. Организация файловой системы в UNIX. Работа с файлами и директориями. Понятие о memory mapped файлах_files/empty.gif" width="1" height="8"></TD></TR>
	<TR><TD class="orang" height="1"><IMG src="./8. Организация файловой системы в UNIX. Работа с файлами и директориями. Понятие о memory mapped файлах_files/empty.gif" width="1" height="1"></TD></TR>
	<TR><TD height="8"><IMG src="./8. Организация файловой системы в UNIX. Работа с файлами и директориями. Понятие о memory mapped файлах_files/empty.gif" width="1" height="8"></TD></TR>
	<TR><TD>


<A name="sect1"></A><H3>Введение</H3><P id="id_1">В материалах нескольких предыдущих семинаров (семинары 1–2, семинар 5) уже затрагивались вопросы работы с файлами в UNIX. Но только теперь, пояснив в лекции понятие файловой системы, мы можем рассмотреть файловую систему UNIX в целом. Наш обзор, правда, ограничится общими вопросами, связанными с организацией файловой системы, и системными вызовами, которые с наибольшей вероятностью могут пригодиться в дальнейшем. Это связано как с ограниченностью времени, которое отводится на работу с файловыми системами в нашем курсе, так и с преимущественно практическим направлением наших занятий. </P><DIV class="lecture_mark" id="mark_1"></DIV><A name="sect2"></A><H3>Разделы носителя информации (partitions) в UNIX</H3><P id="id_2"><A name="keyword-context.1"></A>Физические носители информации – магнитные или оптические диски, ленты и т.д., использующиеся как физическая основа для хранения файлов, в операционных системах принято логически делить на <SPAN class="keyword_def">разделы (partitions) или логические диски</SPAN>. Причем слово "делить" не следует понимать буквально, в некоторых системах несколько физических дисков могут быть объединены в один <SPAN class="keyword">раздел</SPAN>. Об этом подробнее рассказывается в лекции 12 в разделе "Общая структура файловой системы". </P><DIV class="lecture_mark" id="mark_2"></DIV><P id="id_3">В операционной системе UNIX физический носитель информации обычно представляет собой один или несколько <SPAN class="keyword">разделов</SPAN>. В большинстве случаев разбиение на <SPAN class="keyword">разделы</SPAN> производится линейно, хотя некоторые варианты UNIX могут допускать некое подобие древовидного разбиения (Solaris). Количество <SPAN class="keyword">разделов</SPAN> и их размеры определяются при форматировании диска. Поскольку форматирование диска относится к области администрирования операционных систем, оно в нашем курсе рассматриваться не будет.</P><DIV class="lecture_mark" id="mark_3"></DIV><P id="id_4">Наличие нескольких <SPAN class="keyword">разделов</SPAN> на диске может определяться требованиями операционной системы или пожеланиями пользователя. Допустим, пользователь хочет разместить на одном жестком диске несколько операционных систем с возможностью попеременной работы в них, тогда он размещает каждую операционную систему в своем <SPAN class="keyword">разделе</SPAN>. Или другая ситуация: необходимость работы с несколькими видами файловых систем. Под каждый тип файловой системы выделяется отдельный <SPAN class="keyword">логический диск</SPAN>. Третий вариант – это разбиение диска на <SPAN class="keyword">разделы</SPAN> для размещения в разных <SPAN class="keyword">разделах</SPAN> различных категорий файлов. Скажем, в одном <SPAN class="keyword">разделе</SPAN> помещаются 
все системные файлы, а в другом <SPAN class="keyword">разделе</SPAN> – все пользовательские файлы. Примером операционной системы, внутренние требования которой приводят к появлению нескольких <SPAN class="keyword">разделов</SPAN> на диске, могут служить ранние версии MS-DOS, для которых максимальный размер <SPAN class="keyword">логического диска</SPAN> не превышал 32 Мбайт. </P><DIV class="lecture_mark" id="mark_4"></DIV><P id="id_5">Для простоты далее в этих семинарах будем полагать, что у нас имеется только один <SPAN class="keyword">раздел</SPAN> и, следовательно, одна файловая система. Вопросы взаимного сосуществования нескольких файловых систем в рамках одной операционной системы мы затронем в семинарах 13–14 перед обсуждением реализации подсистемы ввода-вывода.</P><DIV class="lecture_mark" id="mark_5"></DIV><A name="sect3"></A><H3>Логическая структура файловой системы и типы файлов в UNIX</H3><P id="id_6">Мы не будем давать здесь определение файла, полагая, что интуитивное представление о файлах у вас имеется, а в лекции 11 (раздел "Введение") было введено понятие о файлах, как об именованных абстрактных объектах, обладающих определенными свойствами. При этом в пространстве имен файлов одному файлу могут соответствовать несколько имен. </P><DIV class="lecture_mark" id="mark_6"></DIV><P id="id_7">В материалах семинаров 1-2 упрощенно говорилось о том, что файлы могут объединяться в <SPAN class="keyword">директории</SPAN>, и что файлы и <SPAN class="keyword">директории</SPAN> организованы в древовидную структуру. На нынешнем уровне знаний мы можем сформулировать это более аккуратно. В операционной системе UNIX существуют файлы нескольких типов, а именно: </P><DIV class="lecture_mark" id="mark_7"></DIV><UL id="id_8"><LI>обычные или <SPAN class="keyword">регулярные файлы</SPAN>; </LI><LI><SPAN class="keyword">директории</SPAN> или каталоги; </LI><LI><SPAN class="keyword">файлы типа FIFO</SPAN> или именованные pip'ы; </LI><LI>специальные <SPAN class="keyword">файлы устройств</SPAN>; </LI><LI>сокеты (sockets); </LI><LI>специальные файлы связи (link).</LI></UL><DIV class="lecture_mark" id="mark_8"></DIV><P id="id_15">Что такое <SPAN class="keyword">регулярные файлы</SPAN> и <SPAN class="keyword">директории</SPAN>, вам должно быть хорошо известно из личного опыта и из лекций (лекция 11). О способах их отображения в дисковое пространство речь пойдет чуть позже. <SPAN class="keyword">Файлы типа FIFO</SPAN> были представлены в семинаре 5, когда рассматривалась работа с именованными pip'ами (раздел "Понятие FIFO. Использование системного вызова mknod() для создания FIFO. Функция mkfifo()"). <SPAN class="keyword">Файлы типа "связь"</SPAN> мы представим в этом семинаре, когда будем обсуждать <SPAN class="keyword">операции над файлами</SPAN> (раздел "Операции над файлами и <SPAN class="keyword">директориями</SPAN>") и соответствующие им системные вызовы (раздел "Системные вызовы и команды для выполнения <SPAN class="keyword">операций над файлами</SPAN> и <SPAN class="keyword">директориями</SPAN>"). О специальных <SPAN class="keyword">файлах устройств</SPAN> будет рассказано в материалах семинаров 13–14, посвященных реализации в UNIX подсистемы ввода-вывода и передаче информации с помощью сигналов. <SPAN class="keyword">Файлы типа "сокет"</SPAN> будут введены в семинарах 15–16, когда мы будем рассматривать вопросы сетевого программирования в UNIX.</P><DIV class="lecture_mark" id="mark_15"></DIV><P id="id_16">Файлы всех перечисленных типов логически объединены в ациклический <SPAN class="keyword">граф</SPAN> с однонаправленными ребрами, получающийся из дерева в результате сращивания нескольких терминальных узлов дерева или нескольких его нетерминальных узлов таким образом, чтобы полученный <SPAN class="keyword">граф</SPAN> не содержал циклов. В нетерминальных узлах такого ациклического <SPAN class="keyword">графа</SPAN> (т.е. в узлах, из которых выходят ребра) могут располагаться только файлы типов "<SPAN class="keyword">директория</SPAN>" и <SPAN class="keyword">"связь"</SPAN>. Причем из узла, в котором располагается <SPAN class="keyword">файл типа "связь"</SPAN>, может выходить только ровно одно ребро. В терминальных узлах этого ациклического <SPAN class="keyword">графа</SPAN> (т.е. в узлах, из которых не выходит ребер) могут располагаться файлы любых типов 
(см. <A href="http://www.intuit.ru/department/os/osintropractice/8/osintropractice_8.html#image.11-12.1">рис. 11–12.1</A>), хотя присутствие 
в терминальном узле <SPAN class="keyword">файла типа "связь"</SPAN> обычно говорит о некотором нарушении целостности файловой системы. </P><DIV class="lecture_mark" id="mark_16"></DIV><P align="left" id="id_17"><A name="image.11-12.1"></A></P><DIV><IMG src="./8. Организация файловой системы в UNIX. Работа с файлами и директориями. Понятие о memory mapped файлах_files/11-12-1.gif" alt="Пример графа файловой системы" width="447" height="244"></DIV><BR><B>Рис. 11-12.1.</B>&nbsp;
        Пример графа файловой системы<P></P><DIV class="lecture_mark" id="mark_17"></DIV><P id="id_18">В отличие от древовидной структуры набора файлов, где имена файлов связывались с узлами дерева, в таком ациклическом <SPAN class="keyword">графе</SPAN> имя файла связывается не с узлом, соответствующим файлу, а с входящим в него ребром. Ребра, выходящие из узлов, соответствующих <SPAN class="keyword">файлам типа "связь"</SPAN>, являются неименованными. Надо отметить, что практически во всех существующих реализациях UNIX-подобных систем в узел <SPAN class="keyword">графа</SPAN>, соответствующий файлу типа "<SPAN class="keyword">директория</SPAN>", не может входить более одного именованного ребра, хотя стандарт на операционную систему UNIX и не запрещает этого. Правила построения имен ребер (файлов) рассматривались в семинарах 1-2. В качестве <SPAN class="keyword">полного имени файла</SPAN> может использоваться любое имя, получающееся при прохождении по ребрам от корневого узла <SPAN class="keyword">графа</SPAN> 
(т.е. узла, в который не входит ни одно ребро) до узла, соответствующего этому файлу, по любому пути с помощью следующего алгоритма:</P><DIV class="lecture_mark" id="mark_18"></DIV><OL id="id_19"><LI>Если интересующему нас файлу соответствует корневой узел, то файл имеет имя "<SPAN class="texample">/</SPAN>". </LI><LI>Берем первое именованное ребро в пути и записываем его имя, которому предваряем символ "<SPAN class="texample">/</SPAN>". </LI><LI>Для каждого очередного именованного ребра в пути приписываем к уже получившейся строке справа символ "<SPAN class="texample">/</SPAN>" и имя соответствующего ребра. </LI></OL><DIV class="lecture_mark" id="mark_19"></DIV><P id="id_26"><SPAN class="keyword">Полное имя</SPAN> является уникальным для всей файловой системы и однозначно определяет соответствующий ему файл.</P><DIV class="lecture_mark" id="mark_26"></DIV><A name="sect4"></A><H3>Организация файла на диске в UNIX на примере файловой системы s5fs. Понятие индексного узла (inode) </H3><P id="id_27">Рассмотрим, как организуется на физическом носителе любой файл в UNIX на примере простой файловой системы, впервые появившейся в вариантах операционной системы System V и носящей поэтому название <SPAN class="keyword">s5fs (System V file system)</SPAN>. </P><DIV class="lecture_mark" id="mark_27"></DIV><P id="id_28">Все дисковое пространство раздела в <SPAN class="keyword">файловой системе s5fs</SPAN> логически разделяется на две части: <SPAN class="keyword">заголовок раздела</SPAN> и <B>логические блоки данных</B>. <A name="keyword-context.2"></A><SPAN class="keyword_def">Заголовок раздела</SPAN> содержит служебную информацию, необходимую для работы файловой системы, и обычно располагается в самом начале раздела. Логические блоки хранят собственно содержательную информацию файлов и часть информации о размещении файлов на диске (т.е. какие логические блоки и в каком порядке содержат информацию, записанную в файл). </P><DIV class="lecture_mark" id="mark_28"></DIV><P id="id_29">Для размещения любого файла на диске используется метод <SPAN class="keyword">индексных узлов</SPAN> (<SPAN class="keyword">inode</SPAN> – от index node), о котором подробно рассказывается в лекции 12 (раздел "Методы выделения дискового пространства"), и на котором здесь мы останавливаться не будем. <SPAN class="keyword">Индексный узел</SPAN> содержит <SPAN class="keyword">атрибуты файла</SPAN> и оставшуюся часть информации о его размещении на диске. Необходимо, однако, отметить, что такие типы файлов, как <SPAN class="keyword">"связь"</SPAN>, <SPAN class="keyword">"сокет"</SPAN>, <SPAN class="keyword">"устройство"</SPAN>, <SPAN class="keyword">"FIFO"</SPAN> не занимают на диске никакого иного места, кроме <SPAN class="keyword">индексного узла</SPAN> (им не выделяется логических блоков). Все необходимое для работы с этими типами файлов содержится в их 
<SPAN class="keyword">атрибутах</SPAN>.</P><DIV class="lecture_mark" id="mark_29"></DIV><P id="id_30">Перечислим часть <SPAN class="keyword">атрибутов файлов</SPAN>, хранящихся в <SPAN class="keyword">индексном узле</SPAN> и свойственных большинству типов файлов. К таким <SPAN class="keyword">атрибутам</SPAN> относятся: </P><DIV class="lecture_mark" id="mark_30"></DIV><UL id="id_31"><LI>Тип файла и права различных категорий пользователей для доступа к нему. </LI><LI>Идентификаторы владельца-пользователя и владельца-группы. </LI><LI>Размер файла в байтах (только для <SPAN class="keyword">регулярных файлов</SPAN>, директорий и <SPAN class="keyword">файлов типа "связь"</SPAN>). </LI><LI>Время последнего доступа к файлу. </LI><LI>Время последней модификации файла. </LI><LI>Время последней модификации самого <SPAN class="keyword">индексного узла</SPAN>. </LI></UL><DIV class="lecture_mark" id="mark_31"></DIV><P id="id_38">Существует еще один <SPAN class="keyword">атрибут</SPAN>, о котором мы поговорим в этих семинарах позже, когда мы будем рассматривать операцию связывания файлов в разделе "Системные вызовы и команды для выполнения <SPAN class="keyword">операций над файлами</SPAN> и директориями" . Количество <SPAN class="keyword">индексных узлов</SPAN> в разделе является постоянной величиной, определяемой на этапе генерации файловой системы. Все <SPAN class="keyword">индексные узлы</SPAN> системы организованы в виде <SPAN class="keyword">массива</SPAN>, хранящегося в <SPAN class="keyword">заголовке раздела</SPAN>. Каждому файлу соответствует только один элемент этого массива и, наоборот, каждому непустому элементу этого массива соответствует только один файл. Таким образом, каждый файл на диске может быть однозначно идентифицирован номером своего <SPAN class="keyword">индексного узла</SPAN> (его индексом в массиве). </P><DIV class="lecture_mark" id="mark_38"></DIV><P id="id_39">На языке представления логической организации файловой системы в виде <SPAN class="keyword">графа</SPAN> это означает, что каждому узлу <SPAN class="keyword">графа</SPAN> соответствует только один номер <SPAN class="keyword">индексного узла</SPAN>, и никакие два узла <SPAN class="keyword">графа</SPAN> не могут иметь одинаковые номера. </P><DIV class="lecture_mark" id="mark_39"></DIV><P id="id_40">Надо отметить, что свойством уникальности номеров <SPAN class="keyword">индексных узлов</SPAN>, идентифицирующих файлы, мы уже неявно пользовались при работе с именоваными pip'ами (семинар 5, раздел "Понятие FIFO. Использование системного вызова <SPAN class="texample">mknod()</SPAN> для создания FIFO. Функция <SPAN class="texample">mkfifo()</SPAN>") и средствами System V IPC (семинары 6–7, раздел "Понятие о System V IPC"). Для именованного pip'a именно номер <SPAN class="keyword">индексного узла</SPAN>, соответствующего <SPAN class="keyword">файлу с типом FIFO</SPAN>, является той самой точкой привязки, пользуясь которой, неродственные процессы могут получить данные о расположении pip'а в адресном пространстве ядра и его состоянии и связаться друг с другом. Для средств System V IPC при генерации IPC-ключа с помощью функции <SPAN class="texample">ftok()</SPAN> в действительности используется не имя заданного файла, а номер соответствующего ему индексного дескриптора, который по определенному алгоритму 
объединяется с номером экземпляра средства связи.</P><DIV class="lecture_mark" id="mark_40"></DIV><A name="sect5"></A><H3>Организация директорий (каталогов) в UNIX </H3><P id="id_44">Содержимое <SPAN class="keyword">регулярных файлов</SPAN> (информация, находящаяся в них, и способ ее организации) всецело определяется программистом, создающим файл. В отличие от <SPAN class="keyword">регулярных</SPAN>, остальные типы файлов, содержащих данные, т. е. <SPAN class="keyword">директории</SPAN> и связи, имеют жестко заданную структуру и содержание, определяемые типом используемой файловой системы. </P><DIV class="lecture_mark" id="mark_44"></DIV><P id="id_45">Основным содержимым файлов типа "<SPAN class="keyword">директория</SPAN>", если говорить на пользовательском языке, являются имена файлов, лежащих непосредственно в этих <SPAN class="keyword">директориях</SPAN>, и соответствующие им номера <SPAN class="keyword">индексных узлов</SPAN>. В терминах представления в виде <SPAN class="keyword">графа</SPAN> содержимое <SPAN class="keyword">директорий</SPAN> представляет собой имена ребер, выходящих из узлов, соответствующих <SPAN class="keyword">директориям</SPAN>, вместе с индексными номерами узлов, к которым они ведут.</P><DIV class="lecture_mark" id="mark_45"></DIV><P id="id_46">В <SPAN class="keyword">файловой системе s5fs</SPAN> пространство имен файлов (ребер) содержит имена длиной не более 14 символов, а максимальное количество <SPAN class="keyword">inode</SPAN> в одном разделе файловой системы не может превышать значения 65535. Эти ограничения не позволяют давать файлам осмысленные имена и приводят к необходимости разбиения больших жестких дисков на несколько разделов. Зато они помогают упростить структуру хранения информации в <SPAN class="keyword">директории</SPAN>. Все содержимое <SPAN class="keyword">директории</SPAN> представляет собой таблицу, в которой каждый элемент имеет фиксированный размер в 16 байт. Из них 14 байт отводится под имя соответствующего файла (ребра), а 2 байта – под номер его <SPAN class="keyword">индексного узла</SPAN>. При этом первый элемент таблицы дополнительно содержит ссылку на саму данную <SPAN class="keyword">директорию</SPAN> под именем "<SPAN class="texample">.</SPAN>", а 
второй элемент таблицы – ссылку на родительский каталог (если он существует), т.е. на узел <SPAN class="keyword">графа</SPAN>, из которого выходит единственное именованное ребро, ведущее к текущему узлу, под именем "<SPAN class="texample">..</SPAN>".</P><DIV class="lecture_mark" id="mark_46"></DIV><P id="id_49">В более современной файловой системе <B>FFS</B> (<B>F</B>ast <B>F</B>ile <B>S</B>ystem) размерность пространства имен файлов (ребер) увеличена до 255 символов. Это позволило использовать практически любые мыслимые имена для файлов (вряд ли найдется программист, которому будет не лень набирать для имени более 255 символов), но пришлось изменить структуру каталога (чтобы уменьшить его размеры и не хранить пустые байты). В системе FFS каталог представляет собой таблицу из записей переменной длины. В структуру каждой записи входят: номер <SPAN class="keyword">индексного узла</SPAN>, длина этой записи, длина имени файла и собственно его имя. Две первых записи в каталоге, как и в <SPAN class="keyword">s5fs</SPAN>, по-прежнему адресуют саму данную <SPAN class="keyword">директорию</SPAN> и ее родительский каталог.</P><DIV class="lecture_mark" id="mark_49"></DIV><A name="sect6"></A><H3>Понятие суперблока</H3><P id="id_50">Мы уже коснулись содержимого <SPAN class="keyword">заголовка раздела</SPAN>, когда говорили о <SPAN class="keyword">массиве индексных узлов</SPAN> файловой системы. Оставшуюся часть <SPAN class="keyword">заголовка</SPAN> в <SPAN class="keyword">s5fs</SPAN> принято называть <SPAN class="keyword">суперблоком</SPAN>. <A name="keyword-context.3"></A><SPAN class="keyword_def">Суперблок</SPAN> хранит информацию, необходимую для правильного функционирования файловой системы в целом. В нем содержатся, в частности, следующие данные.</P><DIV class="lecture_mark" id="mark_50"></DIV><UL id="id_51"><LI>Тип файловой системы. </LI><LI>Флаги состояния файловой системы. </LI><LI>Размер логического блока в байтах (обычно кратен 512 байтам). </LI><LI>Размер файловой системы в логических блоках (включая сам <SPAN class="keyword">суперблок</SPAN> и <SPAN class="keyword">массив inode</SPAN>). </LI><LI>Размер <SPAN class="keyword">массива индексных узлов</SPAN> (т.е. сколько файлов может быть размещено в файловой системе). </LI><LI>Число свободных <SPAN class="keyword">индексных узлов</SPAN> (сколько файлов еще можно создать). </LI><LI>Число свободных блоков для размещения данных. </LI><LI>Часть списка свободных <SPAN class="keyword">индексных узлов</SPAN>. </LI><LI>Часть списка свободных блоков для размещения данных. </LI></UL><DIV class="lecture_mark" id="mark_51"></DIV><P id="id_61">В некоторых модификациях <SPAN class="keyword">файловой системы s5fs</SPAN> последние два списка выносятся за пределы <SPAN class="keyword">суперблока</SPAN>, но остаются в <SPAN class="keyword">заголовке раздела</SPAN>. При первом же обращении к файловой системе <SPAN class="keyword">суперблок</SPAN> обычно целиком считывается в адресное пространство ядра для ускорения последующих обращений. Поскольку количество логических блоков и <SPAN class="keyword">индексных узлов</SPAN> в файловой системе может быть весьма большим, нецелесообразно хранить списки свободных блоков и узлов в <SPAN class="keyword">суперблоке</SPAN> полностью. При работе с <SPAN class="keyword">индексными узлами</SPAN> часть списка свободных узлов, находящаяся в <SPAN class="keyword">суперблоке</SPAN>, постепенно убывает. Когда список почти исчерпан, операционная система сканирует <SPAN class="keyword">массив индексных 
узлов</SPAN> и заново заполняет список. Часть списка свободных логических блоков, лежащая в <SPAN class="keyword">суперблоке</SPAN>, содержит ссылку на продолжение списка, расположенное где-либо в блоках данных. Когда эта часть оказывается использованной, операционная система загружает на освободившееся место продолжение списка, а блок, применявшийся для его хранения, переводится в разряд свободных. </P><DIV class="lecture_mark" id="mark_61"></DIV><A name="sect7"></A><H3>Операции над файлами и директориями</H3><P id="id_62">Хотя с точки зрения пользователя рассмотрение <SPAN class="keyword">операций над файлами</SPAN> и <SPAN class="keyword">директориями</SPAN> представляется достаточно простым и сводится к перечислению ряда системных вызовов и команд операционной системы, попытка систематического подхода к набору операций вызывает определенные затруднения. Далее речь пойдет в основном о <SPAN class="keyword">регулярных файлах</SPAN> и файлах типа "<SPAN class="keyword">директория</SPAN>".</P><DIV class="lecture_mark" id="mark_62"></DIV><P id="id_63">В лекции (лекция 11, раздел "Организация файлов и доступ к ним") речь шла о том, что существует два основных вида файлов, различающихся по методу доступа: файлы последовательного доступа и файлы прямого доступа. Если рассматривать файлы прямого и последовательного доступа как абстрактные типы данных, то они представляются как нечто, содержащее информацию, над которой можно совершать следующие <SPAN class="keyword">операции</SPAN>: </P><DIV class="lecture_mark" id="mark_63"></DIV><UL id="id_64"><LI>Для последовательного доступа: чтение очередной порции данных (<SPAN class="texample">read</SPAN>), запись очередной порции данных (<SPAN class="texample">write</SPAN>) и позиционирование на начале файла (<SPAN class="texample">rewind</SPAN>). </LI><LI>Для прямого доступа: чтение очередной порции данных (<SPAN class="texample">read</SPAN>), запись очередной порции данных (<SPAN class="texample">write</SPAN>) и позиционирование на требуемой части данных (<SPAN class="texample">seek</SPAN>). </LI></UL><DIV class="lecture_mark" id="mark_64"></DIV><P id="id_73">Работа с объектами этих абстрактных типов подразумевает наличие еще двух необходимых операций: создание нового объекта (<SPAN class="texample">new</SPAN>) и уничтожение существующего объекта (<SPAN class="texample">free</SPAN>).</P><DIV class="lecture_mark" id="mark_73"></DIV><P id="id_76">Расширение математической модели файла за счет добавления к хранимой информации атрибутов, присущих файлу (права доступа, учетные данные), влечет за собой появление еще двух <SPAN class="keyword">операций</SPAN>: прочитать атрибуты (<SPAN class="texample">get attribute</SPAN>) и установить их значения (<SPAN class="texample">set attribute</SPAN>).</P><DIV class="lecture_mark" id="mark_76"></DIV><P id="id_79">Наделение файлов какой-либо внутренней структурой (как у файла типа "<SPAN class="keyword">директория</SPAN>") или наложение на набор файлов внешней логической структуры (объединение в ациклический направленный <SPAN class="keyword">граф</SPAN>) приводит к появлению других наборов операций, составляющих интерфейс работы с файлами, которые, тем не менее, будут являться комбинациями перечисленных выше базовых операций. </P><DIV class="lecture_mark" id="mark_79"></DIV><P id="id_80">Для <SPAN class="keyword">директории</SPAN>, например, такой набор <SPAN class="keyword">операций</SPAN>, определяемый ее внутренним строением, может выглядеть так: <SPAN class="keyword">операции</SPAN> <SPAN class="texample">new</SPAN>, <SPAN class="texample">free</SPAN>, <SPAN class="texample">set attribute</SPAN> и <SPAN class="texample">get attribute</SPAN> остаются без изменений, а <SPAN class="keyword">операции</SPAN> <SPAN class="texample">read</SPAN>, <SPAN class="texample">write</SPAN> и <SPAN class="texample">rewind</SPAN> (<SPAN class="texample">seek</SPAN>) заменяются более высокоуровневыми: </P><DIV class="lecture_mark" id="mark_80"></DIV><UL id="id_89"><LI>прочитать запись, соответствующую имени файла, – <SPAN class="texample">get record</SPAN>; </LI><LI>добавить новую запись – <SPAN class="texample">add record</SPAN>; </LI><LI>удалить запись, соответствующую имени файла, – <SPAN class="texample">delete record</SPAN>. </LI></UL><DIV class="lecture_mark" id="mark_89"></DIV><P id="id_96">Неполный набор операций над файлами, связанный с их логическим объединением в структуру <SPAN class="keyword">директорий</SPAN>, будет выглядеть следующим образом:</P><DIV class="lecture_mark" id="mark_96"></DIV><UL id="id_97"><LI>Операции для работы с <SPAN class="keyword">атрибутами файлов</SPAN> – <SPAN class="texample">get attribute</SPAN>, <SPAN class="texample">set attribute</SPAN>. </LI><LI>Операции для работы с содержимым файлов – <SPAN class="texample">read</SPAN>, <SPAN class="texample">write</SPAN>, <SPAN class="texample">rewind(seek)</SPAN> для <SPAN class="keyword">регулярных файлов</SPAN> и <SPAN class="texample">get record</SPAN>, <SPAN class="texample">add record</SPAN>, <SPAN class="texample">delete record</SPAN> для <SPAN class="keyword">директорий</SPAN>. </LI><LI>Операция создания <SPAN class="keyword">регулярного файла</SPAN> в некоторой <SPAN class="keyword">директории</SPAN> (создание нового узла <SPAN class="keyword">графа</SPAN> и добавление в <SPAN class="keyword">граф</SPAN> нового именованного ребра, ведущего в этот узел из некоторого узла, соответствующего <SPAN class="keyword">директории</SPAN>) – <SPAN class="texample">create</SPAN>. Эту операцию можно рассматривать как суперпозицию двух операций: базовой операции <SPAN class="texample">new</SPAN> для <SPAN class="keyword">регулярного файла</SPAN> и <SPAN class="texample">add record</SPAN> для соответствующей <SPAN class="keyword">директории</SPAN>. </LI><LI><SPAN class="keyword">Операция</SPAN> создания поддиректории в некоторой <SPAN class="keyword">директории</SPAN> – <SPAN class="texample">make directory</SPAN>. Эта <SPAN class="keyword">операция</SPAN> отличается от предыдущей операции <SPAN class="texample">create</SPAN> занесением в файл новой <SPAN class="keyword">директории</SPAN> информации о файлах с именами "<SPAN class="texample">.</SPAN>" и "<SPAN class="texample">..</SPAN>", т.е. по сути дела она есть суперпозиция операции <SPAN class="texample">create</SPAN> и двух операций <SPAN class="texample">add record</SPAN>. </LI><LI>Операция создания <SPAN class="keyword">файла типа "связь"</SPAN> – <SPAN class="texample">symbolic link</SPAN>. </LI><LI>Операция создания <SPAN class="keyword">файла типа "FIFO"</SPAN> – <SPAN class="texample">make FIFO</SPAN>. </LI><LI>Операция добавления к <SPAN class="keyword">графу</SPAN> нового именованного ребра, ведущего от узла, соответствующего <SPAN class="keyword">директории</SPAN>, к узлу, соответствующему любому другому типу файла, – <SPAN class="texample">link</SPAN>. Это просто <SPAN class="texample">add record</SPAN> с некоторыми ограничениями. </LI><LI>Операция удаления файла, не являющегося <SPAN class="keyword">директорией</SPAN> или "связью" (удаление именованного ребра из <SPAN class="keyword">графа</SPAN>, ведущего к терминальной вершине с одновременным удалением этой вершины, если к ней не ведут другие именованные ребра), – <SPAN class="texample">unlink</SPAN>. </LI><LI>Операция удаления <SPAN class="keyword">файла типа "связь"</SPAN> (удаление именованного ребра, ведущего к узлу, соответствующему <SPAN class="keyword">файлу типа "связь"</SPAN>, с одновременным удалением этого узла и выходящего из него неименованного ребра, если к этому узлу не ведут другие именованные ребра), – <SPAN class="texample">unlink link</SPAN>. </LI><LI><SPAN class="keyword">Операция</SPAN> рекурсивного удаления <SPAN class="keyword">директории</SPAN> со всеми входящими в нее файлами и поддиректориями – <SPAN class="texample">remove directory</SPAN>. </LI><LI>Операция переименования файла (ребра <SPAN class="keyword">графа</SPAN>) – <SPAN class="texample">rename</SPAN>. </LI><LI>Операция перемещения файла из одной <SPAN class="keyword">директории</SPAN> в другую (перемещается точка выхода именованного ребра, которое ведет к узлу, соответствующему данному файлу) – <SPAN class="texample">move</SPAN>. </LI></UL><DIV class="lecture_mark" id="mark_97"></DIV><P id="id_136">Возможны и другие подобные операции. </P><DIV class="lecture_mark" id="mark_136"></DIV><P id="id_137">Способ реализации файловой системы в реальной операционной системе также может добавлять новые операции. Если часть информации файловой системы или отдельного файла кэшируется в адресном пространстве ядра, то появляются операции синхронизации данных в кэше и на диске для всей системы в целом (<SPAN class="texample">sync</SPAN>) и для отдельного файла (<SPAN class="texample">sync file</SPAN>). </P><DIV class="lecture_mark" id="mark_137"></DIV><P id="id_140">Естественно, что все перечисленные операции могут быть выполнены процессом только при наличии у него определенных полномочий (прав доступа и т.д.). Для выполнения операций над файлами и <SPAN class="keyword">директориями</SPAN> операционная система предоставляет процессам интерфейс в виде системных вызовов, библиотечных функций и команд операционной системы. Часть этих системных вызовов, функций и команд мы рассмотрим в следующих разделах. </P><DIV class="lecture_mark" id="mark_140"></DIV><A name="sect8"></A><H3>Системные вызовы и команды для выполнения операций над файлами и директориями </H3><P id="id_141">В материалах предыдущих семинаров уже говорилось о некоторых командах и системных вызовах, позволяющих выполнять операции над файлами в операционной системе UNIX.</P><DIV class="lecture_mark" id="mark_141"></DIV><P id="id_142">В семинарах 1-2 рассматривался ряд команд, позволяющих изменять <SPAN class="keyword">атрибуты файла</SPAN> – <SPAN class="texample"><SPAN class="keyword">chmod</SPAN></SPAN>, <SPAN class="texample"><SPAN class="keyword">chown</SPAN></SPAN>, <SPAN class="texample"><SPAN class="keyword">chgrp</SPAN></SPAN>, команду копирования файлов и <SPAN class="keyword">директорий</SPAN> – <SPAN class="texample"><SPAN class="keyword">cp</SPAN></SPAN>, команду удаления файлов и <SPAN class="keyword">директорий</SPAN> – <SPAN class="texample"><SPAN class="keyword">rm</SPAN></SPAN>, команду переименования и перемещения файлов и <SPAN class="keyword">директорий</SPAN> – <SPAN class="texample"><SPAN class="keyword">mv</SPAN></SPAN>, команду просмотра содержимого <SPAN class="keyword">директорий</SPAN> – <SPAN class="texample"><SPAN class="keyword">ls</SPAN></SPAN>.</P><DIV class="lecture_mark" id="mark_142"></DIV><P id="id_150">В материалах семинара 5, посвященного потокам ввода-вывода, рассказывалось о хранении информации о файлах внутри адресного пространства процесса с помощью <SPAN class="keyword">таблицы открытых файлов</SPAN>, о понятии файлового дескриптора, о необходимости введения операций открытия и закрытия файлов (системные вызовы <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">close()</SPAN></SPAN>) и об операциях чтения и записи (системные вызовы <SPAN class="texample"><SPAN class="keyword">read()</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">write()</SPAN></SPAN>). Мы обещали вернуться к более подробному рассмотрению затронутых вопросов в текущих семинарах. Пора выполнять обещанное. Далее в этом разделе, если не будет оговорено особо, под словом "файл" будет подразумеваться <SPAN class="keyword">регулярный файл</SPAN>.</P><DIV class="lecture_mark" id="mark_150"></DIV><P id="id_155">Вся информация об <SPAN class="keyword">атрибутах файла</SPAN> и его расположении на физическом носителе содержится в соответствующем файлу <SPAN class="keyword">индексном узле</SPAN> и, возможно, в нескольких связанных с ним логических блоках. Для того чтобы при каждой операции над файлом не считывать эту информацию с физического носителя заново, представляется логичным, считав информацию один раз при первом обращении к файлу, хранить ее в адресном пространстве процесса или в части адресного пространства ядра, характеризующей данный процесс. Именно поэтому в лекции 2 данные о файлах, используемых процессом, были отнесены к составу системного контекста процесса, содержащегося в его PCB.</P><DIV class="lecture_mark" id="mark_155"></DIV><P id="id_156">С точки зрения пользовательского процесса каждый файл представляет собой линейный набор байт, снабженный <SPAN class="keyword">указателем текущей позиции</SPAN> процесса в этом наборе. Все операции чтения из файла и записи в файл производятся в этом наборе с того места, на которое показывает <SPAN class="keyword">указатель текущей позиции</SPAN>. По завершении операции чтения или записи <SPAN class="keyword">указатель текущей позиции</SPAN> помещается после конца прочитанного или записанного участка файла. Значение этого указателя является динамической характеристикой файла для использующего его процесса и также должно храниться в PCB.</P><DIV class="lecture_mark" id="mark_156"></DIV><P id="id_157">На самом деле организация информации, описывающей открытые файлы в адресном пространстве ядра операционной системы UNIX, является более сложной.</P><DIV class="lecture_mark" id="mark_157"></DIV><P id="id_158">Некоторые файлы могут использоваться одновременно несколькими процессами независимо друг от друга или совместно. Для того чтобы не хранить дублирующуюся информацию об <SPAN class="keyword">атрибутах файлов</SPAN> и их расположении на внешнем носителе для каждого процесса отдельно, такие данные обычно размещаются в адресном пространстве ядра операционной системы в единственном экземпляре, а доступ к ним процессы получают только при выполнении соответствующих системных вызовов для операций над файлами. </P><DIV class="lecture_mark" id="mark_158"></DIV><P id="id_159">Независимое использование одного и того же файла несколькими процессами в операционной системе UNIX предполагает возможность для каждого процесса совершать операции чтения и записи в файл по своему усмотрению. При этом для корректной работы с информацией необходимо организовывать взаимоисключения для операций ввода-вывода. Совместное использование одного и того же файла в операционной системе UNIX возможно для близко родственных процессов, т.е. процессов, один из которых является потомком другого или которые имеют общего родителя. При совместном использовании файла процессы разделяют некоторые данные, необходимые для работы с файлом, в частности, <SPAN class="keyword">указатель текущей позиции</SPAN>. Операции чтения или записи, выполненные в одном процессе, изменяют значение <SPAN class="keyword">указателя текущей позиции</SPAN> во всех близко родственных процессах, одновременно использующих этот файл.</P><DIV class="lecture_mark" id="mark_159"></DIV><P id="id_160">Как мы видим, вся информация о файле, необходимая процессу для работы с ним, может быть разбита на три части: </P><DIV class="lecture_mark" id="mark_160"></DIV><UL id="id_161"><LI>данные, специфичные для этого процесса; </LI><LI>данные, общие для близко родственных процессов, совместно использующих файл, например, <SPAN class="keyword">указатель текущей позиции</SPAN>; </LI><LI>данные, являющиеся общими для всех процессов, использующих файл, – <SPAN class="keyword">атрибуты</SPAN> и расположение файла. </LI></UL><DIV class="lecture_mark" id="mark_161"></DIV><P align="left" id="id_165"><A name="image.11-12.2"></A></P><DIV><IMG src="./8. Организация файловой системы в UNIX. Работа с файлами и директориями. Понятие о memory mapped файлах_files/11-12-2.gif" alt="Взаимосвязи между таблицами, содержащими  данные об открытых файлах в системе" width="447" height="445"></DIV><BR><B>Рис. 11-12.2.</B>&nbsp;
        Взаимосвязи между таблицами, содержащими  данные об открытых файлах в системе<P></P><DIV class="lecture_mark" id="mark_165"></DIV><P id="id_166">Естественно, что <A name="keyword-context.4"></A>для хранения этой информации применяются три различные связанные структуры данных, лежащие, как правило, в адресном пространстве ядра операционной системы, – <SPAN class="keyword">таблица открытых файлов процесса</SPAN>, <SPAN class="keyword">системная таблица открытых файлов</SPAN> и <SPAN class="keyword">таблица индексных узлов открытых файлов</SPAN>. Для доступа к этой информации в управляющем блоке процесса заводится <SPAN class="keyword_def">таблица открытых файлов</SPAN>, каждый непустой элемент которой содержит ссылку на соответствующий элемент <SPAN class="keyword">системной таблицы открытых файлов</SPAN>, содержащей данные, необходимые для совместного использования файла близко родственными процессами. Из <SPAN class="keyword">системной таблицы открытых файлов</SPAN> мы, в свою очередь, 
можем по ссылке добраться до общих данных о файле, содержащихся в <SPAN class="keyword">таблице индексных узлов открытых файлов</SPAN> (см. <A href="http://www.intuit.ru/department/os/osintropractice/8/osintropractice_8.html#image.11-12.2">рис. 11–12.2</A>). Только <SPAN class="keyword">таблица открытых файлов процесса</SPAN> входит в состав его PCB и, соответственно, наследуется при рождении нового процесса. Индекс элемента в этой таблице (небольшое целое неотрицательное число) или файловый дескриптор является той величиной, характеризующей файл, которой может оперировать процесс при работе на уровне пользователя. В эту же <SPAN class="keyword">таблицу открытых файлов</SPAN> помещаются и ссылки на данные, описывающие другие потоки ввода-вывода, такие как pipe и FIFO (об этом уже упоминалось в семинаре 5). Как мы увидим позже (в материалах семинаров 15–16, посвященных сетевому программированию), эта же таблица будет использоваться и для размещения ссылок на структуры данных, 
необходимых для передачи информации от процесса к процессу по сети.</P><DIV class="lecture_mark" id="mark_166"></DIV><P id="id_167"><B>Системный вызов</B> <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN>. Для выполнения большинства операций над файлами через системные вызовы пользовательский процесс обычно должен указать в качестве одного из параметров системного вызова дескриптор файла, над которым нужно совершить операцию. Поэтому, прежде чем совершать операции, мы должны поместить информацию о файле в наши таблицы файлов и определить соответствующий файловый дескриптор. Для этого, как уже говорилось в семинаре 5, применяется процедура открытия файла, осуществляемая системным вызовом <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN>. При открытии файла операционная система проверяет, соответствуют ли права, которые запросил процесс для операций над файлом, правам доступа, установленным для этого файла. В случае соответствия она помещает необходимую информацию в <SPAN class="keyword">системную таблицу файлов</SPAN> и, если этот файл не был ранее открыт другим процессом, в таблицу индексных дескрипторов открытых файлов. Далее операционная система находит пустой элемент в <SPAN class="keyword">таблице открытых файлов</SPAN> процесса, устанавливает необходимую связь между всеми тремя таблицами и возвращает на пользовательский уровень дескриптор этого файла.</P><DIV class="lecture_mark" id="mark_167"></DIV><P id="id_170">По сути дела, с помощью операции открытия файла операционная система осуществляет отображение из пространства имен файлов в дисковое пространство файловой системы, подготавливая почву для выполнения других операций. </P><DIV class="lecture_mark" id="mark_170"></DIV><P id="id_171"><B>Системный вызов</B> <SPAN class="texample"><SPAN class="keyword">close()</SPAN></SPAN>. Обратным системным вызовом по отношению к системному вызову <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN> является системный вызов <SPAN class="texample"><SPAN class="keyword">close()</SPAN></SPAN>, с которым мы уже познакомились. После завершения работы с файлом процесс освобождает выделенные ресурсы операционной системы и, возможно, синхронизирует информацию о файле, содержащуюся в <SPAN class="keyword">таблице индексных узлов открытых файлов</SPAN>, с информацией на диске, используя этот системный вызов. Надо отметить, что место в <SPAN class="keyword">таблице индексных узлов открытых файлов</SPAN> не освобождается по системному вызову <SPAN class="texample"><SPAN class="keyword">close()</SPAN></SPAN> до тех пор, пока в системе существует хотя бы один процесс, использующий этот файл. Для обеспечения такого поведения в ней для каждого <SPAN class="keyword">индексного узла</SPAN> заводится счетчик числа открытий, увеличивающийся на 1 при каждом системном вызове <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN> для данного файла и уменьшающийся на 1 при каждом его закрытии. Очищение элемента <SPAN class="keyword">таблицы индексных узлов открытых файлов</SPAN> с окончательной синхронизацией данных в памяти и на диске происходит только в том случае, если при очередном закрытии файла этот счетчик становится равным <SPAN class="texample">0</SPAN>.</P><DIV class="lecture_mark" id="mark_171"></DIV><P id="id_178">Поведение <SPAN class="keyword">таблицы открытых файлов процесса</SPAN> и связанных с ней таблиц при системных вызовах <SPAN class="texample">exit()</SPAN>, <SPAN class="texample">exec()</SPAN> и <SPAN class="texample">fork()</SPAN> рассматривалось в материалах семинара 5. </P><DIV class="lecture_mark" id="mark_178"></DIV><P id="id_182"><B>Операция создания файла</B>. <B>Системный вызов</B> <SPAN class="texample"><SPAN class="keyword">creat()</SPAN></SPAN>. При обсуждении системного вызова <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN> подробно рассказывалось о его использовании для создания нового файла. Для этих же целей можно использовать системный вызов <SPAN class="texample"><SPAN class="keyword">creat()</SPAN></SPAN>, являющийся, по существу, урезанным вариантом вызова <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN> (о значении флага <SPAN class="texample">O_TRUNC</SPAN> для системного вызова <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN> будет сказано чуть ниже).</P><DIV class="lecture_mark" id="mark_182"></DIV><DIV class="xml_table_env" id="id_189"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_190"><B>Системный вызов creat()</B></P><DIV class="lecture_mark" id="mark_190"></DIV>

<P id="id_191"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_191"></DIV>

<DIV class="example"><PRE>#include &lt;fcntl.h&gt;

int creat(char *path, int mode); 
</PRE></DIV>

<P id="id_193"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_193"></DIV>

<P id="id_194">Системный вызов <SPAN class="texample"><SPAN class="keyword">creat</SPAN></SPAN> эквивалентен системному вызову <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN> с параметром <SPAN class="texample">flags</SPAN>, установленным в значение <SPAN class="texample">O_CREAT | O_WRONLY | O_TRUNC</SPAN>. </P><DIV class="lecture_mark" id="mark_194"></DIV>

<P id="id_199">Параметр <SPAN class="texample">path</SPAN> является указателем на строку, содержащую <SPAN class="keyword">полное</SPAN> или относительное имя файла.</P><DIV class="lecture_mark" id="mark_199"></DIV>

<P id="id_201">Если файла с указанным именем не существовало к моменту системного вызова, он будет создан и открыт только для выполнения операций записи. Если файл уже существовал, то он открывается также только для операции записи, при этом его длина уменьшается до 0 с одновременным сохранением всех других <SPAN class="keyword">атрибутов файла</SPAN>.</P><DIV class="lecture_mark" id="mark_201"></DIV>

<P id="id_202">Параметр <SPAN class="texample">mode</SPAN> устанавливает атрибуты прав доступа различных категорий пользователей к новому файлу при его создании. Этот параметр задается как сумма следующих восьмеричных значений:</P><DIV class="lecture_mark" id="mark_202"></DIV>

<UL id="id_204"><LI><SPAN class="texample">0400</SPAN>    – разрешено чтение для пользователя, создавшего файл.</LI><LI><SPAN class="texample">0200</SPAN>    – разрешена запись для пользователя, создавшего файл.</LI><LI><SPAN class="texample">0100</SPAN>    – разрешено исполнение для пользователя, создавшего файл.</LI><LI><SPAN class="texample">0040</SPAN>    – разрешено чтение для группы пользователя, создавшего файл.</LI><LI><SPAN class="texample">0020</SPAN>    – разрешена запись для группы пользователя, создавшего файл.</LI><LI><SPAN class="texample">0010</SPAN>    – разрешено исполнение для группы пользователя, создавшего файл.</LI><LI><SPAN class="texample">0004</SPAN>    – разрешено чтение для всех остальных пользователей</LI><LI><SPAN class="texample">0002</SPAN>    – разрешена запись для всех остальных пользователей</LI><LI><SPAN class="texample">0001</SPAN>    – разрешено исполнение для всех остальных пользователей</LI></UL><DIV class="lecture_mark" id="mark_204"></DIV>

<P id="id_223">При создании файла реально устанавливаемые права доступа получаются из стандартной комбинации параметра mode и маски создания файлов текущего процесса <SPAN class="texample">umask</SPAN>, а именно – они равны <SPAN class="texample">mode &amp; ~umask</SPAN>. </P><DIV class="lecture_mark" id="mark_223"></DIV>

<P id="id_226"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_226"></DIV>

<P id="id_227">Системный вызов возвращает значение файлового дескриптора для открытого файла при нормальном завершении и значение <SPAN class="texample">-1</SPAN> при возникновении ошибки. </P><DIV class="lecture_mark" id="mark_227"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_189"></DIV><P id="id_229"><B>Операция чтения</B> <SPAN class="keyword">атрибутов файла</SPAN>. <B>Системные вызовы</B> <SPAN class="texample"><SPAN class="keyword">stat()</SPAN></SPAN>, <SPAN class="texample"><SPAN class="keyword">fstat()</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">lstat()</SPAN></SPAN>. Для чтения всех <SPAN class="keyword">атрибутов файла</SPAN> в специальную структуру могут применяться системные вызовы <SPAN class="texample"><SPAN class="keyword">stat()</SPAN></SPAN>, <SPAN class="texample"><SPAN class="keyword">fstat()</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">lstat()</SPAN></SPAN>. Разъяснение понятий <SPAN class="keyword">жесткой</SPAN> и <SPAN class="keyword">мягкой (символической) связи</SPAN>, встречающихся в описании системных вызовов, будет дано позже при рассмотрении операций связывания файлов.</P><DIV class="lecture_mark" id="mark_229"></DIV><DIV class="xml_table_env" id="id_236"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_237"><B>Системные вызовы для чтения атрибутов файла</B></P><DIV class="lecture_mark" id="mark_237"></DIV>

<P id="id_238"><B>Прототипы системных вызовов</B></P><DIV class="lecture_mark" id="mark_238"></DIV>

<DIV class="example"><PRE>#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
int stat(char *filename, 
         struct stat *buf);
int fstat(int fd, struct stat *buf);
int lstat(char *filename, 
          struct stat *buf);
</PRE></DIV>

<P id="id_240"><B>Описание системных вызовов</B></P><DIV class="lecture_mark" id="mark_240"></DIV>

<P id="id_241">Настоящее описание не является полным описанием этих системных вызовов, а приспособлено для целей данного курса. Для получения полного описания обращайтесь в UNIX Manual. </P><DIV class="lecture_mark" id="mark_241"></DIV>

<P id="id_242">Системные вызовы <SPAN class="texample"><SPAN class="keyword">stat</SPAN></SPAN>, <SPAN class="texample"><SPAN class="keyword">fstat</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">lstat</SPAN></SPAN> служат для получения информации об <SPAN class="keyword">атрибутах файла</SPAN>. </P><DIV class="lecture_mark" id="mark_242"></DIV>

<P id="id_246">Системный вызов <SPAN class="texample"><SPAN class="keyword">stat</SPAN></SPAN> читает информацию об <SPAN class="keyword">атрибутах файла</SPAN>, на имя которого указывает параметр <SPAN class="texample">filename</SPAN>, и заполняет ими структуру, расположенную по адресу <SPAN class="texample">buf</SPAN>. Заметим, что имя файла должно быть <SPAN class="keyword">полным</SPAN>, либо должно строиться относительно той <SPAN class="keyword">директории</SPAN>, которая является текущей для процесса, совершившего вызов. Если имя файла относится к <SPAN class="keyword">файлу типа "связь"</SPAN>, то читается информация (рекурсивно!) об <SPAN class="keyword">атрибутах файла</SPAN>, на который указывает символическая связь.</P><DIV class="lecture_mark" id="mark_246"></DIV>

<P id="id_250">Системный вызов <SPAN class="texample"><SPAN class="keyword">lstat</SPAN></SPAN> идентичен системному вызову <SPAN class="texample"><SPAN class="keyword">stat</SPAN></SPAN> за одним исключением: если имя файла относится к <SPAN class="keyword">файлу типа "связь"</SPAN>, то читается информация о самом <SPAN class="keyword">файле типа "связь"</SPAN>.</P><DIV class="lecture_mark" id="mark_250"></DIV>

<P id="id_253">Системный вызов <SPAN class="texample"><SPAN class="keyword">fstat</SPAN></SPAN> идентичен системному вызову <SPAN class="texample"><SPAN class="keyword">stat</SPAN></SPAN>, только файл задается не именем, а своим файловым дескриптором (естественно, файл к этому моменту должен быть открыт).</P><DIV class="lecture_mark" id="mark_253"></DIV>

<P id="id_256">Для системных вызовов <SPAN class="texample"><SPAN class="keyword">stat</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">lstat</SPAN></SPAN> процессу не нужны никакие права доступа к указанному файлу, но могут понадобиться права для поиска во всех <SPAN class="keyword">директориях</SPAN>, входящих в специфицированное имя файла.</P><DIV class="lecture_mark" id="mark_256"></DIV>

<P id="id_259">Структура <SPAN class="texample"><SPAN class="keyword">stat</SPAN></SPAN> в различных версиях UNIX может быть описана по-разному. В Linux она содержит следующие поля: </P><DIV class="lecture_mark" id="mark_259"></DIV>

<DIV class="example"><PRE>struct stat {
dev_t st_dev; 
  /* устройство, на котором 
     расположен файл */
ino_t st_ino; 
  /* номер индексного узла для файла */ 
mode_t st_mode; 
  /* тип файла и права доступа к нему */
nlink_t st_nlink; 
  /* счетчик числа жестких связей */
uid_t st_uid; 
  /* идентификатор пользователя владельца */
gid_t st_gid; 
  /* идентификатор группы владельца */
dev_t st_rdev;
  /*тип устройства для специальных файлов 
    устройств*/
off_t st_size; 
  /* размер файла в байтах (если определен 
     для данного типа файлов) */
unsigned long st_blksize; 
  /* размер блока для файловой системы */
unsigned long st_blocks; 
  /* число выделенных блоков */
time_t st_atime; 
  /* время последнего доступа к файлу */
time_t st_mtime; 
  /* время последней модификации файла */
time_t st_ctime; 
  /* время создания файла */
}
</PRE></DIV>

<P id="id_262">Для определения типа файла можно использовать следующие логические макросы, применяя их к значению поля <SPAN class="texample">st_mode</SPAN>:     </P><DIV class="lecture_mark" id="mark_262"></DIV>

<UL id="id_264"><LI><SPAN class="texample">S_ISLNK(m)</SPAN>     – файл типа "связь"?</LI><LI><SPAN class="texample">S_ISREG(m)</SPAN>     – регулярный файл?</LI><LI><SPAN class="texample">S_ISDIR(m)</SPAN>     – директория?</LI><LI><SPAN class="texample">S_ISCHR(m)</SPAN>     – специальный файл символьного устройства?</LI><LI><SPAN class="texample">S_ISBLK(m)</SPAN>     – специальный файл блочного устройства?</LI><LI><SPAN class="texample">S_ISFIFO(m)</SPAN>     – файл типа FIFO?</LI><LI><SPAN class="texample">S_ISSOCK(m)</SPAN>     – файл типа "socket"?</LI></UL><DIV class="lecture_mark" id="mark_264"></DIV>

<P id="id_279">Младшие 9 бит поля <SPAN class="texample">st_mode</SPAN> определяют права доступа к файлу подобно тому, как это делается в маске создания файлов текущего процесса. </P><DIV class="lecture_mark" id="mark_279"></DIV>

<P id="id_281"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_281"></DIV>

<P id="id_282">Системные вызовы возвращают значение <SPAN class="texample">0</SPAN> при нормальном завершении и значение <SPAN class="texample">-1</SPAN> при возникновении ошибки. </P><DIV class="lecture_mark" id="mark_282"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_236"></DIV><P id="id_285"><B>Операции изменения</B> <SPAN class="keyword">атрибутов файла</SPAN>. Большинство операций изменения <SPAN class="keyword">атрибутов файла</SPAN> обычно выполняется пользователем в интерактивном режиме с помощью команд операционной системы. О них уже шла речь в материалах семинаров 1–2, и мы не будем возвращаться к ним вновь. Отметим только операцию изменения размеров файла, а точнее операцию его обрезания, без изменения всех других <SPAN class="keyword">атрибутов</SPAN>, кроме, быть может, времени последнего доступа к файлу и его последней модификации. Для того чтобы уменьшить размеры существующего файла до 0, не затрагивая остальных его характеристик (прав доступа, даты создания, учетной информации и т.д.), можно при открытии файла использовать в комбинации флагов системного вызова <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN> флаг <SPAN class="texample">O_TRUNC</SPAN>. Для изменения размеров файла до любой желаемой величины (даже для его увеличения 
во многих вариантах UNIX, хотя изначально этого не предусматривалось!) может использоваться системный вызов <SPAN class="texample"><SPAN class="keyword">ftruncate()</SPAN></SPAN>. При этом, если размер файла мы уменьшаем, то вся информация в конце файла, не влезающая в новый размер, будет потеряна. Если же размер файла мы увеличиваем, то это будет выглядеть так, как будто мы дополнили его до недостающего размера нулевыми байтами. </P><DIV class="lecture_mark" id="mark_285"></DIV><DIV class="xml_table_env" id="id_289"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_290"><B>Системный вызов ftruncate()</B></P><DIV class="lecture_mark" id="mark_290"></DIV>

<P id="id_291"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_291"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
int ftruncate(int fd, size_t length);
</PRE></DIV>

<P id="id_293"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_293"></DIV>

<P id="id_294">Системный вызов <SPAN class="texample"><SPAN class="keyword">ftruncate</SPAN></SPAN> предназначен для изменения длины открытого <SPAN class="keyword">регулярного файла</SPAN>. </P><DIV class="lecture_mark" id="mark_294"></DIV>

<P id="id_296">Параметр <SPAN class="texample">fd</SPAN> является дескриптором соответствующего файла, т. е. значением, которое вернул системный вызов <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN>.</P><DIV class="lecture_mark" id="mark_296"></DIV>

<P id="id_299">Параметр <SPAN class="texample">length</SPAN> – значение новой длины для этого файла. Если параметр <SPAN class="texample">length</SPAN> меньше, чем текущая длина файла, то вся информация в конце файла, не влезающая в новый размер, будет потеряна. Если же он больше, чем текущая длина, то файл будет выглядеть так, как будто мы дополнили его до недостающего размера нулевыми байтами.</P><DIV class="lecture_mark" id="mark_299"></DIV>

<P id="id_302"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_302"></DIV>

<P id="id_303">Системный вызов возвращает значение <SPAN class="texample">0</SPAN> при нормальном завершении и значение <SPAN class="texample">-1</SPAN> при возникновении ошибки.</P><DIV class="lecture_mark" id="mark_303"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_289"></DIV><P id="id_306"><B>Операции чтения из файла и записи в файл</B>. Для операций чтения из файла и записи в файл применяются системные вызовы <SPAN class="texample"><SPAN class="keyword">read()</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">write()</SPAN></SPAN>, которые мы уже обсуждали ранее (семинар 5, раздел "Системные вызовы <SPAN class="texample"><SPAN class="keyword">read()</SPAN></SPAN>, <SPAN class="texample"><SPAN class="keyword">write()</SPAN></SPAN>, <SPAN class="texample"><SPAN class="keyword">close()</SPAN></SPAN>"). </P><DIV class="lecture_mark" id="mark_306"></DIV><P id="id_312"><B>Надо отметить, что их поведение при работе с файлами имеет определенные особенности, связанные с понятием</B> <SPAN class="keyword">указателя текущей позиции</SPAN> <B>в файле.</B> </P><DIV class="lecture_mark" id="mark_312"></DIV><P id="id_313">При работе с файлами информация записывается в файл или читается из него, начиная с места, определяемого <SPAN class="keyword">указателем текущей позиции</SPAN> в файле. Значение указателя увеличивается на количество реально прочитанных или записанных байт. При чтении информации из файла она не пропадает из него. Если системный вызов <SPAN class="texample"><SPAN class="keyword">read</SPAN></SPAN> возвращает значение <SPAN class="texample">0</SPAN>, то это означает, что достигнут конец файла. </P><DIV class="lecture_mark" id="mark_313"></DIV><P id="id_316"><B>Операция изменения</B> <SPAN class="keyword">указателя текущей позиции</SPAN>. <B>Системный вызов</B> <SPAN class="texample"><SPAN class="keyword">lseek()</SPAN></SPAN>. С точки зрения процесса все <SPAN class="keyword">регулярные файлы</SPAN> являются файлами прямого доступа. <A name="keyword-context.5"></A>В любой момент процесс может изменить положение <SPAN class="keyword">указателя текущей позиции</SPAN> в открытом файле с помощью системного вызова <SPAN class="texample"><SPAN class="keyword_def">lseek()</SPAN></SPAN>. </P><DIV class="lecture_mark" id="mark_316"></DIV><P id="id_319"><B>Особенностью этого системного вызова является возможность помещения</B> <SPAN class="keyword">указателя текущей позиции</SPAN> <B>в файле за конец файла (т.е. возможность установления значения указателя большего, чем длина файла). </B></P><DIV class="lecture_mark" id="mark_319"></DIV><P id="id_320">При любой последующей операции записи в таком положении указателя файл будет выглядеть так, как будто возникший промежуток от конца файла до текущей позиции, где начинается запись, был заполнен нулевыми байтами. Если операции записи в таком положении указателя не производится, то никакого изменения файла, связанного с необычным значением указателя, не произойдет (например, операция чтения будет возвращать нулевое значение для количества прочитанных байтов).</P><DIV class="lecture_mark" id="mark_320"></DIV><DIV class="xml_table_env" id="id_321"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_322"><B>Системный вызов lseek()</B></P><DIV class="lecture_mark" id="mark_322"></DIV>

<P id="id_323"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_323"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
off_t lseek(int fd, off_t offset, 
            int whence);
</PRE></DIV>

<P id="id_325"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_325"></DIV>

<P id="id_326">Системный вызов <SPAN class="texample"><SPAN class="keyword">lseek</SPAN></SPAN> предназначен для изменения положения <SPAN class="keyword">указателя текущей позиции</SPAN> в открытом <SPAN class="keyword">регулярном файле</SPAN>. </P><DIV class="lecture_mark" id="mark_326"></DIV>

<P id="id_328">Параметр <SPAN class="texample">fd</SPAN> является дескриптором соответствующего файла, т. е. значением, которое вернул системный вызов <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN>.</P><DIV class="lecture_mark" id="mark_328"></DIV>

<P id="id_331">Параметр <SPAN class="texample">offset</SPAN> совместно с параметром <SPAN class="texample">whence</SPAN> определяют новое положение <SPAN class="keyword">указателя текущей позиции</SPAN> следующим образом:</P><DIV class="lecture_mark" id="mark_331"></DIV>

<UL id="id_334"><LI>Если значение параметра <SPAN class="texample">whence</SPAN> равно <SPAN class="texample">SEEK_SET</SPAN>, то новое значение указателя будет составлять <SPAN class="texample">offset</SPAN> байт от начала файла. Естественно, что значение <SPAN class="texample">offset</SPAN> в этом случае должно быть не отрицательным. </LI><LI>значение параметра <SPAN class="texample">whence</SPAN> равно <SPAN class="texample">SEEK_CUR</SPAN>, то новое значение указателя будет составлять старое значение указателя <SPAN class="texample">+ offset</SPAN> байт. При этом новое значение указателя не должно стать отрицательным. </LI><LI>Если значение параметра <SPAN class="texample">whence</SPAN> равно <SPAN class="texample">SEEK_END</SPAN>, то новое значение указателя будет составлять длина файла <SPAN class="texample">+ offset</SPAN> байт. При этом новое значение указателя не должно стать отрицательным.</LI></UL><DIV class="lecture_mark" id="mark_334"></DIV>

<P id="id_348">Системный вызов <SPAN class="texample"><SPAN class="keyword">lseek</SPAN></SPAN> позволяет выставить текущее значение указателя за конец файла (т.е. сделать его превышающим размер файла). При любой последующей операции записи в этом положении указателя файл будет выглядеть так, как будто возникший промежуток был заполнен нулевыми битами.</P><DIV class="lecture_mark" id="mark_348"></DIV>

<P id="id_350">Тип данных <SPAN class="texample">off_t</SPAN> обычно является синонимом типа <SPAN class="texample">long</SPAN>.</P><DIV class="lecture_mark" id="mark_350"></DIV>

<P id="id_353"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_353"></DIV>

<P id="id_354">Системный вызов возвращает новое положение <SPAN class="keyword">указателя текущей позиции</SPAN> в байтах от начала файла при нормальном завершении и значение <SPAN class="texample">-1</SPAN> при возникновении ошибки. </P><DIV class="lecture_mark" id="mark_354"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_321"></DIV><P id="id_356"><B>Операция добавления информации в файл. Флаг</B> <SPAN class="texample">O_APPEND</SPAN>. Хотя эта операция по сути дела является комбинацией двух уже рассмотренных операций, мы считаем нужным упомянуть ее особо. Если открытие файла системным вызовом <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN> производилось с установленным флагом <SPAN class="texample">O_APPEND</SPAN>, то любая операция записи в файл <B>будет всегда добавлять новые данные в конец файла</B>, независимо от предыдущего положения <SPAN class="keyword">указателя текущей позиции</SPAN> (как если бы непосредственно перед записью был выполнен вызов <SPAN class="texample"><SPAN class="keyword">lseek()</SPAN></SPAN> для установки указателя на конец файла).</P><DIV class="lecture_mark" id="mark_356"></DIV><P id="id_361"><B>Операции создания связей</B>. <B>Команда</B> <SPAN class="texample"><SPAN class="keyword">ln</SPAN></SPAN><B>, системные вызовы</B> <SPAN class="texample"><SPAN class="keyword">link()</SPAN></SPAN> <B>и</B> <SPAN class="texample"><SPAN class="keyword">symlink()</SPAN></SPAN>. С операциями, позволяющими изменять логическую структуру файловой системы, такими как создание файла, мы уже сталкивались в этом разделе. Однако операции создания связи служат для проведения новых именованных ребер в уже существующей структуре без добавления новых узлов или для опосредованного проведения именованного ребра к уже существующему узлу через <SPAN class="keyword">файл типа "связь"</SPAN> и неименованное ребро. Такие операции мы до сих пор не рассматривали, поэтому давайте остановимся на них подробнее. </P><DIV class="lecture_mark" id="mark_361"></DIV><P id="id_365">Допустим, что несколько программистов совместно ведут работу над одним и тем же проектом. Файлы, относящиеся к этому проекту, вполне естественно могут быть выделены в отдельную <SPAN class="keyword">директорию</SPAN> так, чтобы не смешиваться с файлами других пользователей и другими файлами программистов, участвующих в проекте. Для удобства каждый из разработчиков, конечно, хотел бы, чтобы эти файлы находились в его собственной <SPAN class="keyword">директории</SPAN>. Этого можно было бы добиться, копируя по мере изменения новые версии соответствующих файлов из <SPAN class="keyword">директории</SPAN> одного исполнителя в <SPAN class="keyword">директорию</SPAN> другого исполнителя. Однако тогда, во-первых, возникнет ненужное дублирование информации на диске. Во-вторых, появится необходимость решения тяжелой задачи: синхронизации обновления замены всех копий этих файлов новыми версиями. </P><DIV class="lecture_mark" id="mark_365"></DIV><P id="id_366">Существует другое решение проблемы. Достаточно разрешить файлам иметь несколько имен. Тогда одному физическому экземпляру данных на диске могут соответствовать различные имена файла, находящиеся в одной или в разных <SPAN class="keyword">директориях</SPAN>. Подобная операция присвоения нового имени файлу (без уничтожения ранее существовавшего имени) получила название операции создания связи. </P><DIV class="lecture_mark" id="mark_366"></DIV><P id="id_367">В операционной системе UNIX связь может быть создана двумя различными способами. </P><DIV class="lecture_mark" id="mark_367"></DIV><P id="id_368">Первый способ, наиболее точно следующий описанной выше процедуре, получил название способа создания <SPAN class="keyword">жесткой связи</SPAN> (hard link). С точки зрения логической структуры файловой системы этому способу соответствует проведение нового именованного ребра из узла, соответствующего некоторой <SPAN class="keyword">директории</SPAN>, к узлу, соответствующему файлу любого типа, получающему дополнительное имя. С точки зрения структур данных, описывающих строение файловой системы, в эту <SPAN class="keyword">директорию</SPAN> добавляется запись, содержащая дополнительное имя файла и номер его <SPAN class="keyword">индексного узла</SPAN> (уже существующий!). При таком подходе и новое имя файла, и его старое имя или имена абсолютно равноправны для операционной системы и могут взаимозаменяемо использоваться для осуществления всех операций.</P><DIV class="lecture_mark" id="mark_368"></DIV><P id="id_369">Использование <SPAN class="keyword">жестких связей</SPAN> приводит к возникновению двух проблем.</P><DIV class="lecture_mark" id="mark_369"></DIV><P id="id_370">Первая проблема связана с операцией удаления файла. Если мы хотим удалить файл из некоторой <SPAN class="keyword">директории</SPAN>, то после удаления из ее содержимого записи, соответствующей этому файлу, мы не можем освободить логические блоки, занимаемые файлом, и его <SPAN class="keyword">индексный узел</SPAN>, не убедившись, что у файла нет дополнительных имен (к его <SPAN class="keyword">индексному узлу</SPAN> не ведут ссылки из других <SPAN class="keyword">директорий</SPAN>), иначе мы нарушим целостность файловой системы. Для решения этой проблемы файлы получают дополнительный атрибут – счетчик <SPAN class="keyword">жестких связей</SPAN> (или именованных ребер), ведущих к ним, который, как и другие атрибуты, располагается в их <SPAN class="keyword">индексных узлах</SPAN>. При создании файла этот счетчик получает значение <SPAN class="texample">1</SPAN>. При создании каждой новой <SPAN class="keyword">жесткой связи
</SPAN>, ведущей к файлу, он увеличивается на <SPAN class="texample">1</SPAN>. Когда мы удаляем файл из некоторой <SPAN class="keyword">директории</SPAN>, то из ее содержимого удаляется запись об этом файле, и счетчик <SPAN class="keyword">жестких связей</SPAN> уменьшается на <SPAN class="texample">1</SPAN>. Если его значение становится равным <SPAN class="texample">0</SPAN>, происходит освобождение логических блоков и <SPAN class="keyword">индексного узла</SPAN>, выделенных этому файлу.</P><DIV class="lecture_mark" id="mark_370"></DIV><P id="id_375">Вторая проблема связана с опасностью превращения логической структуры файловой системы из ациклического <SPAN class="keyword">графа</SPAN> в циклический и с возможной неопределенностью толкования записи с именем "<SPAN class="texample">..</SPAN>" в содержимом <SPAN class="keyword">директорий</SPAN>. Для их предотвращения во всех существующих вариантах операционной системы UNIX запрещено создание <SPAN class="keyword">жестких связей</SPAN>, ведущих к уже существующим <SPAN class="keyword">директориям</SPAN> (несмотря на то, что POSIX-стандарт для операционной системы UNIX разрешает подобную операцию для пользователя root). Поэтому мы и говорили о том, что в узел, соответствующий файлу типа "<SPAN class="keyword">директория</SPAN>", не может вести более одного именованного ребра. (В операционной системе Linux по непонятной причине дополнительно запрещено создание <SPAN class="keyword">жестких связей</SPAN>, ведущих к специальным <SPAN class="keyword">
файлам устройств</SPAN>.)</P><DIV class="lecture_mark" id="mark_375"></DIV><DIV class="xml_table_env" id="id_377"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_378"><B>Команда ln</B> </P><DIV class="lecture_mark" id="mark_378"></DIV>

<P id="id_379"><B>Синтаксис команды</B></P><DIV class="lecture_mark" id="mark_379"></DIV>

<DIV class="example"><PRE>ln [options] source [dest]
ln [options] source ... directory
</PRE></DIV>

<P id="id_381"><B>Описание команды</B></P><DIV class="lecture_mark" id="mark_381"></DIV>

<P id="id_382">Настоящее описание не является полным описанием команды <SPAN class="texample"><SPAN class="keyword">ln</SPAN></SPAN>, а описывает только ее опции, используемые в данном курсе. Для получения полного описания обращайтесь к UNIX Manual </P><DIV class="lecture_mark" id="mark_382"></DIV>

<P id="id_384"><A name="keyword-context.6"></A>Команда <SPAN class="texample"><SPAN class="keyword_def">ln</SPAN></SPAN> предназначена для реализации операции создания связи в файловой системе. В нашем курсе мы будем использовать две формы этой команды.</P><DIV class="lecture_mark" id="mark_384"></DIV>

<P id="id_386">Первая форма команды, когда в качестве параметра <SPAN class="texample">source</SPAN> задается имя только одного файла, а параметр <SPAN class="texample">dest</SPAN> отсутствует, или когда в качестве параметра <SPAN class="texample">dest</SPAN> задается имя файла, не существующего в файловой системе, создает связь к файлу, указанному в качестве параметра <SPAN class="texample">source</SPAN>, в текущей <SPAN class="keyword">директории</SPAN> с его именем (если параметр dest отсутствует) или с именем <SPAN class="texample">dest</SPAN> (полным или относительным) в случае наличия параметра <SPAN class="texample">dest</SPAN>.</P><DIV class="lecture_mark" id="mark_386"></DIV>

<P id="id_393">Вторая форма команды, когда в качестве параметра <SPAN class="texample">source</SPAN> задаются имена одного или нескольких файлов, разделенные между собой пробелами, а в качестве параметра <SPAN class="texample">directory</SPAN> задается имя уже существующей в файловой системе <SPAN class="keyword">директории</SPAN>, создает связи к каждому из файлов, перечисленных в параметре <SPAN class="texample">source</SPAN>, в <SPAN class="keyword">директории</SPAN> <SPAN class="texample">directory</SPAN> с именами, совпадающими с именами перечисленных файлов.</P><DIV class="lecture_mark" id="mark_393"></DIV>

<P id="id_398">Команда <SPAN class="texample"><SPAN class="keyword">ln</SPAN></SPAN> без опций служит для создания <SPAN class="keyword">жестких связей</SPAN> (hard link), а команда <SPAN class="texample"><SPAN class="keyword">ln</SPAN></SPAN> с опцией <SPAN class="texample">–s</SPAN> – для создания <SPAN class="keyword">мягких (soft link) или символических (symbolic) связей</SPAN>.</P><DIV class="lecture_mark" id="mark_398"></DIV>

<P id="id_402"><B>Примечание:</B> во всех существующих версиях UNIX (несмотря на стандарт POSIX) запрещено создание <SPAN class="keyword">жестких связей</SPAN> к <SPAN class="keyword">директориям</SPAN>. Операционная система Linux запрещает также, по непонятным причинам, создание <SPAN class="keyword">жестких связей</SPAN> к специальным <SPAN class="keyword">файлам устройств</SPAN>. </P><DIV class="lecture_mark" id="mark_402"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_377"></DIV><P id="id_403">Для создания <SPAN class="keyword">жестких связей</SPAN> применяются команда операционной системы <SPAN class="texample"><SPAN class="keyword">ln</SPAN></SPAN> без опций и системный вызов <SPAN class="texample"><SPAN class="keyword">link()</SPAN></SPAN>. </P><DIV class="lecture_mark" id="mark_403"></DIV><P id="id_406"><B>Надо отметить, что системный вызов</B> <SPAN class="texample"><SPAN class="keyword">link()</SPAN></SPAN> <B>является одним из немногих системных вызовов, совершающих операции над файлами, которые не требуют предварительного открытия файла, поскольку он подразумевает выполнение единичного действия только над содержимым</B> <SPAN class="keyword">индексного узла</SPAN>, <B>выделенного связываемому файлу</B>.</P><DIV class="lecture_mark" id="mark_406"></DIV><DIV class="xml_table_env" id="id_408"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_409"><B>Системный вызов link()</B></P><DIV class="lecture_mark" id="mark_409"></DIV>

<P id="id_410"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_410"></DIV>

<DIV class="example"><PRE>#include &lt;unistd.h&gt;
int link(char *pathname, 
         char *linkpathname);
</PRE></DIV>

<P id="id_412"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_412"></DIV>

<P id="id_413">Системный вызов <SPAN class="texample"><SPAN class="keyword">link</SPAN></SPAN> служит для создания <SPAN class="keyword">жесткой связи</SPAN> к файлу с именем, на которое указывает параметр <SPAN class="texample">pathname</SPAN>. Указатель на имя создаваемой связи задается параметром <SPAN class="texample">linkpathname</SPAN> (полное или относительное имя связи). Во всех существующих реализациях операционной системы UNIX запрещено создавать <SPAN class="keyword">жесткие связи</SPAN> к <SPAN class="keyword">директориям</SPAN>. В операционной системе Linux (по непонятной причине) дополнительно запрещено создавать <SPAN class="keyword">жесткие связи</SPAN> к специальным <SPAN class="keyword">файлам устройств</SPAN>.</P><DIV class="lecture_mark" id="mark_413"></DIV>

<P id="id_417"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_417"></DIV>

<P id="id_418">Системный вызов возвращает значение <SPAN class="texample">0</SPAN> при нормальном завершении и значение <SPAN class="texample">-1</SPAN> при возникновении ошибки. </P><DIV class="lecture_mark" id="mark_418"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_408"></DIV><P id="id_421">Второй способ создания связи получил название способа создания <SPAN class="keyword">мягкой (soft) или символической (symbolic) связи (link)</SPAN>. В то время как <SPAN class="keyword">жесткая связь</SPAN> файлов является аналогом использования прямых ссылок (указателей) в современных языках программирования, символическая связь, до некоторой степени, напоминает косвенные ссылки (указатель на указатель). При создании <SPAN class="keyword">мягкой связи</SPAN> с именем <SPAN class="texample">symlink</SPAN> из некоторой 
<SPAN class="keyword">директории</SPAN> к файлу, заданному полным или относительным именем <SPAN class="texample">linkpath</SPAN>, в этой <SPAN class="keyword">директории</SPAN> действительно <B>создается новый</B> <SPAN class="keyword">файл типа "связь"</SPAN> с именем <SPAN class="texample">symlink</SPAN> со своими собственными <SPAN class="keyword">индексным узлом</SPAN> и логическими блоками. При тщательном рассмотрении можно обнаружить, что все его содержимое составляет только символьная запись имени <SPAN class="texample">linkpath</SPAN>. 
Операция открытия <SPAN class="keyword">файла типа "связь"</SPAN> устроена таким образом, что в действительности открывается не сам этот файл, а тот файл, чье имя содержится в нем (при необходимости рекурсивно!). Поэтому операции над файлами, требующие предварительного открытия файла (как, впрочем, и большинство команд операционной системы, совершающих действия над файлами, где операция открытия файла присутствует, но скрыта от пользователя), в реальности будут совершаться не над <SPAN class="keyword">файлом типа "связь"</SPAN>, а над тем файлом, имя которого содержится в нем (или над тем файлом, который, в конце концов, откроется при рекурсивных ссылках). Отсюда, в частности, следует, что попытки прочитать <B>реальное</B> содержимое <SPAN class="keyword">файлов типа "связь"</SPAN> с помощью системного вызова 
<SPAN class="texample"><SPAN class="keyword">read()</SPAN></SPAN> обречены на неудачу. Как видно, создание <SPAN class="keyword">мягкой связи</SPAN>, с точки зрения изменения логической структуры файловой системы, эквивалентно опосредованному проведению именованного ребра к уже существующему узлу через <SPAN class="keyword">файл типа "связь"</SPAN> и неименованное ребро.</P><DIV class="lecture_mark" id="mark_421"></DIV><P id="id_427">Создание символической связи не приводит к проблеме, связанной с удалением файлов. Если файл, на который ссылается <SPAN class="keyword">мягкая связь</SPAN>, удаляется с физического носителя, то попытка открытия файла <SPAN class="keyword">мягкой связи</SPAN> (а, следовательно, и удаленного файла) приведет к ошибке "Файла с таким именем не существует", которая может быть аккуратно обработана приложением. Таким образом, удаление связанного объекта, как упоминалось ранее, лишь отчасти и не фатально нарушит целостность файловой системы.</P><DIV class="lecture_mark" id="mark_427"></DIV><P id="id_428">Неаккуратное применение символических связей пользователями операционной системы может привести к превращению логической структуры файловой системы из ациклического <SPAN class="keyword">графа</SPAN> в циклический <SPAN class="keyword">граф</SPAN>. Это, конечно, нежелательно, но не носит столь разрушительного характера, как циклы, которые могли бы быть созданы <SPAN class="keyword">жесткой связью</SPAN>, если бы не был введен запрет на организацию <SPAN class="keyword">жестких связей</SPAN> к <SPAN class="keyword">директориям</SPAN>. 
Поскольку <SPAN class="keyword">мягкие связи</SPAN> принципиально отличается от <SPAN class="keyword">жестких связей</SPAN> и связей, возникающих между <SPAN class="keyword">директорией</SPAN> и файлом при его создании, <SPAN class="keyword">мягкая связь</SPAN> легко может быть идентифицирована операционной системой или программой пользователя. Для предотвращения зацикливания программ, выполняющих операции над файлами, обычно ограничивается глубина рекурсии по прохождению <SPAN class="keyword">мягких связей</SPAN>. 
Превышение этой глубины приводит к возникновению ошибки "Слишком много <SPAN class="keyword">мягких связей</SPAN>", которая может быть легко обработана приложением. Поэтому ограничения на тип файлов, к которым может вести <SPAN class="keyword">мягкая связь</SPAN>, в операционной системе UNIX не вводятся.</P><DIV class="lecture_mark" id="mark_428"></DIV><P id="id_429"><B>Для создания</B> <SPAN class="keyword">мягких связей</SPAN> <B>применяются уже знакомая нам команда операционной системы</B> <SPAN class="texample"><SPAN class="keyword">ln</SPAN></SPAN> <B>с опцией</B> <SPAN class="texample">-s</SPAN> <B>и системный вызов</B> <SPAN class="texample"><SPAN class="keyword">symlink()</SPAN></SPAN>. <B>Надо отметить, что системный вызов</B> <SPAN class="texample"><SPAN class="keyword">symlink()</SPAN></SPAN> <B>также не требует предварительного открытия связываемого файла, поскольку он вообще не рассматривает его содержимое.</B> </P><DIV class="lecture_mark" id="mark_429"></DIV><DIV class="xml_table_env" id="id_434"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_435"><B>Системный вызов symlink()</B></P><DIV class="lecture_mark" id="mark_435"></DIV>

<P id="id_436"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_436"></DIV>

<DIV class="example"><PRE>#include &lt;unistd.h&gt;
int symlink(char *pathname, 
            char *linkpathname);
</PRE></DIV>

<P id="id_438"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_438"></DIV>

<P id="id_439">Системный вызов <SPAN class="texample"><SPAN class="keyword">symlink</SPAN></SPAN> служит для создания <SPAN class="keyword">символической (мягкой) связи</SPAN> к файлу с именем, на которое указывает параметр <SPAN class="texample">pathname</SPAN>. Указатель на имя создаваемой связи задается параметром <SPAN class="texample">linkpathname</SPAN> (полное или относительное имя связи). </P><DIV class="lecture_mark" id="mark_439"></DIV>

<P id="id_443">Никакой проверки реального существования файла с именем <SPAN class="texample">pathname</SPAN> системный вызов не производит.</P><DIV class="lecture_mark" id="mark_443"></DIV>

<P id="id_445"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_445"></DIV>

<P id="id_446">Системный вызов возвращает значение <SPAN class="texample">0</SPAN> при нормальном завершении и значение <SPAN class="texample">-1</SPAN> при возникновении ошибки. </P><DIV class="lecture_mark" id="mark_446"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_434"></DIV><P id="id_449"><B>Операция удаления связей и файлов</B>. <B>Системный вызов</B> <SPAN class="texample"><SPAN class="keyword">unlink()</SPAN></SPAN>. При рассмотрении операции связывания файлов мы уже почти полностью рассмотрели, как производится операция удаления <SPAN class="keyword">жестких связей</SPAN> и файлов. При удалении <SPAN class="keyword">мягкой связи</SPAN>, т.е. фактически <SPAN class="keyword">файла типа "связь"</SPAN>, все происходит, как и для обычных файлов. Единственным изменением, с точки зрения логической структуры файловой системы, является то, что при действительном удалении узла, соответствующего <SPAN class="keyword">файлу типа "связь"</SPAN>, вместе с ним удаляется и выходящее из него неименованное ребро. </P><DIV class="lecture_mark" id="mark_449"></DIV><P id="id_451"><B>Дополнительно необходимо отметить, что условием реального удаления</B> <SPAN class="keyword">регулярного файла</SPAN> <B>с диска является не только равенство 0 значения его счетчика</B> <SPAN class="keyword">жестких связей</SPAN>, <B>но и отсутствие процессов, которые держат этот файл открытым</B>. Если такие процессы есть, то удаление <SPAN class="keyword">регулярного файла</SPAN> будет выполнено при его полном закрытии последним использующим файл процессом.</P><DIV class="lecture_mark" id="mark_451"></DIV><P id="id_452"><A name="keyword-context.7"></A>Для осуществления операции удаления <SPAN class="keyword">жестких связей</SPAN> и/или файлов можно задействовать уже известную вам из семинаров 1–2 команду операционной системы <SPAN class="texample"><SPAN class="keyword">rm</SPAN></SPAN> или системный вызов <SPAN class="texample"><SPAN class="keyword_def">unlink()</SPAN></SPAN>. </P><DIV class="lecture_mark" id="mark_452"></DIV><P id="id_455"><B>Заметим, что системный вызов</B> <SPAN class="texample"><SPAN class="keyword">unlink()</SPAN></SPAN> <B>также не требует предварительного открытия удаляемого файла, поскольку после его удаления совершать над ним операции бессмысленно.</B> </P><DIV class="lecture_mark" id="mark_455"></DIV><DIV class="xml_table_env" id="id_457"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_458"><B>Системный вызов unlink()</B></P><DIV class="lecture_mark" id="mark_458"></DIV>

<P id="id_459"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_459"></DIV>

<DIV class="example"><PRE>#include &lt;unistd.h&gt;
int unlink(char *pathname);
</PRE></DIV>

<P id="id_461"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_461"></DIV>

<P id="id_462">Системный вызов <SPAN class="texample"><SPAN class="keyword">unlink</SPAN></SPAN> служит для удаления имени, на которое указывает параметр pathname, из файловой системы.</P><DIV class="lecture_mark" id="mark_462"></DIV>

<P id="id_464">Если после удаления имени счетчик числа <SPAN class="keyword">жестких связей</SPAN> у данного файла стал равным <SPAN class="texample">0</SPAN>, то возможны следующие ситуации.</P><DIV class="lecture_mark" id="mark_464"></DIV>

<UL id="id_466"><LI>Если в операционной системе нет процессов, которые держат данный файл открытым, то файл полностью удаляется с физического носителя. </LI><LI>Если удаляемое имя было последней <SPAN class="keyword">жесткой связью</SPAN> для <SPAN class="keyword">регулярного файла</SPAN>, но какой-либо процесс держит его открытым, то файл продолжает существовать до тех пор, пока не будет закрыт последний файловый дескриптор, ссылающийся на данный файл. </LI><LI>Если имя относится к файлу типа socket, FIFO или к специальному <SPAN class="keyword">файлу устройства</SPAN>, то файл удаляется независимо от наличия процессов, держащих его открытым, но процессы, открывшие данный объект, могут продолжать пользоваться им. </LI><LI>Если имя относится к <SPAN class="keyword">файлу типа "связь"</SPAN>, то он удаляется, и <SPAN class="keyword">мягкая связь</SPAN> оказывается разорванной. </LI></UL><DIV class="lecture_mark" id="mark_466"></DIV>

<P id="id_471"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_471"></DIV>

<P id="id_472">Системный вызов возвращает значение <SPAN class="texample">0</SPAN> при нормальном завершении и значение <SPAN class="texample">-1</SPAN> при возникновении ошибки. </P><DIV class="lecture_mark" id="mark_472"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_457"></DIV><A name="sect9"></A><H3>Практическое применение команд и системных вызовов для операций над файлами </H3><P id="id_475">Практическое использование изученных вызовов и команд обычно проводится по усмотрению преподавателя или собственному вашему усмотрению. Создайте <SPAN class="keyword">жесткие</SPAN> и символические связи из вашей <SPAN class="keyword">директории</SPAN> к другим файлам. Просмотрите содержимое <SPAN class="keyword">директорий</SPAN> со связями с помощью команды <SPAN class="texample"><SPAN class="keyword">ls</SPAN></SPAN> <SPAN class="texample">-al</SPAN>. Обратите внимание на отличие <SPAN class="keyword">мягких</SPAN> и <SPAN class="keyword">жестких связей</SPAN> в листинге этой команды. Определите допустимую глубину рекурсии символических связей для вашей операционной системы.</P><DIV class="lecture_mark" id="mark_475"></DIV><A name="sect10"></A><H3>Специальные функции для работы с содержимым директорий </H3><P id="id_478">Стандартные системные вызовы <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN>, <SPAN class="texample"><SPAN class="keyword">read()</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">close()</SPAN></SPAN> не могут помочь программисту изучить содержимое файла типа "<SPAN class="keyword">директория</SPAN>". Для анализа содержимого <SPAN class="keyword">директорий</SPAN> используется набор функций из стандартной библиотеки языка C.</P><DIV class="lecture_mark" id="mark_478"></DIV><DIV class="xml_table_env" id="id_482"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_483"><B>Функция opendir()</B></P><DIV class="lecture_mark" id="mark_483"></DIV>

<P id="id_484"><B>Прототип функции</B></P><DIV class="lecture_mark" id="mark_484"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;
DIR *opendir(char *name);
</PRE></DIV>

<P id="id_486"><B>Описание функции</B></P><DIV class="lecture_mark" id="mark_486"></DIV>

<P id="id_487">Функция <SPAN class="texample"><SPAN class="keyword">opendir</SPAN></SPAN> служит для открытия потока информации для <SPAN class="keyword">директории</SPAN>, имя которой расположено по указателю <SPAN class="texample">name</SPAN>. Тип данных <SPAN class="texample">DIR</SPAN> представляет собой некоторую структуру данных, описывающую такой поток. Функция <SPAN class="texample"><SPAN class="keyword">opendir</SPAN></SPAN> подготавливает почву для функционирования других функций, выполняющих операции над <SPAN class="keyword">директорией</SPAN>, и позиционирует поток на первой записи <SPAN class="keyword">директории</SPAN>. </P><DIV class="lecture_mark" id="mark_487"></DIV>

<P id="id_492"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_492"></DIV>

<P id="id_493">При удачном завершении функция возвращает указатель на открытый поток <SPAN class="keyword">директории</SPAN>, который будет в дальнейшем передаваться в качестве параметра всем другим функциям, работающим с этой <SPAN class="keyword">директорией</SPAN>. При неудачном завершении возвращается значение <SPAN class="texample">NULL</SPAN>. </P><DIV class="lecture_mark" id="mark_493"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_482"></DIV><P id="id_495">С точки зрения программиста в этом интерфейсе <SPAN class="keyword">директория</SPAN> представляется как файл последовательного доступа, над которым можно совершать операции чтения очередной записи и позиционирования на начале файла. Перед выполнением этих операций <SPAN class="keyword">директорию</SPAN> необходимо открыть, а после окончания – закрыть. <A name="keyword-context.8"></A>Для открытия <SPAN class="keyword">директории</SPAN> используется функция <SPAN class="texample"><SPAN class="keyword_def">opendir()</SPAN></SPAN>, которая подготавливает почву для совершения операций и позиционирует нас на начале файла. <A name="keyword-context.9"></A>Чтение очередной записи из <SPAN class="keyword">директории</SPAN> осуществляет функция <SPAN class="texample"><SPAN class="keyword_def">readdir()</SPAN></SPAN>, одновременно позиционируя нас на начале следующей записи (если она, конечно, существует). <A name="keyword-context.10"></A>Для операции нового позиционирования на начале <SPAN class="keyword">директории</SPAN> (если вдруг понадобится) применяется 
функция <SPAN class="texample"><SPAN class="keyword_def">rewinddir()</SPAN></SPAN>. После окончания работы с <SPAN class="keyword">директорией</SPAN> ее необходимо закрыть с помощью функции <SPAN class="texample"><SPAN class="keyword">closedir()</SPAN></SPAN>.</P><DIV class="lecture_mark" id="mark_495"></DIV><DIV class="xml_table_env" id="id_500"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_501"><B>Функция readdir()</B></P><DIV class="lecture_mark" id="mark_501"></DIV>

<P id="id_502"><B>Прототип функции</B></P><DIV class="lecture_mark" id="mark_502"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;
struct dirent *readdir(DIR *dir);
</PRE></DIV>

<P id="id_504"><B>Описание функции</B></P><DIV class="lecture_mark" id="mark_504"></DIV>

<P id="id_505">Функция <SPAN class="texample"><SPAN class="keyword">readdir</SPAN></SPAN> служит для чтения очередной записи из потока информации для <SPAN class="keyword">директории</SPAN>. </P><DIV class="lecture_mark" id="mark_505"></DIV>

<P id="id_507">Параметр <SPAN class="texample">dir</SPAN> представляет собой указатель на структуру, описывающую поток <SPAN class="keyword">директории</SPAN>, который вернула функция <SPAN class="texample"><SPAN class="keyword">opendir()</SPAN></SPAN>. </P><DIV class="lecture_mark" id="mark_507"></DIV>

<P id="id_510">Тип данных <SPAN class="texample">struct dirent</SPAN> представляет собой некоторую структуру данных, описывающую одну запись в <SPAN class="keyword">директории</SPAN>. Поля этой записи сильно варьируются от одной файловой системы к другой, но одно из полей, которое собственно и будет нас интересовать, всегда присутствует в ней. Это поле <SPAN class="texample">char d_name[ ]</SPAN> неопределенной длины, не превышающей значения <SPAN class="texample">NAME_MAX+1</SPAN>, которое содержит символьное имя файла, завершающееся символом конца строки. Данные, возвращаемые функцией <SPAN class="texample"><SPAN class="keyword">readdir</SPAN></SPAN>, переписываются при очередном вызове этой функции для того же самого потока <SPAN class="keyword">директории</SPAN>. </P><DIV class="lecture_mark" id="mark_510"></DIV>

<P id="id_515"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_515"></DIV>

<P id="id_516">При удачном завершении функция возвращает указатель на структуру, содержащую очередную запись <SPAN class="keyword">директории</SPAN>. При неудачном завершении или при достижении конца <SPAN class="keyword">директории</SPAN> возвращается значение <SPAN class="texample">NULL</SPAN>. </P><DIV class="lecture_mark" id="mark_516"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_500"></DIV><P id="id_518"></P><DIV class="lecture_mark" id="mark_518"></DIV><DIV class="xml_table_env" id="id_519"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_520"><B>Функция rewinddir()</B></P><DIV class="lecture_mark" id="mark_520"></DIV>

<P id="id_521"><B>Прототип функции</B></P><DIV class="lecture_mark" id="mark_521"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;
void rewinddir(DIR *dir);
</PRE></DIV>

<P id="id_523"><B>Описание функции</B></P><DIV class="lecture_mark" id="mark_523"></DIV>

<P id="id_524">Функция <SPAN class="texample"><SPAN class="keyword">rewinddir</SPAN></SPAN> служит для позиционирования потока информации для <SPAN class="keyword">директории</SPAN>, ассоциированного с указателем <SPAN class="texample">dir</SPAN> (т.е. с тем, что вернула функция <SPAN class="texample"><SPAN class="keyword">opendir()</SPAN></SPAN>), на первой записи (или на начале) <SPAN class="keyword">директории</SPAN>. </P><DIV class="lecture_mark" id="mark_524"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_519"></DIV><P id="id_528"></P><DIV class="lecture_mark" id="mark_528"></DIV><DIV class="xml_table_env" id="id_529"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_530"><B>Функция closedir()</B></P><DIV class="lecture_mark" id="mark_530"></DIV>

<P id="id_531"><B>Прототип функции</B></P><DIV class="lecture_mark" id="mark_531"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;
int closedir(DIR *dir);
</PRE></DIV>

<P id="id_533"><B>Описание функции</B></P><DIV class="lecture_mark" id="mark_533"></DIV>

<P id="id_534">Функция <SPAN class="texample"><SPAN class="keyword">closedir</SPAN></SPAN> служит для закрытия потока информации для <SPAN class="keyword">директории</SPAN>, ассоциированного с указателем <SPAN class="texample">dir</SPAN> (т.е. с тем, что вернула функция <SPAN class="texample"><SPAN class="keyword">opendir()</SPAN></SPAN>). После закрытия поток <SPAN class="keyword">директории</SPAN> становится недоступным для дальнейшего использования. </P><DIV class="lecture_mark" id="mark_534"></DIV>

<P id="id_538"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_538"></DIV>

<P id="id_539">При успешном завершении функция возвращает значение <SPAN class="texample">0</SPAN>, при неудачном завершении – значение <SPAN class="texample">-1</SPAN>. </P><DIV class="lecture_mark" id="mark_539"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_529"></DIV><A name="sect11"></A><H3>Написание, прогон и компиляция программы, анализирующей содержимое директории </H3><P id="id_542">Напишите, откомпилируйте и прогоните программу, распечатывающую список файлов, входящих в <SPAN class="keyword">директорию</SPAN>, с указанием их типов. Имя <SPAN class="keyword">директории</SPAN> задается как параметр командной строки. Если оно отсутствует, то выбирается текущая <SPAN class="keyword">директория</SPAN>.</P><DIV class="lecture_mark" id="mark_542"></DIV><P id="id_543"><B>Задача повышенной сложности</B>: напишите программу, распечатывающую содержимое заданной <SPAN class="keyword">директории</SPAN> в формате, аналогичном формату выдачи команды <SPAN class="texample"><SPAN class="keyword">ls</SPAN></SPAN> <SPAN class="texample">-al</SPAN>. Для этого вам дополнительно понадобится самостоятельно изучить в UNIX Manual функцию <SPAN class="texample">ctime(3)</SPAN> и системные вызовы <SPAN class="texample">time(2)</SPAN>, <SPAN class="texample">readlink(2)</SPAN>. Цифры после имен функций и системных вызовов – это номера соответствующих разделов для UNIX Manual. </P><DIV class="lecture_mark" id="mark_543"></DIV><A name="sect12"></A><H3>Понятие о файлах, отображаемых в память (memory mapped файлах). Системные вызовы mmap(), munmap() </H3><P id="id_549">Как уже говорилось, с помощью системного вызова <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN> операционная система отображает файл из пространства имен в дисковое пространство файловой системы, подготавливая почву для осуществления других операций. С появлением концепции виртуальной памяти, которая рассматривалась в лекции 9, когда физические размеры памяти перестали играть роль сдерживающего фактора в развитии вычислительных систем, стало возможным отображать файлы непосредственно в адресное пространство процессов. Иными словами, появилась возможность работать с файлами как с обычной памятью, заменив выполнение базовых операций над ними с помощью системных вызовов на использование операций обычных языков программирования. <A name="keyword-context.11"></A>Файлы, чье содержимое отображается непосредственно в адресное пространство процессов, получили название файлов, отображаемых в память, или, по-английски, <SPAN class="keyword_def">memory mapped файлов</SPAN> 
(см. лекцию 10). Надо отметить, что такое отображение может быть осуществлено не только для всего файла в целом, но и для его части.</P><DIV class="lecture_mark" id="mark_549"></DIV><P id="id_551">С точки зрения программиста работа с такими файлами выглядит следующим образом: </P><DIV class="lecture_mark" id="mark_551"></DIV><UL id="id_552"><LI>Отображение файла из пространства имен в адресное пространство процесса происходит в два этапа: сначала выполняется отображение в дисковое пространство, а уже затем из дискового пространства в адресное. Поэтому вначале файл необходимо открыть, используя обычный системный вызов <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN>. </LI><LI><A name="keyword-context.12"></A>Вторым этапом является отображение файла целиком или частично из дискового пространства в адресное пространство процесса. Для этого используется системный вызов <SPAN class="texample"><SPAN class="keyword_def">mmap()</SPAN></SPAN>. Файл после этого можно и закрыть, выполнив системный вызов <SPAN class="texample"><SPAN class="keyword">close()</SPAN></SPAN>, так как необходимую информацию о расположении файла на диске мы уже сохранили в других структурах данных при вызове <SPAN class="texample"><SPAN class="keyword">mmap()</SPAN></SPAN>.</LI></UL><DIV class="lecture_mark" id="mark_552"></DIV><DIV class="xml_table_env" id="id_559"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_560"><B>Системный вызов mmap()</B></P><DIV class="lecture_mark" id="mark_560"></DIV>

<P id="id_561"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_561"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/mman.h&gt; 
void *mmap (void *start, size_t length, 
    int prot, int flags, int fd, 
    off_t offset);
</PRE></DIV>

<P id="id_563"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_563"></DIV>

<P id="id_564">Системный вызов <SPAN class="texample"><SPAN class="keyword">mmap</SPAN></SPAN> служит для отображения предварительно открытого файла (например, с помощью системного вызова <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN>) в адресное пространство вычислительной системы. После его выполнения файл может быть закрыт (например, системным вызовом <SPAN class="texample"><SPAN class="keyword">close()</SPAN></SPAN>), что никак не повлияет на дальнейшую работу с отображенным файлом.</P><DIV class="lecture_mark" id="mark_564"></DIV>

<P id="id_568">Настоящее описание не является полным описанием системного вызова, а предназначено только для использования в рамках данного курса. Для получения полной информации обращайтесь к UNIX Manual. </P><DIV class="lecture_mark" id="mark_568"></DIV>

<P id="id_569">Параметр <SPAN class="texample">fd</SPAN> является файловым дескриптором для файла, который мы хотим отобразить в адресное пространство (т.е. значением, которое вернул системный вызов <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN>). </P><DIV class="lecture_mark" id="mark_569"></DIV>

<P id="id_572">Ненулевое значение параметра <SPAN class="texample">start</SPAN> может использоваться только очень квалифицированными системными программистами, поэтому мы в семинарах будем всегда полагать его равным значению <SPAN class="texample">NULL</SPAN>, позволяя операционной системе самой выбрать начало области адресного пространства, в которую будет отображен файл.</P><DIV class="lecture_mark" id="mark_572"></DIV>

<P id="id_575">В память будет отображаться часть файла, начиная с позиции внутри его, заданной значением параметра <SPAN class="texample">offset</SPAN> – смещение от начала файла в байтах, и длиной, равной значению параметра <SPAN class="texample">length</SPAN> (естественно, тоже в байтах). Значение параметра <SPAN class="texample">length</SPAN> может и превышать реальную длину от позиции <SPAN class="texample">offset</SPAN> до конца существующего файла. На поведении системного вызова это никак не отразится, но в дальнейшем при попытке доступа к ячейкам памяти, лежащим вне границ реального файла, возникнет сигнал <SPAN class="texample">SIGBUS</SPAN> (реакция на него по умолчанию – прекращение процесса с образованием core файла).</P><DIV class="lecture_mark" id="mark_575"></DIV>

<P id="id_581">Параметр <SPAN class="texample">flags</SPAN> определяет способ отображения файла в адресное пространство. В рамках нашего курса мы будем использовать только два его возможных значения: <SPAN class="texample">MAP_SHARED</SPAN> и <SPAN class="texample">MAP_PRIVATE</SPAN>. Если в качестве его значения выбрано <SPAN class="texample">MAP_SHARED</SPAN>, то полученное отображение файла впоследствии будет использоваться и другими процессами, вызвавшими <SPAN class="keyword">mmap</SPAN> для этого файла с аналогичными значениями параметров, а все изменения, сделанные в отображенном файле, будут сохранены во вторичной памяти. Если в качестве значения параметра <SPAN class="texample">flags</SPAN> указано <SPAN class="texample">MAP_PRIVATE</SPAN>, то процесс получает отображение файла в свое монопольное распоряжение, но все изменения в нем не могут быть занесены во вторичную память (т.е., проще говоря, не сохранятся).</P><DIV class="lecture_mark" id="mark_581"></DIV>

<P id="id_588">Параметр <SPAN class="texample">prot</SPAN> определяет разрешенные операции над областью памяти, в которую будет отображен файл. В качестве его значения мы будем использовать значения <SPAN class="texample">PROT_READ</SPAN> (разрешено чтение), <SPAN class="texample">PROT_WRITE</SPAN> (разрешена запись) или их комбинацию через операцию "побитовое или" – "<SPAN class="texample">|</SPAN>". Необходимо отметить две существенные особенности системного вызова, связанные с этим параметром:</P><DIV class="lecture_mark" id="mark_588"></DIV>

<OL id="id_593"><LI>Значение параметра <SPAN class="texample">prot</SPAN> не может быть шире, чем операции над файлом, заявленные при его открытии в параметре <SPAN class="texample">flags</SPAN> системного вызова <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN>. Например, нельзя открыть файл только для чтения, а при его отображении в память использовать значение <SPAN class="texample">prot = PROT_READ | PROT_WRITE</SPAN>.</LI><LI>В результате ошибки в операционной системе Linux при работе на 486-х и 586-х процессорах попытка записать в отображение файла, открытое только для записи, более 32-х байт одновременно приводит к ошибке (возникает сигнал о нарушении защиты памяти).</LI></OL><DIV class="lecture_mark" id="mark_593"></DIV>

<P id="id_600"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_600"></DIV>

<P id="id_601">При нормальном завершении системный вызов возвращает начальный адрес области памяти, в которую отображен файл (или его часть), при возникновении ошибки – специальное значение <SPAN class="texample">MAP_FAILED</SPAN>. </P><DIV class="lecture_mark" id="mark_601"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_559"></DIV><UL id="id_603"><LI>После этого с содержимым файла можно работать, как с содержимым обычной области памяти. </LI><LI><A name="keyword-context.13"></A>По окончании работы с содержимым файла, необходимо освободить дополнительно выделенную процессу область памяти, предварительно синхронизировав содержимое файла на диске с содержимым этой области (если, конечно, необходимо). Эти действия выполняет системный вызов <SPAN class="texample"><SPAN class="keyword_def">munmap()</SPAN></SPAN>. </LI></UL><DIV class="lecture_mark" id="mark_603"></DIV><DIV class="xml_table_env" id="id_607"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_608"><B>Системный вызов munmap</B></P><DIV class="lecture_mark" id="mark_608"></DIV>

<P id="id_609"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_609"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/mman.h&gt; 

int munmap (void *start, size_t length);
</PRE></DIV>

<P id="id_611"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_611"></DIV>

<P id="id_612">Системный вызов <SPAN class="texample"><SPAN class="keyword">munmap</SPAN></SPAN> служит для прекращения отображения <SPAN class="keyword">memory mapped файла</SPAN> в адресное пространство вычислительной системы. Если при системном вызове <SPAN class="texample"><SPAN class="keyword">mmap()</SPAN></SPAN> было задано значение параметра <SPAN class="texample">flags</SPAN>, равное <SPAN class="texample">MAP_SHARED</SPAN>, и в отображении файла была разрешена операция записи (в параметре <SPAN class="texample">prot</SPAN> использовалось значение <SPAN class="texample">PROT_WRITE</SPAN>), то <SPAN class="texample"><SPAN class="keyword">munmap</SPAN></SPAN> синхронизирует содержимое отображения с содержимым файла во вторичной памяти. После его выполнения области памяти, использовавшиеся для отображения файла, становятся недоступны текущему процессу. </P><DIV class="lecture_mark" id="mark_612"></DIV>

<P id="id_620">Параметр <SPAN class="texample">start</SPAN> является адресом начала области памяти, выделенной для отображения файла, т.е. значением, которое вернул системный вызов <SPAN class="texample"><SPAN class="keyword">mmap()</SPAN></SPAN>.</P><DIV class="lecture_mark" id="mark_620"></DIV>

<P id="id_623">Параметр <SPAN class="texample">length</SPAN> определяет ее длину, и его значение должно совпадать со значением соответствующего параметра в системном вызове <SPAN class="texample"><SPAN class="keyword">mmap()</SPAN></SPAN>. </P><DIV class="lecture_mark" id="mark_623"></DIV>

<P id="id_626"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_626"></DIV>

<P id="id_627">При нормальном завершении системный вызов возвращает значение <SPAN class="texample">0</SPAN>, при возникновении ошибки – значение <SPAN class="texample">-1</SPAN>. </P><DIV class="lecture_mark" id="mark_627"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_607"></DIV><A name="sect13"></A><H3>Анализ, компиляция и прогон программы для создания memory mapped файла и записи его содержимого </H3><P id="id_630">Для закрепления материала, изложенного в предыдущем разделе, рассмотрим пример программы. </P><DIV class="lecture_mark" id="mark_630"></DIV><A name="example.11.1"></A><DIV class="example"><PRE>/* Программа 11-1.с для иллюстрации работы с 
memory mapped файлом */
int main(void)
{
    int fd; /* Файловый дескриптор для файла, в 
котором будет храниться наша информация*/
    size_t length; /* Длина отображаемой части файла */
    int i; 
    /* Ниже следует описание типа структуры, которым мы забьем
    файл, и двух указателей на подобный тип. Указатель ptr
    будет использоваться в качестве начального адреса 
    выделенной области памяти, а указатель tmpptr – для 
    перемещения внутри этой области. */
    struct A {
        double f;
        double f2;
    } *ptr, tmpptr;
    /* Открываем файл или сначала создаем его (если 
такого файла не было). Права доступа к файлу при создании 
определяем как read-write для всех категорий пользователей 
(0666). Из-за ошибки в Linux мы будем вынуждены ниже в 
системном вызове mmap() разрешить в отображении файла и 
чтение, и запись, хотя реально нам нужна только запись. 
Поэтому и при открытии файла мы вынуждены задавать O_RDWR. */
    fd = open("mapped.dat", O_RDWR | O_CREAT, 0666);
    if( fd == -1){
        /* Если файл открыть не удалось, выдаем 
сообщение об ошибке и завершаем работу */
        printf("File open failed!\n");
        exit(1);
    }
    /* Вычисляем будущую длину файла (мы собираемся записать
    в него 100000 структур) */
    length = 100000*sizeof(struct A);
    /* Вновь созданный файл имеет длину 0. Если мы его 
    отобразим в память с такой длиной, то любая попытка 
    записи в выделенную память приведет к ошибке. Увеличиваем
    длину файла с помощью вызова ftruncate(). */
    ftruncate(fd,length);
    /* Отображаем файл в память. Разрешенные операции над
    отображением указываем как PROT_WRITE | PROT_READ по 
    уже названным причинам. Значение флагов ставим в 
    MAP_SHARED, так как мы хотим с охранить информацию, 
    которую занесем в отображение, на диске. Файл 
    отображаем с его начала (offset = 0) и до конца 
    (length = длине файла). */
    ptr = (struct A )mmap(NULL, length, PROT_WRITE | 
        PROT_READ, MAP_SHARED, fd, 0);
    /* Файловый дескриптор нам более не нужен, и мы его
    закрываем */
    close(fd);
    if( ptr == MAP_FAILED ){
        /* Если отобразить файл не удалось, сообщаем об
        ошибке и завершаем работу */
        printf("Mapping failed!\n");
        exit(2);
    }
    /* В цикле заполняем образ файла числами от 1 до 100000
    и их квадратами. Для перемещения по области памяти 
    используем указатель tmpptr, так как указатель ptr на 
    начало образа файла нам понадобится для прекращения 
    иотображения вызовом munmap(). */
    tmpptr = ptr;
    for(i = 1; i &lt;=100000; i++){
        tmpptr-&gt;f = i;
        tmpptr-&gt;f2 = tmpptr-&gt;f*tmpptr-&gt;f;
        tmpptr++;
    }
    /* Прекращаем отображать файл в память, записываем 
    содержимое отображения на диск и освобождаем память. */
    munmap((void *)ptr, length);
    return 0;
}
</PRE><SPAN class="objectName">
            Листинг 
            11.1.
            Программа 11-1.с для иллюстрации работы с memory mapped файлом.</SPAN></DIV><P id="id_632">Эта программа создает файл, отображает его в адресное пространство процесса и заносит в него информацию с помощью обычных операций языка С. </P><DIV class="lecture_mark" id="mark_632"></DIV><P id="id_633"><B>Обратите внимание на необходимость увеличения размера файла перед его отображением. Созданный файл имеет нулевой размер, и если его с этим размером отобразить в память, то мы сможем записать в него или прочитать из него не более 0 байт, т.е. ничего. Для увеличения размера файла использован системный вызов</B> <SPAN class="texample"><SPAN class="keyword">ftruncate()</SPAN></SPAN>, <B>хотя это можно было бы сделать и любым другим способом.</B> </P><DIV class="lecture_mark" id="mark_633"></DIV><P id="id_635">При отображении файла мы вынуждены разрешить в нем и запись, и чтение, хотя реально совершаем только запись. Это сделано для того, чтобы избежать ошибки в операционной системе Linux, связанной с использованием 486-х и 586-х процессоров. Такой список разрешенных операций однозначно требует, чтобы при открытии файла системным вызовом <SPAN class="texample"><SPAN class="keyword">open()</SPAN></SPAN> файл открывался и на запись, и на чтение. Поскольку информацию мы желаем сохранить на диске, при отображении использовано значение флагов <SPAN class="texample">MAP_SHARED</SPAN>. Откомпилируйте эту программу и запустите ее.</P><DIV class="lecture_mark" id="mark_635"></DIV><A name="sect14"></A><H3>Изменение предыдущей программы для чтения из файла, используя его отображение в память </H3><P id="id_638">Модифицируйте программу из предыдущего раздела так, чтобы она отображала файл, записанный программой из раздела "Анализ, компиляция и прогон программы для создания <SPAN class="keyword">memory mapped файла</SPAN> и записи его содержимого", в память и считала сумму квадратов чисел от 1 до 100000, которые уже находятся в этом файле.</P><DIV class="lecture_mark" id="mark_638"></DIV><P id="id_639"><B>Задача повышенной сложности:</B> напишите две программы, использующие <SPAN class="keyword">memory mapped файл</SPAN> для обмена информацией при одновременной работе, подобно тому, как они могли бы использовать разделяемую память</P><DIV class="lecture_mark" id="mark_639"></DIV>


	</TD>
	</TR>
	<TR><TD height="8"><IMG src="./8. Организация файловой системы в UNIX. Работа с файлами и директориями. Понятие о memory mapped файлах_files/empty.gif" width="1" height="8"></TD></TR>
	</TBODY></TABLE>
	<!-- /content -->

</TD>
<TD><IMG src="./8. Организация файловой системы в UNIX. Работа с файлами и директориями. Понятие о memory mapped файлах_files/empty.gif" width="8" height="1"></TD>
</TR>
</TBODY></TABLE>
<!-- /bottom -->
<TABLE border="0" cellpadding="0" cellspacing="0" width="100%">
<TBODY><TR><TD class="orang" height="1"><IMG src="./8. Организация файловой системы в UNIX. Работа с файлами и директориями. Понятие о memory mapped файлах_files/empty.gif" width="1" height="1"></TD></TR>
<TR><TD class="ltxt" align="center">© INTUIT.ru, 2003-2009. Все права защищены.</TD>
</TR>
</TBODY></TABLE>
<!-- /bottom -->

<SCRIPT src="./8. Организация файловой системы в UNIX. Работа с файлами и директориями. Понятие о memory mapped файлах_files/urchin.js" type="text/javascript">
</SCRIPT>
<SCRIPT type="text/javascript">
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>


</BODY></HTML>