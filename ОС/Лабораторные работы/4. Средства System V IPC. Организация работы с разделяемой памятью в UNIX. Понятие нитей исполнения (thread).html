
<!-- saved from url=(0075)http://www.intuit.ru/department/os/osintropractice/4/osintropractice_4.html -->
<HTML><HEAD><META http-equiv="Content-Type" content="text/html; charset=windows-1251">

<TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<LINK href="./4. Средства System V IPC. Организация работы с разделяемой памятью в UNIX. Понятие нитей исполнения (thread)_files/printable.css" type="text/css" rel="stylesheet">
</HEAD><BODY leftmargin="6" topmargin="6" marginheight="6" marginwidth="6">

<DIV align="left">
<SPAN style="color: #000000; font-weight: bold;">
&nbsp;&nbsp;
<SPAN style="font-size:12pt;">Интернет-Университет Информационных Технологий</SPAN>
</SPAN>
</DIV>

&nbsp;&nbsp;
<SPAN align="rright" style="color: #330066; text-decoration:underline;">http://www.INTUIT.ru</SPAN>


<TABLE border="0" cellpadding="0" cellspacing="0" width="100%">
<TBODY><TR><TD height="8" colspan="3"><IMG src="./4. Средства System V IPC. Организация работы с разделяемой памятью в UNIX. Понятие нитей исполнения (thread)_files/empty.gif" width="1" height="8"></TD></TR>
<TR><TD class="orang" height="1" colspan="3"><IMG src="./4. Средства System V IPC. Организация работы с разделяемой памятью в UNIX. Понятие нитей исполнения (thread)_files/empty.gif" width="1" height="1"></TD></TR>
<TR><TD height="8" colspan="3"><IMG src="./4. Средства System V IPC. Организация работы с разделяемой памятью в UNIX. Понятие нитей исполнения (thread)_files/empty.gif" width="1" height="8"></TD></TR>
<TR valign="top">
<TD><IMG src="./4. Средства System V IPC. Организация работы с разделяемой памятью в UNIX. Понятие нитей исполнения (thread)_files/empty.gif" width="8" height="1"></TD>
<TD>
	<!-- content -->
	<TABLE border="0" cellpadding="0" cellspacing="0" width="100%">
	<TBODY><TR><TD class="head">Основы операционных систем. Практикум</TD></TR>
<TR><TD height="4"><IMG src="./4. Средства System V IPC. Организация работы с разделяемой памятью в UNIX. Понятие нитей исполнения (thread)_files/empty.gif" width="1" height="4"></TD></TR>
	<TR><TD class="orang" height="1"><IMG src="./4. Средства System V IPC. Организация работы с разделяемой памятью в UNIX. Понятие нитей исполнения (thread)_files/empty.gif" width="1" height="1"></TD></TR>
	<TR><TD height="8"><IMG src="./4. Средства System V IPC. Организация работы с разделяемой памятью в UNIX. Понятие нитей исполнения (thread)_files/empty.gif" width="1" height="8"></TD></TR>
	<TR><TD><SPAN class="headsub">


4. Лекция:

 Средства System V IPC. Организация работы с разделяемой памятью в UNIX. Понятие нитей исполнения (thread): версия для печати и PDA</SPAN>

<BR>
<SPAN class="rtxt">Преимущества и недостатки потокового обмена данными. Понятие System V IPC. Пространство имен. Адресация в System V IPC. Функция ftok(). Дескрипторы System V IPC. Разделяемая память в UNIX. Системные вызовы shmget(), shmat(), shmdt(). Команды ipc и ipcrm. Использование системного вызова shmctl() для освобождения ресурса. Разделяемая память и системные вызовы fork(), exec() и функция exit(). Понятие о нити исполнения (thread) в UNIX. Идентификатор нити исполнения. Функция pthread_self(). Создание и завершение thread'а. Функции pthread_create(), pthread_exit(), pthread_join(). Необходимость синхронизации процессов и нитей исполнения, использующих общую память.
</SPAN>

</TD></TR>

	<TR><TD height="8"><IMG src="./4. Средства System V IPC. Организация работы с разделяемой памятью в UNIX. Понятие нитей исполнения (thread)_files/empty.gif" width="1" height="8"></TD></TR>
	<TR><TD class="orang" height="1"><IMG src="./4. Средства System V IPC. Организация работы с разделяемой памятью в UNIX. Понятие нитей исполнения (thread)_files/empty.gif" width="1" height="1"></TD></TR>
	<TR><TD height="8"><IMG src="./4. Средства System V IPC. Организация работы с разделяемой памятью в UNIX. Понятие нитей исполнения (thread)_files/empty.gif" width="1" height="8"></TD></TR>
	<TR><TD>


<A name="sect1"></A><H3>Преимущества и недостатки потокового обмена данными. </H3><P id="id_1">На предыдущем семинаре мы познакомились с механизмами, обеспечивающими потоковую передачу данных между процессами в операционной системе UNIX, а именно с pip'ами и FIFO. Потоковые механизмы достаточно просты в реализации и удобны для использования, но имеют ряд существенных недостатков:</P><DIV class="lecture_mark" id="mark_1"></DIV><UL id="id_2"><LI>Операции чтения и записи не анализируют содержимое передаваемых данных. Процесс, прочитавший 20 байт из потока, не может сказать, были ли они записаны одним процессом или несколькими, записывались ли они за один раз или было, например, выполнено 4 операции записи по 5 байт. Данные в потоке никак не интерпретируются системой. Если требуется какая-либо интерпретация данных, то передающий и принимающий процессы должны заранее согласовать свои действия и уметь осуществлять ее самостоятельно. </LI><LI>Для передачи информации от одного процесса к другому требуется, как минимум, две операции копирования данных: первый раз – из адресного пространства передающего процесса в системный буфер, второй раз – из системного буфера в адресное пространство принимающего процесса. </LI><LI>Процессы, обменивающиеся информацией, должны одновременно существовать в вычислительной системе. Нельзя записать информацию в поток с помощью одного процесса, завершить его, а затем, через некоторое время, запустить другой процесс и прочитать записанную информацию.</LI></UL><DIV class="lecture_mark" id="mark_2"></DIV><A name="sect2"></A><H3>Понятие о System V IPC </H3><P id="id_6">Указанные выше недостатки потоков данных привели к разработке других механизмов передачи информации между процессами. Часть этих механизмов, впервые появившихся в UNIX System V и впоследствии перекочевавших оттуда практически во все современные версии операционной системы UNIX, получила общее название <A name="keyword-context.1"></A><SPAN class="keyword_def">System V IPC</SPAN> (IPC – сокращение от interprocess communications). В группу <SPAN class="keyword">System V IPC</SPAN> входят: очереди сообщений, <SPAN class="keyword">разделяемая память</SPAN> и семафоры. Эти средства организации взаимодействия процессов связаны не только общностью происхождения, но и обладают схожим интерфейсом для выполнения подобных операций, например, для выделения и освобождения соответствующего ресурса в системе. Мы будем рассматривать их в порядке от менее семантически нагруженных с точки зрения операционной системы к более семантически нагруженным. Иными словами, чем позже мы начнем заниматься 
каким-либо механизмом из <SPAN class="keyword">System V IPC</SPAN>, тем больше действий по интерпретации передаваемой информации придется выполнять операционной системе при использовании этого механизма. Часть этого семинара мы посвятим изучению <SPAN class="keyword">разделяемой памяти</SPAN>. Семафоры будут рассматриваться на семинаре 8, а очереди сообщений – на семинаре 9.</P><DIV class="lecture_mark" id="mark_6"></DIV><A name="sect3"></A><H3>Пространство имен. Адресация в System V IPC. Функция ftok() </H3><P id="id_7">Все средства связи из <SPAN class="keyword">System V IPC</SPAN>, как и уже рассмотренные нами pipe и FIFO, являются средствами связи с непрямой адресацией. Как мы установили на предыдущем семинаре, для организации взаимодействия неродственных процессов с помощью средства связи с непрямой адресацией необходимо, чтобы это средство связи имело имя. Отсутствие имен у pip'ов позволяет процессам получать информацию о расположении pip'а в системе и его состоянии только через родственные связи. Наличие ассоциированного имени у FIFO – имени специализированного файла в файловой системе – позволяет неродственным процессам получать эту информацию через интерфейс файловой системы.</P><DIV class="lecture_mark" id="mark_7"></DIV><P id="id_8"><A name="keyword-context.2"></A>Множество всех возможных имен для объектов какого-либо вида принято называть <SPAN class="keyword_def">пространством имен</SPAN> соответствующего вида объектов. Для FIFO <SPAN class="keyword">пространством имен</SPAN> является множество всех допустимых имен файлов в файловой системе. Для всех объектов из <SPAN class="keyword">System V IPC</SPAN> таким <SPAN class="keyword">пространством имен</SPAN> является множество значений некоторого целочисленного типа данных – <SPAN class="texample">key_t</SPAN> – ключа. Причем программисту не позволено напрямую присваивать значение ключа, это значение задается опосредованно: через комбинацию имени какого-либо файла, уже существующего в файловой системе, и небольшого целого числа – например, номера экземпляра средства связи.</P><DIV class="lecture_mark" id="mark_8"></DIV><P id="id_10">Такой хитрый способ получения значения ключа связан с двумя соображениями:</P><DIV class="lecture_mark" id="mark_10"></DIV><UL id="id_11"><LI>Если разрешить программистам самим присваивать значение ключа для идентификации средств связи, то не исключено, что два программиста случайно воспользуются одним и тем же значением, не подозревая об этом. Тогда их процессы будут несанкционированно взаимодействовать через одно и то же средство коммуникации, что может привести к нестандартному поведению этих процессов. Поэтому основным компонентом значения ключа является преобразованное в числовое значение полное имя некоторого файла, доступ к которому на чтение разрешен процессу. Каждый программист имеет возможность использовать для этой цели свой специфический файл, например исполняемый файл, связанный с одним из взаимодействующих процессов. Следует отметить, что преобразование из текстового имени файла в число основывается на расположении указанного файла на жестком диске или ином физическом носителе. Поэтому для образования ключа следует применять файлы, не меняющие своего положения в течение времени организации взаимодействия процессов; </LI><LI>Второй компонент значения ключа используется для того, чтобы позволить программисту связать с одним и тем же именем файла более одного экземпляра каждого средства связи. В качестве такого компонента можно задавать порядковый номер соответствующего экземпляра. </LI></UL><DIV class="lecture_mark" id="mark_11"></DIV><P id="id_14"><A name="keyword-context.3"></A>Получение значения ключа из двух компонентов осуществляется функцией <SPAN class="texample"><SPAN class="keyword_def">ftok()</SPAN></SPAN>. </P><DIV class="lecture_mark" id="mark_14"></DIV><DIV class="xml_table_env" id="id_16"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_17"><B>Функция для генерации ключа System V IPC</B></P><DIV class="lecture_mark" id="mark_17"></DIV>

<P id="id_18"><B>Прототип функции</B></P><DIV class="lecture_mark" id="mark_18"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
key_t ftok(char *pathname, char proj);
</PRE></DIV>

<P id="id_20"><B>Описание функции</B></P><DIV class="lecture_mark" id="mark_20"></DIV>

<P id="id_21">Функция <SPAN class="texample"><SPAN class="keyword">ftok</SPAN></SPAN> служит для преобразования имени существующего файла и небольшого целого числа, например, порядкового номера экземпляра средств связи, в ключ System V IPC.</P><DIV class="lecture_mark" id="mark_21"></DIV>

<P id="id_23">Параметр <SPAN class="texample">pathname</SPAN> должен являться указателем на имя существующего файла, доступного для процесса, вызывающего функцию.</P><DIV class="lecture_mark" id="mark_23"></DIV>

<P id="id_25">Параметр <SPAN class="texample">proj</SPAN> – это небольшое целое число, характеризующее экземпляр средства связи.</P><DIV class="lecture_mark" id="mark_25"></DIV>

<P id="id_27">В случае невозможности генерации ключа функция возвращает отрицательное значение, в противном случае она возвращает значение сгенерированного ключа. Тип данных <SPAN class="texample">key_t</SPAN> обычно представляет собой 32-битовое целое.</P><DIV class="lecture_mark" id="mark_27"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_16"></DIV><P id="id_29">Еще раз подчеркнем три важных момента, связанных с использованием имени файла для получения ключа. Во-первых, необходимо указывать имя файла, который <B>уже существует</B> в файловой системе и для которого процесс <B>имеет право доступа на чтение</B> (не путайте с заданием имени файла при создании FIFO, где указывалось имя <B>для вновь создаваемого</B> специального файла). Во-вторых, указанный файл должен <B>сохранять свое положение на диске</B> до тех пор, пока все процессы, участвующие во взаимодействии, не получат <SPAN class="keyword">ключ System V IPC</SPAN>. В-третьих, задание имени файла, как одного из компонентов для получения ключа, ни в коем случае не означает, что информация, передаваемая с помощью ассоциированного средства связи, будет располагаться в этом файле. Информация будет храниться <B>внутри адресного пространства операционной системы</B>, а заданное имя файла лишь позволяет различным процессам сгенерировать идентичные ключи.</P><DIV class="lecture_mark" id="mark_29"></DIV><A name="sect4"></A><H3>Дескрипторы System V IPC </H3><P id="id_30">Мы говорили (см. семинар 5 раздел "Файловый дескриптор" ), что информацию о потоках ввода-вывода, с которыми имеет дело текущий процесс, в частности о pip'ах и FIFO, операционная система хранит в таблице открытых файлов процесса. Системные вызовы, осуществляющие операции над потоком, используют в качестве параметра индекс элемента таблицы открытых файлов, соответствующего потоку, – файловый дескриптор. Использование файловых дескрипторов для идентификации потоков внутри процесса позволяет применять к ним уже существующий интерфейс для работы с файлами, но в то же время приводит к автоматическому закрытию потоков при завершении процесса. Этим, в частности, объясняется один из перечисленных выше недостатков потоковой передачи информации. </P><DIV class="lecture_mark" id="mark_30"></DIV><P id="id_31">При реализации компонентов <SPAN class="keyword">System V IPC</SPAN> была принята другая концепция. Ядро операционной системы хранит информацию обо всех средствах <SPAN class="keyword">System V IPC</SPAN>, используемых в системе, вне контекста пользовательских процессов. <A name="keyword-context.4"></A>При создании нового средства связи или получении доступа к уже существующему процесс получает неотрицательное целое число – <SPAN class="keyword_def">дескриптор (идентификатор)</SPAN> <B>этого средства связи</B>, которое однозначно идентифицирует его во всей вычислительной системе. Этот <SPAN class="keyword">дескриптор</SPAN> должен передаваться в качестве параметра всем системным вызовам, осуществляющим дальнейшие операции над соответствующим средством <SPAN class="keyword">System V IPC</SPAN>.</P><DIV class="lecture_mark" id="mark_31"></DIV><P id="id_32">Подобная концепция позволяет устранить один из самых существенных недостатков, присущих потоковым средствам связи – требование одновременного существования взаимодействующих процессов, но в то же время требует повышенной осторожности для того, чтобы процесс, получающий информацию, не принял взамен новых старые данные, случайно оставленные в механизме коммуникации.</P><DIV class="lecture_mark" id="mark_32"></DIV><A name="sect5"></A><H3>Разделяемая память в UNIX. Системные вызовы shmget(), shmat(), shmdt() </H3><P id="id_33">С точки зрения операционной системы, наименее семантически нагруженным средством <SPAN class="keyword">System V IPC</SPAN> является <SPAN class="keyword">разделяемая память (shared memory)</SPAN>. Мы уже упоминали об этой категории средств связи на лекции. Для текущего семинара нам достаточно знать, что операционная система может позволить нескольким процессам совместно использовать некоторую область адресного пространства. Внутренние механизмы, позволяющие реализовать такое использование, будут подробно рассмотрены на лекции, посвященной сегментной, страничной и сегментно-страничной организации памяти. </P><DIV class="lecture_mark" id="mark_33"></DIV><P id="id_34">Все средства связи <SPAN class="keyword">System V IPC</SPAN> требуют предварительных инициализирующих действий (создания) для организации взаимодействия процессов.</P><DIV class="lecture_mark" id="mark_34"></DIV><P id="id_35"><A name="keyword-context.5"></A>Для создания области <SPAN class="keyword">разделяемой памяти</SPAN> с определенным ключом или доступа по ключу к уже существующей области применяется системный вызов <SPAN class="texample"><SPAN class="keyword_def">shmget()</SPAN></SPAN>. Существует два варианта его использования для создания новой области <SPAN class="keyword">разделяемой памяти</SPAN>.</P><DIV class="lecture_mark" id="mark_35"></DIV><UL id="id_37"><LI>Стандартный способ. В качестве значения ключа системному вызову поставляется значение, сформированное функцией <SPAN class="texample"><SPAN class="keyword">ftok()</SPAN></SPAN> для некоторого имени файла и номера экземпляра области <SPAN class="keyword">разделяемой памяти</SPAN>. В качестве флагов поставляется комбинация прав доступа к создаваемому сегменту и флага <SPAN class="texample"><SPAN class="keyword">IPC_CREAT</SPAN></SPAN>. Если сегмент для данного ключа еще не существует, то система будет пытаться создать его с указанными правами доступа. Если же вдруг он уже существовал, то мы просто получим его дескриптор. Возможно добавление к этой комбинации флагов флага <SPAN class="texample"><SPAN class="keyword">IPC_EXCL</SPAN></SPAN>. Этот флаг гарантирует нормальное завершение системного вызова только в том случае, если сегмент действительно был создан (т. е. ранее он не существовал), если же сегмент существовал, то системный вызов завершится с ошибкой, и значение системной переменной 
<SPAN class="texample">errno</SPAN>, описанной в файле <SPAN class="texample">errno.h</SPAN>, будет установлено в <SPAN class="texample">EEXIST</SPAN>. </LI><LI>Нестандартный способ. В качестве значения ключа указывается специальное значение <SPAN class="texample"><SPAN class="keyword">IPC_PRIVATE</SPAN></SPAN>. Использование значения <SPAN class="texample"><SPAN class="keyword">IPC_PRIVATE</SPAN></SPAN> всегда приводит к попытке создания нового сегмента <SPAN class="keyword">разделяемой памяти</SPAN> с заданными правами доступа и с ключом, который не совпадает со значением ключа ни одного из уже существующих сегментов и который не может быть получен с помощью функции <SPAN class="texample"><SPAN class="keyword">ftok()</SPAN></SPAN> ни при одной комбинации ее параметров. Наличие флагов <SPAN class="texample"><SPAN class="keyword">IPC_CREAT</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">IPC_EXCL</SPAN></SPAN> в этом случае игнорируется. </LI></UL><DIV class="lecture_mark" id="mark_37"></DIV><DIV class="xml_table_env" id="id_51"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_52"><B>Системный вызов shmget()</B></P><DIV class="lecture_mark" id="mark_52"></DIV>

<P id="id_53"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_53"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;

int shmget(key_t key, int size, 
           int shmflg);
</PRE></DIV>

<P id="id_55"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_55"></DIV>

<P id="id_56">Системный вызов <SPAN class="texample"><SPAN class="keyword">shmget</SPAN></SPAN> предназначен для выполнения операции доступа к сегменту разделяемой памяти и, в случае его успешного завершения, возвращает дескриптор System V IPC для этого сегмента (целое неотрицательное число, однозначно характеризующее сегмент внутри вычислительной системы и использующееся в дальнейшем для других операций с ним).</P><DIV class="lecture_mark" id="mark_56"></DIV>

<P id="id_58">Параметр <SPAN class="texample">key</SPAN> является ключом System V IPC для сегмента, т. е. фактически его именем из пространства имен System V IPC. В качестве значения этого параметра может использоваться значение ключа, полученное с помощью функции <SPAN class="texample"><SPAN class="keyword">ftok()</SPAN></SPAN>, или специальное значение <SPAN class="texample"><SPAN class="keyword">IPC_PRIVATE</SPAN></SPAN>. Использование значения <SPAN class="texample"><SPAN class="keyword">IPC_PRIVATE</SPAN></SPAN> всегда приводит к попытке создания нового сегмента разделяемой памяти с ключом,который не совпадает со значением ключа ни одного из уже существующих сегментов и который не может быть получен с помощью функции <SPAN class="texample"><SPAN class="keyword">ftok()</SPAN></SPAN> ни при одной комбинации ее параметров.</P><DIV class="lecture_mark" id="mark_58"></DIV>

<P id="id_64">Параметр <SPAN class="texample">size</SPAN>. определяет размер создаваемого или уже существующего сегмента в байтах. Если сегмент с указанным ключом уже существует, но его размер не совпадает с указанным в параметре <SPAN class="texample">size</SPAN>, констатируется возникновение ошибки.</P><DIV class="lecture_mark" id="mark_64"></DIV>

<P id="id_67">Параметр <SPAN class="texample">shmflg</SPAN> – флаги – играет роль только при создании нового сегмента разделяемой памяти и определяет права различных пользователей при доступе к сегменту, а также необходимость создания нового сегмента и поведение системного вызова при попытке создания. Он является некоторой комбинацией (с помощью операции побитовое или – "<SPAN class="texample">|</SPAN>") следующих предопределенных значений и восьмеричных прав доступа:</P><DIV class="lecture_mark" id="mark_67"></DIV>

<UL id="id_70"><LI><SPAN class="texample"><SPAN class="keyword">IPC_CREAT</SPAN></SPAN> – если сегмента для указанного ключа не существует, он должен быть создан;</LI><LI><SPAN class="texample"><SPAN class="keyword">IPC_EXCL</SPAN></SPAN> – применяется совместно с флагом <SPAN class="texample"><SPAN class="keyword">IPC_CREAT</SPAN></SPAN>. При совместном их использовании и существовании сегмента с указанным ключом, доступ к сегменту не производится и констатируется ошибочная ситуация, при этом переменная <SPAN class="texample">errno</SPAN>, описанная в файле <SPAN class="texample">&lt;errno.h&gt;</SPAN>, примет значение <SPAN class="texample">EEXIST</SPAN>;</LI><LI><SPAN class="texample">0400</SPAN> – разрешено чтение для пользователя, создавшего сегмент;</LI><LI><SPAN class="texample">0200</SPAN> – разрешена запись для пользователя, создавшего сегмент;</LI><LI><SPAN class="texample">0040</SPAN> – разрешено чтение для группы пользователя, создавшего сегмент;</LI><LI><SPAN class="texample">0020</SPAN> – разрешена запись для группы пользователя, создавшего сегмент;</LI><LI><SPAN class="texample">0004</SPAN> – разрешено чтение для всех остальных пользователей;</LI><LI><SPAN class="texample">0002</SPAN> – разрешена запись для всех остальных пользователей.</LI></UL><DIV class="lecture_mark" id="mark_70"></DIV>

<P id="id_91"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_91"></DIV>

<P id="id_92">Системный вызов возвращает значение дескриптора System V IPC для сегмента разделяемой памяти при нормальном завершении и значение <SPAN class="texample">-1</SPAN> при возникновении ошибки.</P><DIV class="lecture_mark" id="mark_92"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_51"></DIV><P id="id_94">Доступ к созданной области <SPAN class="keyword">разделяемой памяти</SPAN> в дальнейшем обеспечивается ее дескриптором, который вернет системный вызов <SPAN class="texample"><SPAN class="keyword">shmget()</SPAN></SPAN>. Доступ к уже существующей области также может осуществляться двумя способами:</P><DIV class="lecture_mark" id="mark_94"></DIV><UL id="id_96"><LI>Если мы знаем ее ключ, то, используя вызов <SPAN class="texample"><SPAN class="keyword">shmget()</SPAN></SPAN>,можем получить ее дескриптор. В этом случае нельзя указывать в качестве составной части флагов флаг <SPAN class="texample"><SPAN class="keyword">IPC_EXCL</SPAN></SPAN>, а значение ключа, естественно, не может быть <SPAN class="texample"><SPAN class="keyword">IPC_PRIVATE</SPAN></SPAN>. Права доступа игнорируются, а размер области должен совпадать с размером, указанным при ее создании. </LI><LI>Либо мы можем воспользоваться тем, что <SPAN class="keyword">дескриптор System V IPC</SPAN> действителен в рамках всей операционной системы, и передать его значение от процесса, создавшего <SPAN class="keyword">разделяемую память</SPAN>, текущему процессу. Отметим, что при создании <SPAN class="keyword">разделяемой памяти</SPAN> с помощью значения <SPAN class="texample"><SPAN class="keyword">IPC_PRIVATE</SPAN></SPAN> – это единственно возможный способ. </LI></UL><DIV class="lecture_mark" id="mark_96"></DIV><P id="id_103"><A name="keyword-context.6"></A>После получения дескриптора необходимо включить область <SPAN class="keyword">разделяемой памяти</SPAN> в адресное пространство текущего процесса. Это осуществляется с помощью системного вызова <SPAN class="texample"><SPAN class="keyword_def">shmat()</SPAN></SPAN>. При нормальном завершении он вернет адрес <SPAN class="keyword">разделяемой памяти</SPAN> в адресном пространстве текущего процесса. Дальнейший доступ к этой памяти осуществляется с помощью обычных средств языка программирования. </P><DIV class="lecture_mark" id="mark_103"></DIV><DIV class="xml_table_env" id="id_105"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_106"><B>Системный вызов shmat()</B></P><DIV class="lecture_mark" id="mark_106"></DIV>

<P id="id_107"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_107"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;
char *shmat(int shmid, char *shmaddr, 
            int shmflg);
</PRE></DIV>

<P id="id_109"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_109"></DIV>

<P id="id_110">Системный вызов <SPAN class="texample"><SPAN class="keyword">shmat</SPAN></SPAN> предназначен для включения области разделяемой памяти в адресное пространство текущего процесса. Данное описание не является полным описанием системного вызова, а ограничивается рамками текущего курса. Для полного описания обращайтесь к UNIX Manual.</P><DIV class="lecture_mark" id="mark_110"></DIV>

<P id="id_112">Параметр <SPAN class="texample">shmid</SPAN> является дескриптором System V IPC для сегмента разделяемой памяти, т. е. значением, которое вернул системный вызов <SPAN class="texample"><SPAN class="keyword">shmget()</SPAN></SPAN> при создании сегмента или при его поиске по ключу.</P><DIV class="lecture_mark" id="mark_112"></DIV>

<P id="id_115">В качестве параметра <SPAN class="texample">shmaddr</SPAN> в рамках нашего курса мы всегда будем передавать значение <SPAN class="texample">NULL</SPAN>, позволяя операционной системе самой разместить разделяемую память в адресном пространстве нашего процесса.</P><DIV class="lecture_mark" id="mark_115"></DIV>

<P id="id_118">Параметр <SPAN class="texample">shmflg</SPAN> в нашем курсе может принимать только два значения: <SPAN class="texample">0</SPAN> – для осуществления операций чтения и записи над сегментом и <SPAN class="texample">SHM_RDONLY</SPAN> – если мы хотим только читать из него. При этом процесс должен иметь соответствующие права доступа к сегменту.</P><DIV class="lecture_mark" id="mark_118"></DIV>

<P id="id_122"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_122"></DIV>

<P id="id_123">Системный вызов возвращает адрес сегмента разделяемой памяти в адресном пространстве процесса при нормальном завершении и значение <SPAN class="texample">-1</SPAN> при возникновении ошибки.</P><DIV class="lecture_mark" id="mark_123"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_105"></DIV><P id="id_125"><A name="keyword-context.7"></A>После окончания использования <SPAN class="keyword">разделяемой памяти</SPAN> процесс может уменьшить размер своего адресного пространства, исключив из него эту область с помощью системного вызова <SPAN class="texample"><SPAN class="keyword_def">shmdt()</SPAN></SPAN>. Отметим, что в качестве параметра системный вызов <SPAN class="texample"><SPAN class="keyword">shmdt()</SPAN></SPAN> требует адрес начала области <SPAN class="keyword">разделяемой памяти</SPAN> в адресном пространстве процесса, т. е. значение, которое вернул системный вызов <SPAN class="texample"><SPAN class="keyword">shmat()</SPAN></SPAN>, поэтому данное значение следует сохранять на протяжении всего времени использования <SPAN class="keyword">разделяемой памяти</SPAN>.</P><DIV class="lecture_mark" id="mark_125"></DIV><DIV class="xml_table_env" id="id_129"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_130"><B>Системный вызов shmdt()</B></P><DIV class="lecture_mark" id="mark_130"></DIV>

<P id="id_131"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_131"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;
int shmdt(char *shmaddr);
</PRE></DIV>

<P id="id_133"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_133"></DIV>

<P id="id_134">Системный вызов <SPAN class="texample"><SPAN class="keyword">shmdt</SPAN></SPAN> предназначен для исключения области разделяемой памяти из адресного пространства текущего процесса.</P><DIV class="lecture_mark" id="mark_134"></DIV>

<P id="id_136">Параметр <SPAN class="texample">shmaddr</SPAN> является адресом сегмента разделяемой памяти,т. е. значением, которое вернул системный вызов <SPAN class="texample"><SPAN class="keyword">shmat()</SPAN></SPAN>.</P><DIV class="lecture_mark" id="mark_136"></DIV>

<P id="id_139"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_139"></DIV>

<P id="id_140">Системный вызов возвращает значение <SPAN class="texample">0</SPAN> при нормальном завершении и значение <SPAN class="texample">-1</SPAN> при возникновении ошибки.</P><DIV class="lecture_mark" id="mark_140"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_129"></DIV><A name="sect6"></A><H3>Прогон программ с использованием разделяемой памяти</H3><P id="id_143">Для иллюстрации использования <SPAN class="keyword">разделяемой памяти</SPAN> давайте рассмотрим две взаимодействующие программы.</P><DIV class="lecture_mark" id="mark_143"></DIV><A name="example.6.1a"></A><DIV class="example"><PRE>/* Программа 1 (06-1а.с) для иллюстрации работы с разделяемой памятью */ 
/* Мы организуем разделяемую память для массива из трех целых чисел. 
Первый элемент массива является счетчиком числа запусков программы 1, 
т. е. данной программы, второй элемент массива – счетчиком числа запусков
программы 2, третий элемент массива – счетчиком числа запусков обеих 
программ */ 
#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
int main()
{
    int *array;    /* Указатель на разделяемую память */
    int shmid;     /* IPC дескриптор для области разделяемой памяти */
    int new = 1;   /* Флаг необходимости инициализации элементов массива */
    char pathname[] = "06-1a.c"; /* Имя файла, 
        используемое для генерации ключа. Файл с таким 
        именем должен существовать в текущей директории */
    key_t key;     /* IPC ключ */ 
    /* Генерируем IPC ключ из имени файла 06-1a.c в 
        текущей директории и номера экземпляра области 
        разделяемой памяти 0 */
    if((key = ftok(pathname,0)) &lt; 0){
        printf("Can\'t generate key\n");
        exit(-1);
    }
    /* Пытаемся эксклюзивно создать разделяемую память для 
    сгенерированного ключа, т.е. если для этого ключа она
    уже существует, системный вызов вернет отрицательное 
    значение. Размер памяти определяем как размер массива 
    из трех целых переменных, права доступа 0666 – чтение
    и запись разрешены для всех */
    if((shmid = shmget(key, 3*sizeof(int),             
    0666|IPC_CREAT|IPC_EXCL)) &lt; 0){
    /* В случае ошибки пытаемся определить: возникла ли она
    из-за того, что сегмент разделяемой памяти уже существует
    или по другой причине */
        if(errno != EEXIST){
            /* Если по другой причине – прекращаем работу */
            printf("Can\'t create shared memory\n");
            exit(-1);
        } else {
            /* Если из-за того, что разделяемая память уже 
            существует, то пытаемся получить ее IPC 
            дескриптор и, в случае удачи, сбрасываем флаг 
            необходимости инициализации элементов массива */

            if((shmid = shmget(key, 3*sizeof(int), 0)) &lt; 0){
                printf("Can\'t find shared memory\n");
                exit(-1);
            }
            new = 0;
        }
    }
    /* Пытаемся отобразить разделяемую память в адресное 
    пространство текущего процесса. Обратите внимание на то,
    что для правильного сравнения мы явно преобразовываем 
    значение -1 к указателю на целое.*/ 

    if((array = (int *)shmat(shmid, NULL, 0)) == (int *)(-1)){
        printf("Can't attach shared memory\n");
        exit(-1);
    }
    /* В зависимости от значения флага new либо 
инициализируем массив, либо увеличиваем 
соответствующие счетчики */ 
    if(new){
        array[0] = 1;
        array[1] = 0;
        array[2] = 1;
    } else {
        array[0] += 1;
        array[2] += 1;
    }
    /* Печатаем новые значения счетчиков, удаляем 
    разделяемую память из адресного пространства 
    текущего процесса и завершаем работу */
    printf("Program 1 was spawn %d times, 
        program 2 - %d times, total - %d times\n",
        array[0], array[1], array[2]);
    if(shmdt(array) &lt; 0){ 
        printf("Can't detach shared memory\n");
        exit(-1);
    }
    return 0;
}
</PRE><SPAN class="objectName">
            Листинг 
            6.1a.
            Программа 1 (06-1а.с) для иллюстрации работы с разделяемой памятью</SPAN></DIV><A name="example.6.1b"></A><DIV class="example"><PRE>/* Программа 2 (06-1b.с) для иллюстрации работы с 
разделяемой памятью */ 
/* Мы организуем разделяемую память для массива из
трех целых чисел. Первый элемент массива является 
счетчиком числа запусков программы 1, т. е. данной 
программы, второй элемент массива – счетчиком числа
запусков программы 2, третий элемент массива – 
счетчиком числа запусков обеих программ */ 
#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
int main()
{
    int *array;   /* Указатель на разделяемую память */
    int shmid;    /* IPC дескриптор для области разделяемой памяти */
    int new = 1;  /* Флаг необходимости инициализации элементов массива */
    char pathname[] = "06-1a.c"; /* Имя файла, 
        используемое для генерации ключа. Файл с таким 
        именем должен существовать в текущей директории */
    key_t key;    /* IPC ключ */ 
    /* Генерируем IPC ключ из имени файла 06-1a.c в 
    текущей директории и номера экземпляра области 
    разделяемой памяти 0 */
    if((key = ftok(pathname,0)) &lt; 0){
        printf("Can\'t generate key\n");
        exit(-1);
    }
    /* Пытаемся эксклюзивно создать разделяемую память
    для сгенерированного ключа, т.е. если для этого 
    ключа она уже существует, системный вызов вернет
    отрицательное значение. Размер памяти определяем 
    как размер массива из трех целых переменных, права 
    доступа 0666 – чтение и запись разрешены для всех */
    if((shmid = shmget(key, 3*sizeof(int), 
        0666|IPC_CREAT|IPC_EXCL)) &lt; 0){
    /* В случае возникновения ошибки пытаемся определить: 
    возникла ли она из-за того, что сегмент разделяемой 
    памяти уже существует или по другой причине */
        if(errno != EEXIST){
            /* Если по другой причине – прекращаем работу */
            printf("Can\'t create shared memory\n");
            exit(-1);
        } else {
            /* Если из-за того, что разделяемая память уже
            существует, то пытаемся получить ее IPC дескриптор
            и, в случае удачи, сбрасываем флаг необходимости
            инициализации элементов массива */
            if((shmid = shmget(key, 3*sizeof(int), 0)) &lt; 0){
                printf("Can\'t find shared memory\n");
                exit(-1);
            }
            new = 0;
        }
    }
    /* Пытаемся отобразить разделяемую память в адресное 
    пространство текущего процесса. Обратите внимание на то,
    что для правильного сравнения мы явно преобразовываем 
    значение -1 к указателю на целое.*/ 
    if((array = (int *)shmat(shmid, NULL, 0)) == 
        (int *)(-1)){
        printf("Can't attach shared memory\n");
        exit(-1);
    }
    /* В зависимости от значения флага new либо 
    инициализируем массив, либо увеличиваем 
    соответствующие счетчики */ 
    if(new){
        array[0] = 0;
        array[1] = 1;
        array[2] = 1;
    } else {
        array[1] += 1;
        array[2] += 1;
    }
    /* Печатаем новые значения счетчиков, удаляем разделяемую
    память из адресного пространства текущего процесса и 
    завершаем работу */
    printf("Program 1 was spawn %d times, 
        program 2 - %d times, total - %d times\n",
    array[0], array[1], array[2]);
    if(shmdt(array) &lt; 0){ 
        printf("Can't detach shared memory\n");
        exit(-1);
    }
    return 0;
}
</PRE><SPAN class="objectName">
            Листинг 
            6.1b.
            Программа 2 (06-1b.с) для иллюстрации работы с разделяемой памятью</SPAN></DIV><P id="id_146">Эти программы очень похожи друг на друга и используют <SPAN class="keyword">разделяемую память</SPAN> для хранения числа запусков каждой из программ и их суммы. В <SPAN class="keyword">разделяемой памяти</SPAN> размещается массив из трех целых чисел. Первый элемент массива используется как счетчик для программы 1, второй элемент – для программы 2, третий элемент – для обеих программ суммарно. Дополнительный нюанс в программах возникает из-за необходимости инициализации элементов массива при создании <SPAN class="keyword">разделяемой памяти</SPAN>. Для этого нам нужно, чтобы программы могли различать случай, когда они создали ее, и случай, когда она уже существовала. Мы добиваемся различия, используя вначале системный вызов <SPAN class="texample"><SPAN class="keyword">shmget()</SPAN></SPAN> с флагами <SPAN class="texample"><SPAN class="keyword">IPC_CREAT</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">IPC_EXCL</SPAN></SPAN>. Если вызов завершается нормально, то мы создали <SPAN class="keyword">разделяемую память</SPAN>. Если вызов завершается с констатацией ошибки и значение переменной <SPAN class="texample">errno</SPAN> равняется <SPAN class="texample">EEXIST</SPAN>, то, значит, <SPAN class="keyword">разделяемая память</SPAN> уже существует, и мы можем получить ее IPC дескриптор, применяя тот же самый вызов с нулевым значением флагов. Наберите программы, сохраните под именами <SPAN class="texample">06-1а.с</SPAN> и <SPAN class="texample">06-1b.c</SPAN>  cоответственно, откомпилируйте их и запустите несколько раз. Проанализируйте полученные результаты. </P><DIV class="lecture_mark" id="mark_146"></DIV><A name="sect7"></A><H3>Команды ipcs и ipcrm </H3><P id="id_154">Как мы видели из предыдущего примера, созданная область <SPAN class="keyword">разделяемой памяти</SPAN> сохраняется в операционной системе даже тогда, когда нет ни одного процесса, включающего ее в свое адресное пространство. С одной стороны, это имеет определенные преимущества, поскольку не требует одновременного существования взаимодействующих процессов, с другой стороны, может причинять существенные неудобства. Допустим, что предыдущие программы мы хотим использовать таким образом, чтобы подсчитывать количество запусков в течение одного, текущего, сеанса работы в системе. Однако в созданном сегменте <SPAN class="keyword">разделяемой памяти</SPAN> остается информация от предыдущего сеанса, и программы будут выдавать общее количество запусков за все время работы с момента загрузки операционной системы. Можно было бы создавать для нового сеанса новый сегмент <SPAN class="keyword">разделяемой памяти</SPAN>, но 
количество ресурсов в системе не безгранично. Нас спасает то, что существуют способы удалять неиспользуемые ресурсы <SPAN class="keyword">System V IPC</SPAN> как с помощью команд операционной системы, так и с помощью системных вызовов. Все средства <SPAN class="keyword">System V IPC</SPAN> требуют определенных действий для освобождения занимаемых ресурсов после окончания взаимодействия процессов. Для того чтобы удалять ресурсы <SPAN class="keyword">System V IPC</SPAN> из командной строки, нам понадобятся две команды, <SPAN class="texample"><SPAN class="keyword">ipcs</SPAN></SPAN> и <SPAN class="texample"><SPAN class="keyword">ipcrm</SPAN></SPAN>.</P><DIV class="lecture_mark" id="mark_154"></DIV><P id="id_157"><A name="keyword-context.8"></A>Команда <SPAN class="texample"><SPAN class="keyword_def">ipcs</SPAN></SPAN> выдает информацию обо всех средствах <SPAN class="keyword">System V IPC</SPAN>, существующих в системе, для которых пользователь обладает правами на чтение: областях <SPAN class="keyword">разделяемой памяти</SPAN>, семафорах и очередях сообщений. </P><DIV class="lecture_mark" id="mark_157"></DIV><DIV class="xml_table_env" id="id_159"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_160"><B>Команда ipcs</B></P><DIV class="lecture_mark" id="mark_160"></DIV>

<P id="id_161"><B>Синтаксис команды</B></P><DIV class="lecture_mark" id="mark_161"></DIV>

<DIV class="example"><PRE>ipcs [-asmq] [-tclup]
ipcs [-smq] -i id
ipcs -h
</PRE></DIV>

<P id="id_163"><B>Описание команды</B></P><DIV class="lecture_mark" id="mark_163"></DIV>

<P id="id_164">Команда <SPAN class="texample"><SPAN class="keyword">ipcs</SPAN></SPAN> предназначена для получения информации о средствах System V IPC, к которым пользователь имеет право доступа на чтение. </P><DIV class="lecture_mark" id="mark_164"></DIV>

<P id="id_166">Опция <SPAN class="texample">-i</SPAN> позволяет указать идентификатор ресурсов. Будет выдаваться только информация для ресурсов, имеющих этот идентификатор.</P><DIV class="lecture_mark" id="mark_166"></DIV>

<P id="id_168">Виды IPC ресурсов могут быть заданы с помощью следующих опций:</P><DIV class="lecture_mark" id="mark_168"></DIV>

<UL id="id_169"><LI><SPAN class="texample">–s</SPAN> для семафоров;</LI><LI><SPAN class="texample">-m</SPAN> для сегментов разделяемой памяти;</LI><LI><SPAN class="texample">-q</SPAN> для очередей сообщений;</LI><LI><SPAN class="texample">-a</SPAN> для всех ресурсов (по умолчанию).</LI></UL><DIV class="lecture_mark" id="mark_169"></DIV>

<P id="id_178">Опции <SPAN class="texample">[-tclup]</SPAN> используются для изменения состава выходной информации. По умолчанию для каждого средства выводятся его ключ, идентификатор IPC, идентификатор владельца, права доступа и ряд других характеристик. Применение опций позволяет вывести:</P><DIV class="lecture_mark" id="mark_178"></DIV>

<UL id="id_180"><LI><SPAN class="texample">-t</SPAN> времена совершения последних операций над средствами IPC;</LI><LI><SPAN class="texample">-p</SPAN> идентификаторы процесса, создавшего ресурс, и процесса, совершившего над ним последнюю операцию;</LI><LI><SPAN class="texample">-c</SPAN> идентификаторы пользователя и группы для создателя ресурса и его собственника;</LI><LI><SPAN class="texample">-l</SPAN> системные ограничения для средств System V IPC;</LI><LI><SPAN class="texample">-u</SPAN> общее состояние IPC ресурсов в системе.</LI></UL><DIV class="lecture_mark" id="mark_180"></DIV>

<P id="id_191">Опция <SPAN class="texample">-h</SPAN> используется для получения краткой справочной информации.</P><DIV class="lecture_mark" id="mark_191"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_159"></DIV><P id="id_193">Из всего многообразия выводимой информации нас будут интересовать только IPC идентификаторы для средств, созданных вами. Эти идентификаторы будут использоваться в команде <SPAN class="texample"><SPAN class="keyword">ipcrm</SPAN></SPAN>, позволяющей удалить необходимый ресурс из системы. Для удаления сегмента <SPAN class="keyword">разделяемой памяти</SPAN> эта команда имеет вид: </P><DIV class="lecture_mark" id="mark_193"></DIV><DIV class="example"><PRE>ipcrm shm &lt;IPC идентификатор&gt;</PRE></DIV><P id="id_196">Удалите созданный вами сегмент <SPAN class="keyword">разделяемой памяти</SPAN> из операционной системы, используя эти команды. </P><DIV class="lecture_mark" id="mark_196"></DIV><DIV class="xml_table_env" id="id_197"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_198"><B>Команда ipcrm</B></P><DIV class="lecture_mark" id="mark_198"></DIV>

<P id="id_199"><B>Синтаксис команды</B></P><DIV class="lecture_mark" id="mark_199"></DIV>

<DIV class="example"><PRE>ipcrm [shm | msg | sem] id</PRE></DIV>

<P id="id_201"><B>Описание команды</B></P><DIV class="lecture_mark" id="mark_201"></DIV>

<P id="id_202">Команда <SPAN class="texample"><SPAN class="keyword">ipcrm</SPAN></SPAN> предназначена для удаления ресурса System V IPC из операционной системы. Параметр <SPAN class="texample">id</SPAN> задает IPC идентификатор для удаляемого ресурса, параметр <SPAN class="texample">shm</SPAN> используется для сегментов разделяемой памяти, параметр <SPAN class="texample">msg</SPAN> – для очередей сообщений, параметр <SPAN class="texample">sem</SPAN> – для семафоров.</P><DIV class="lecture_mark" id="mark_202"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_197"></DIV><P id="id_208">Если поведение программ, использующих средства <SPAN class="keyword">System V IPC</SPAN>, базируется на предположении, что эти средства были созданы при их работе, не забывайте перед их запуском удалять уже существующие ресурсы.</P><DIV class="lecture_mark" id="mark_208"></DIV><A name="sect8"></A><H3>Использование системного вызова shmctl() для освобождения ресурса </H3><P id="id_209">Для той же цели – удалить область <SPAN class="keyword">разделяемой памяти</SPAN> из системы – можно воспользоваться и системным вызовом <SPAN class="texample"><SPAN class="keyword_def">shmctl()</SPAN></SPAN>. <A name="keyword-context.9"></A>Этот системный вызов позволяет полностью ликвидировать область <SPAN class="keyword">разделяемой памяти</SPAN> в операционной системе по заданному дескриптору средства IPC, если, конечно, у вас хватает для этого полномочий.<SPAN class="keyword"></SPAN> Системный вызов <SPAN class="texample"><SPAN class="keyword">shmctl()</SPAN></SPAN> позволяет выполнять и другие действия над сегментом <SPAN class="keyword">разделяемой памяти</SPAN>, но их изучение лежит за пределами нашего курса. </P><DIV class="lecture_mark" id="mark_209"></DIV><DIV class="xml_table_env" id="id_212"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_213"><B>Системный вызов shmctl()</B></P><DIV class="lecture_mark" id="mark_213"></DIV>

<P id="id_214"><B>Прототип системного вызова</B></P><DIV class="lecture_mark" id="mark_214"></DIV>

<DIV class="example"><PRE>#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;

int shmctl(int shmid, int cmd, 
           struct shmid_ds *buf);
</PRE></DIV>

<P id="id_216"><B>Описание системного вызова</B></P><DIV class="lecture_mark" id="mark_216"></DIV>

<P id="id_217">Системный вызов <SPAN class="texample"><SPAN class="keyword">shmctl</SPAN></SPAN> предназначен для получения информации об области разделяемой памяти, изменения ее атрибутов и удаления из системы. Данное описание не является полным описанием системного вызова, а ограничивается рамками текущего курса. Для изучения полного описания обращайтесь к UNIX Manual.</P><DIV class="lecture_mark" id="mark_217"></DIV>

<P id="id_219">В нашем курсе мы будем пользоваться системным вызовом <SPAN class="texample"><SPAN class="keyword">shmctl</SPAN></SPAN> только для удаления области разделяемой памяти из системы. Параметр <SPAN class="texample">shmid</SPAN> является дескриптором System V IPC для сегмента разделяемой памяти, т. е. значением, которое вернул системный вызов <SPAN class="texample"><SPAN class="keyword">shmget()</SPAN></SPAN> при создании сегмента или при его поиске по ключу.</P><DIV class="lecture_mark" id="mark_219"></DIV>

<P id="id_223">В качестве параметра <SPAN class="texample">cmd</SPAN> в рамках нашего курса мы всегда будем передавать значение <SPAN class="texample">IPC_RMID</SPAN> – команду для удаления сегмента разделяемой памяти с заданным идентификатором. Параметр <SPAN class="texample">buf</SPAN> для этой команды не используется, поэтому мы всегда будем подставлять туда значение <SPAN class="texample">NULL</SPAN>.</P><DIV class="lecture_mark" id="mark_223"></DIV>

<P id="id_228"><B>Возвращаемое значение</B></P><DIV class="lecture_mark" id="mark_228"></DIV>

<P id="id_229">Системный вызов возвращает значение <SPAN class="texample">0</SPAN> при нормальном завершении и значение <SPAN class="texample">-1</SPAN> при возникновении ошибки.</P><DIV class="lecture_mark" id="mark_229"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_212"></DIV><A name="sect9"></A><H3>Разделяемая память и системные вызовы fork(), exec() и функция exit() </H3><P id="id_232">Важным вопросом является поведение сегментов <SPAN class="keyword">разделяемой памяти</SPAN> при выполнении процессом системных вызовов <SPAN class="texample">fork()</SPAN>, <SPAN class="texample">exec()</SPAN> и функции <SPAN class="texample">exit()</SPAN>.</P><DIV class="lecture_mark" id="mark_232"></DIV><P id="id_236">При выполнении системного вызова <SPAN class="texample">fork()</SPAN> все области <SPAN class="keyword">разделяемой памяти</SPAN>, размещенные в адресном пространстве процесса, наследуются порожденным процессом.</P><DIV class="lecture_mark" id="mark_236"></DIV><P id="id_238">При выполнении системных вызовов <SPAN class="texample">exec()</SPAN> и функции <SPAN class="texample">exit()</SPAN> все области <SPAN class="keyword">разделяемой памяти</SPAN>, размещенные в адресном пространстве процесса, исключаются из его адресного пространства, но продолжают существовать в операционной системе.</P><DIV class="lecture_mark" id="mark_238"></DIV><A name="sect10"></A><H3>Самостоятельное написание, компиляция и запуск программы для организации связи двух процессов через разделяемую память. </H3><P id="id_241">Для закрепления полученных знаний напишите две программы, осуществляющие взаимодействие через <SPAN class="keyword">разделяемую память</SPAN>. Первая программа должна создавать сегмент <SPAN class="keyword">разделяемой памяти</SPAN> и копировать туда собственный исходный текст, вторая программа должна брать оттуда этот текст, печатать его на экране и удалять сегмент <SPAN class="keyword">разделяемой памяти</SPAN> из системы.</P><DIV class="lecture_mark" id="mark_241"></DIV><A name="sect11"></A><H3>Понятие о нити исполнения (thread) в UNIX. Идентификатор нити исполнения. Функция pthread_self() </H3><P id="id_242">На лекции 4 мы говорили, что во многих современных операционных системах существует расширенная реализация понятия процесс, когда процесс представляет собой совокупность выделенных ему ресурсов и набора <SPAN class="keyword">нитей исполнения</SPAN>. Нити процесса разделяют его программный код, глобальные переменные и системные ресурсы, но каждая нить имеет собственный программный счетчик, свое содержимое регистров и свой стек. Поскольку глобальные переменные у <SPAN class="keyword">нитей исполнения</SPAN> являются общими, они могут использовать их, как элементы <SPAN class="keyword">разделяемой памяти</SPAN>, не прибегая к механизму, описанному выше.</P><DIV class="lecture_mark" id="mark_242"></DIV><P id="id_243">В различных версиях операционной системы UNIX существуют различные интерфейсы, обеспечивающие работу с <SPAN class="keyword">нитями исполнения</SPAN>. Мы кратко ознакомимся с некоторыми функциями, позволяющими разделить процесс на thread'ы и управлять их поведением, в соответствии со стандартом POSIX. <SPAN class="keyword">Нити исполнения</SPAN>, удовлетворяющие стандарту POSIX, принято называть POSIX thread'ами или, кратко, pthread'ами.</P><DIV class="lecture_mark" id="mark_243"></DIV><P id="id_244">К сожалению, операционная система Linux не полностью поддерживает <SPAN class="keyword">нити исполнения</SPAN> на уровне ядра системы. При создании нового thread'а запускается новый традиционный процесс, разделяющий с родительским традиционным процессом его ресурсы, программный код и данные, расположенные вне стека, т.е. фактически действительно создается новый thread, но ядро не умеет определять, что эти thread'ы являются составными частями одного целого. Это "знает" только специальный процесс-координатор, работающий на пользовательском уровне и стартующий при первом вызове функций, обеспечивающих POSIX интерфейс для <SPAN class="keyword">нитей исполнения</SPAN>. Поэтому мы сможем наблюдать не все преимущества использования <SPAN class="keyword">нитей исполнения</SPAN> (в частности, ускорить решение задачи на однопроцессорной машине с их помощью вряд ли получится), но даже в этом случае thread'ы можно задействовать как очень удобный способ 




для создания процессов с общими ресурсами, программным кодом и <SPAN class="keyword">разделяемой памятью</SPAN>.</P><DIV class="lecture_mark" id="mark_244"></DIV><P id="id_245"><A name="keyword-context.10"></A>Каждая <SPAN class="keyword">нить исполнения</SPAN>, как и процесс, имеет в системе уникальный номер – <SPAN class="keyword">идентификатор</SPAN> thread'a. Поскольку традиционный процесс в концепции <SPAN class="keyword">нитей исполнения</SPAN> трактуется как процесс, содержащий единственную <SPAN class="keyword">нить исполнения</SPAN>, мы можем узнать <SPAN class="keyword">идентификатор</SPAN> этой нити и для любого обычного процесса. Для этого используется функция <SPAN class="texample"><SPAN class="keyword_def">pthread_self()</SPAN></SPAN>. <SPAN class="keyword">Нить исполнения</SPAN>, создаваемую при рождении нового процесса, принято называть <B>начальной</B> или <B>главной</B> <SPAN class="keyword">нитью исполнения</SPAN> этого процесса.</P><DIV class="lecture_mark" id="mark_245"></DIV><DIV class="xml_table_env" id="id_247"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_248"><B>Функция pthread_self()</B></P><DIV class="lecture_mark" id="mark_248"></DIV>

<P id="id_249"><B>Прототип функции</B></P><DIV class="lecture_mark" id="mark_249"></DIV>

<DIV class="example"><PRE>#include &lt;pthread.h&gt;
pthread_t pthread_self(void);
</PRE></DIV>

<P id="id_251"><B>Описание функции</B></P><DIV class="lecture_mark" id="mark_251"></DIV>

<P id="id_252">Функция <SPAN class="texample"><SPAN class="keyword">pthread_self</SPAN></SPAN> возвращает идентификатор текущей нити исполнения.</P><DIV class="lecture_mark" id="mark_252"></DIV>

<P id="id_254">Тип данных <SPAN class="texample">pthread_t</SPAN> является синонимом для одного из целочисленных типов языка C.</P><DIV class="lecture_mark" id="mark_254"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_247"></DIV><A name="sect12"></A><H3>Создание и завершение thread'а. Функции pthread_create(), pthread_exit(), pthread_join() </H3><P id="id_256"><SPAN class="keyword">Нити исполнения</SPAN>, как и традиционные процессы, могут порождать нити-потомки, правда, только внутри своего процесса. Каждый будущий thread внутри программы должен представлять собой функцию с прототипом </P><DIV class="lecture_mark" id="mark_256"></DIV><DIV class="example"><PRE>void *thread(void *arg); </PRE></DIV><P id="id_258">Параметр <SPAN class="texample">arg</SPAN> передается этой функции при создании thread'a и может, до некоторой степени, рассматриваться как аналог параметров функции <SPAN class="texample">main()</SPAN>, о которых мы говорили на семинарах 3–4. Возвращаемое функцией значение может интерпретироваться как аналог информации, которую родительский процесс может получить после завершения процесса-ребенка. <A name="keyword-context.11"></A>Для создания новой <SPAN class="keyword">нити исполнения</SPAN> применяется функция <SPAN class="texample"><SPAN class="keyword_def">pthread_create()</SPAN></SPAN>.</P><DIV class="lecture_mark" id="mark_258"></DIV><DIV class="xml_table_env" id="id_262"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_263"><B>Функция для создания нити исполнения</B></P><DIV class="lecture_mark" id="mark_263"></DIV>

<P id="id_264"><B>Прототип функции</B></P><DIV class="lecture_mark" id="mark_264"></DIV>

<DIV class="example"><PRE>#include &lt;pthread.h&gt;
int pthread_create(pthread_t *thread, 
    pthread_attr_t *attr,
    void * (*start_routine)(void *), 
    void *arg);
</PRE></DIV>

<P id="id_266"><B>Описание функции</B></P><DIV class="lecture_mark" id="mark_266"></DIV>

<P id="id_267">Функция <SPAN class="texample"><SPAN class="keyword">pthread_create</SPAN></SPAN> служит для создания новой нити исполнения (thread'а) внутри текущего процесса. Настоящее описание не является полным описанием функции, а служит только целям данного курса. Для изучения полного описания обращайтесь к UNIX Manual.</P><DIV class="lecture_mark" id="mark_267"></DIV>

<P id="id_269">Новый <SPAN class="texample">thread</SPAN> будет выполнять функцию <SPAN class="texample">start_routine</SPAN> с прототипом</P><DIV class="lecture_mark" id="mark_269"></DIV>

<DIV class="example"><PRE>void *start_routine(void *)</PRE></DIV>

<P id="id_273">передавая ей в качестве аргумента параметр <SPAN class="texample">arg</SPAN>. Если требуется передать более одного параметра, они собираются в структуру, и передается адрес этой структуры. Значение, возвращаемое функцией <SPAN class="texample">start_routine</SPAN> не должно указывать на динамический объект данного thread'а.</P><DIV class="lecture_mark" id="mark_273"></DIV>

<P id="id_276">Параметр <SPAN class="texample">attr</SPAN> служит для задания различных атрибутов создаваемого thread'а. Их описание выходит за рамки нашего курса, и мы всегда будем считать их заданными по умолчанию, подставляя в качестве аргумента значение <SPAN class="texample">NULL</SPAN>.</P><DIV class="lecture_mark" id="mark_276"></DIV>

<P id="id_279"><B>Возвращаемые значения</B></P><DIV class="lecture_mark" id="mark_279"></DIV>

<P id="id_280">При удачном завершении функция возвращает значение <SPAN class="texample">0</SPAN> и помещает идентификатор новой нити исполнения по адресу, на который указывает параметр <SPAN class="texample">thread</SPAN>. В случае ошибки возвращается <B>положительное значение</B> (а не отрицательное, как в большинстве системных вызовов и функций!), которое определяет код ошибки, описанный в файле <SPAN class="texample">&lt;errno.h&gt;</SPAN>. Значение системной переменной <SPAN class="texample">errno</SPAN> при этом не устанавливается.</P><DIV class="lecture_mark" id="mark_280"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_262"></DIV><P id="id_285">Мы не будем рассматривать ее в полном объеме, так как детальное изучение программирования с использованием thread'ов не является целью данного курса. </P><DIV class="lecture_mark" id="mark_285"></DIV><P id="id_286">Важным отличием этой функции от большинства других системных вызовов и функций является то, что в случае неудачного завершения она <B>возвращает не отрицательное, а положительное значение</B>, которое определяет код ошибки, описанный в файле <SPAN class="texample">&lt;errno.h&gt;</SPAN>. Значение системной переменной <SPAN class="texample">errno</SPAN> при этом не устанавливается. Результатом выполнения этой функции является появление в системе новой <SPAN class="keyword">нити исполнения</SPAN>, которая будет выполнять функцию, ассоциированную со thread'ом, передав ей специфицированный параметр, параллельно с уже существовавшими <SPAN class="keyword">нитями исполнения</SPAN> процесса.</P><DIV class="lecture_mark" id="mark_286"></DIV><P id="id_289">Созданный thread может завершить свою деятельность тремя способами:</P><DIV class="lecture_mark" id="mark_289"></DIV><UL id="id_290"><LI>С помощью выполнения функции <SPAN class="texample"><SPAN class="keyword">pthread_exit()</SPAN></SPAN>. Функция никогда не возвращается в вызвавшую ее <SPAN class="keyword">нить исполнения</SPAN>. Объект, на который указывает параметр этой функции, может быть изучен в другой <SPAN class="keyword">нити исполнения</SPAN>, например, в породившей завершившийся thread. Этот параметр, следовательно, должен указывать на объект, не являющийся локальным для завершившегося thread'а, например, на статическую переменную; </LI><LI>С помощью возврата из функции, ассоциированной с <SPAN class="keyword">нитью исполнения</SPAN>. Объект, на который указывает адрес, возвращаемый функцией, как и в предыдущем случае, может быть изучен в другой <SPAN class="keyword">нити исполнения</SPAN>, например, в породившей завершившийся thread, и должен указывать на объект, не являющийся локальным для завершившегося thread'а; </LI><LI>Если в процессе выполняется возврат из функции <SPAN class="texample">main()</SPAN> или где-либо в процессе (в любой <SPAN class="keyword">нити исполнения</SPAN>) осуществляется вызов функции <SPAN class="texample">exit()</SPAN>, это приводит к завершению всех thread'ов процесса. </LI></UL><DIV class="lecture_mark" id="mark_290"></DIV><DIV class="xml_table_env" id="id_297"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_298"><B>Функция для завершения нити исполнения</B></P><DIV class="lecture_mark" id="mark_298"></DIV>

<P id="id_299"><B>Прототип функции</B></P><DIV class="lecture_mark" id="mark_299"></DIV>

<DIV class="example"><PRE>#include &lt;pthread.h&gt;
void pthread_exit(void *status);
</PRE></DIV>

<P id="id_301"><B>Описание функции</B></P><DIV class="lecture_mark" id="mark_301"></DIV>

<P id="id_302">Функция <SPAN class="texample"><SPAN class="keyword">pthread_exit</SPAN></SPAN> служит для завершения нити исполнения (<SPAN class="texample">thread</SPAN>) текущего процесса.</P><DIV class="lecture_mark" id="mark_302"></DIV>

<P id="id_305">Функция никогда не возвращается в вызвавший ее <SPAN class="texample">thread</SPAN>. Объект, на который указывает параметр <SPAN class="texample">status</SPAN>, может быть впоследствии изучен в другой нити исполнения, например в нити, породившей завершившуюся нить. Поэтому он не должен указывать на динамический объект завершившегося thread'а.</P><DIV class="lecture_mark" id="mark_305"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_297"></DIV><P id="id_308"><A name="keyword-context.12"></A>Одним из вариантов получения адреса, возвращаемого завершившимся thread'ом, с одновременным ожиданием его завершения является использование функции <SPAN class="texample"><SPAN class="keyword_def">pthread_join()</SPAN></SPAN>. <SPAN class="keyword">Нить исполнения</SPAN>, вызвавшая эту функцию, переходит в состояние <B>ожидание</B> до завершения заданного thread'а. Функция позволяет также получить указатель, который вернул завершившийся thread в операционную систему.</P><DIV class="lecture_mark" id="mark_308"></DIV><DIV class="xml_table_env" id="id_310"><A name=""></A><TABLE border="0" class="xml_table" cellpadding="2" cellspacing="1"><TBODY><TR><TD bgcolor="#eaeaea" valign="top">

<P id="id_311"><B>Функция pthread_join()</B></P><DIV class="lecture_mark" id="mark_311"></DIV>

<P id="id_312"><B>Прототип функции</B></P><DIV class="lecture_mark" id="mark_312"></DIV>

<DIV class="example"><PRE>#include &lt;pthread.h&gt;
int pthread_join (pthread_t thread,
void **status_addr);
</PRE></DIV>

<P id="id_314"><B>Описание функции</B></P><DIV class="lecture_mark" id="mark_314"></DIV>

<P id="id_315">Функция <SPAN class="texample"><SPAN class="keyword">pthread_join</SPAN></SPAN> блокирует работу вызвавшей ее нити исполнения до завершения thread'а с идентификатором <SPAN class="texample">thread</SPAN>. После разблокирования в указатель, расположенный по адресу <SPAN class="texample">status_addr</SPAN>, заносится адрес, который вернул завершившийся thread либо при выходе из ассоциированной с ним функции, либо при выполнении функции <SPAN class="texample"><SPAN class="keyword">pthread_exit()</SPAN></SPAN>. Если нас не интересует, что вернула нам нить исполнения, в качестве этого параметра можно использовать значение <SPAN class="texample">NULL</SPAN>.</P><DIV class="lecture_mark" id="mark_315"></DIV>

<P id="id_321"><B>Возвращаемые значения</B></P><DIV class="lecture_mark" id="mark_321"></DIV>

<P id="id_322">Функция возвращает значение <SPAN class="texample">0</SPAN> при успешном завершении. В случае ошибки возвращается <B>положительное значение</B> (а не отрицательное, как в большинстве системных вызовов и функций!), которое определяет код ошибки, описанный в файле <SPAN class="texample">&lt;errno.h&gt;</SPAN>. Значение системной переменной <SPAN class="texample">errno</SPAN> при этом не устанавливается.</P><DIV class="lecture_mark" id="mark_322"></DIV>

</TD></TR></TBODY></TABLE></DIV><DIV class="lecture_mark" id="mark_310"></DIV><A name="sect13"></A><H3>Прогон программы с использованием двух нитей исполнения </H3><P id="id_326">Для иллюстрации вышесказанного давайте рассмотрим программу, в которой работают две <SPAN class="keyword">нити исполнения</SPAN>. </P><DIV class="lecture_mark" id="mark_326"></DIV><A name="example.6.2"></A><DIV class="example"><PRE>/* Программа 06-2.c для иллюстрации работы двух нитей исполнения.
Каждая нить исполнения просто увеличивает на 1 разделяемую 
переменную a. */ 
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
int a = 0; 
/* Переменная a является глобальной статической для всей 
программы, поэтому она будет разделяться обеими нитями 
исполнения.*/
/* Ниже следует текст функции, которая будет 
ассоциирована со 2-м thread'ом */
void *mythread(void *dummy)
/* Параметр dummy в нашей функции не используется и 
присутствует только для совместимости типов данных. По той
же причине функция возвращает значение void *, хотя
это никак не используется в программе.*/
{
    pthread_t mythid; /* Для идентификатора нити исполнения */
    /* Заметим, что переменная mythid является 
динамической локальной переменной функции mythread(), 
т. е. помещается в стеке и, следовательно, не разделяется
нитями исполнения. */
    /* Запрашиваем идентификатор thread'а */
    mythid = pthread_self();
    a = a+1;
    printf("Thread %d, Calculation result = %d\n", 
        mythid, a);
    return NULL;
}
/* Функция main() – она же ассоциированная функция главного
thread'а */
int main()
{
    pthread_t thid, mythid;
    int result;
    /* Пытаемся создать новую нить исполнения, 
ассоциированную с функцией mythread(). Передаем ей 
в качестве параметра значение NULL. В случае удачи в 
переменную thid занесется идентификатор нового thread'а.
Если возникнет ошибка, то прекратим работу. */
    result = pthread_create( &amp;thid, 
        (pthread_attr_t *)NULL, mythread, NULL);
    if(result != 0){
    printf ("Error on thread create, 
        return value = %d\n", result);
    exit(-1);
    }
    printf("Thread created, thid = %d\n", thid);
    /* Запрашиваем идентификатор главного thread'а */
    mythid = pthread_self();
    a = a+1; 
    printf("Thread %d, Calculation result = %d\n", 
        mythid, a);
    /* Ожидаем завершения порожденного thread'a, не 
    интересуясь, какое значение он нам вернет. Если не 
    выполнить вызов этой функции, то возможна ситуация, 
    когда мы завершим функцию main() до того, как выполнится 
    порожденный thread, что автоматически повлечет за 
    собой его завершение, исказив результаты. */
    pthread_join(thid, (void **)NULL);
    return 0;
}
</PRE><SPAN class="objectName">
            Листинг 
            6.2.
            Программа 06-2.c для иллюстрации работы двух нитей исполнения.</SPAN></DIV><P id="id_328">Для сборки исполняемого файла при работе редактора связей необходимо явно подключить библиотеку функций для работы с pthread'ами, которая не подключается автоматически. Это делается с помощью добавления к команде компиляции и редактирования связей параметра <SPAN class="texample">-lpthread</SPAN> – подключить библиотеку <SPAN class="texample"><SPAN class="keyword">pthread</SPAN></SPAN>. Наберите текст, откомпилируйте эту программу и запустите на исполнение. </P><DIV class="lecture_mark" id="mark_328"></DIV><P id="id_331"><B>Обратите внимание на отличие результатов этой программы от похожей программы, иллюстрировавшей создание нового процесса (раздел "Прогон программы с</B> <SPAN class="texample">fork()</SPAN> <B>с одинаковой работой родителя и ребенка"), которую мы рассматривали на семинарах 3-4. Программа, создававшая новый процесс, печатала дважды одинаковые значения для переменной</B> <SPAN class="texample">a</SPAN>, <B>так как адресные пространства различных процессов независимы, и каждый процесс прибавлял 1 к своей собственной переменной</B> <SPAN class="texample">a</SPAN><B>. Рассматриваемая программа печатает два разных значения, так как переменная</B> <SPAN class="texample">a</SPAN> <B>является разделяемой, и каждый thread прибавляет 1 к одной и той же переменной</B>. </P><DIV class="lecture_mark" id="mark_331"></DIV><A name="sect14"></A><H3>Написание, компиляция и прогон программы с использованием трех нитей исполнения. </H3><P id="id_336">Модифицируйте предыдущую программу, добавив к ней третью <SPAN class="keyword">нить исполнения</SPAN>. </P><DIV class="lecture_mark" id="mark_336"></DIV><A name="sect15"></A><H3>Необходимость синхронизации процессов и нитей исполнения, использующих общую память </H3><P id="id_337">Все рассмотренные на этом семинаре примеры являются не совсем корректными. В большинстве случаев они работают правильно, однако возможны ситуации, когда совместная деятельность этих процессов или <SPAN class="keyword">нитей исполнения</SPAN> приводит к неверным и неожиданным результатам. Это связано с тем, что любые неатомарные операции, связанные с изменением содержимого <SPAN class="keyword">разделяемой памяти</SPAN>, представляют собой критическую секцию процесса или <SPAN class="keyword">нити исполнения</SPAN>. Вспомните рассмотрение критических секций в лекции 5. </P><DIV class="lecture_mark" id="mark_337"></DIV><P id="id_338">Вернемся к рассмотрению программ из раздела "Прогон программ с использованием <SPAN class="keyword">разделяемой памяти</SPAN>". При одновременном существовании двух процессов в операционной системе может возникнуть следующая последовательность выполнения операций во времени: </P><DIV class="lecture_mark" id="mark_338"></DIV><DIV class="example"><PRE>...
Процесс 1: array[0] += 1;
Процесс 2: array[1] += 1;
Процесс 1: array[2] += 1;
Процесс 1: printf(
   "Program 1 was spawn %d times, 
   program 2 - %d times, total - %d times\n",
   array[0], array[1], array[2]);
...
</PRE></DIV><P id="id_340">Тогда печать будет давать неправильные результаты. Естественно, что воспроизвести подобную последовательность действий практически нереально. Мы не сможем подобрать необходимое время старта процессов и степень загруженности вычислительной системы. Но мы можем смоделировать эту ситуацию, добавив в обе программы достаточно длительные пустые циклы перед оператором <SPAN class="texample">array[2] += 1;</SPAN> Это проделано в следующих программах. </P><DIV class="lecture_mark" id="mark_340"></DIV><A name="example.6.3a"></A><DIV class="example"><PRE>/* Программа 1 (06-3а.с) для иллюстрации 
некорректной работы с разделяемой памятью */ 
/* Мы организуем разделяемую память для массива из трех целых
чисел. Первый элемент массива является счетчиком числа 
запусков программы 1, т. е. данной программы, второй элемент
массива – счетчиком числа запусков программы 2, третий 
элемент массива – счетчиком числа запусков обеих программ */ 
#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
int main()
{
    int *array; /* Указатель на разделяемую память */
    int shmid; /* IPC дескриптор для области 
    разделяемой памяти */
    int new = 1; /* Флаг необходимости инициализации 
        элементов массива */
    char pathname[] = "06-3a.c"; /* Имя файла, 
        использующееся для генерации ключа. Файл с таким 
        именем должен существовать в текущей директории */
    key_t key; /* IPC ключ */
    long i; 
    /* Генерируем IPC ключ из имени файла 06-3a.c в 
    текущей директории и номера экземпляра области 
    разделяемой памяти 0 */
    if((key = ftok(pathname,0)) &lt; 0){
        printf("Can\'t generate key\n");
        exit(-1);
    }
    /* Пытаемся эксклюзивно создать разделяемую память для
    сгенерированного ключа, т.е. если для этого ключа она 
    уже существует, системный вызов вернет отрицательное 
    значение. Размер памяти определяем как размер массива 
    из 3-х целых переменных, права доступа 0666 – чтение и
    запись разрешены для всех */
    if((shmid = shmget(key, 3*sizeof(int), 
        0666|IPC_CREAT|IPC_EXCL)) &lt; 0){
    /* В случае возникновения ошибки пытаемся определить: 
    возникла ли она из-за того, что сегмент разделяемой 
    памяти уже существует или по другой причине */
        if(errno != EEXIST){
            /* Если по другой причине – прекращаем работу */
            printf("Can\'t create shared memory\n");
            exit(-1);
        } else {
            /* Если из-за того, что разделяемая память уже 
            существует – пытаемся получить ее IPC дескриптор 
            и, в случае удачи, сбрасываем флаг необходимости
            инициализации элементов массива */
            if((shmid = shmget(key, 3*sizeof(int), 0)) &lt; 0){
                printf("Can\'t find shared memory\n");
                exit(-1);
            }
            new = 0;
        }
    }
    /* Пытаемся отобразить разделяемую память в адресное 
    пространство текущего процесса. Обратите внимание на то, 
    что для правильного сравнения мы явно преобразовываем 
    значение -1 к указателю на целое.*/ 
    if((array = (int *)shmat(shmid, NULL, 0)) == 
        (int *)(-1)){
        printf("Can't attach shared memory\n");
        exit(-1);
    }
/* В зависимости от значения флага new либо 
инициализируем массив, либо увеличиваем 
соответствующие счетчики */ 
    if(new){
        array[0] = 1;
        array[1] = 0;
        array[2] = 1;
    } else {
        array[0] += 1;
        for(i=0; i&lt;1000000000L; i++); 
        /* Предельное значение для i может меняться в зависимости
        от производительности компьютера */
        array[2] += 1;
    }
    /* Печатаем новые значения счетчиков, удаляем разделяемую 
    память из адресного пространства текущего процесса и з
    авершаем работу */
    printf("Program 1 was spawn %d times, 
        program 2 - %d times, total - %d times\n",
        array[0], array[1], array[2]);
    if(shmdt(array) &lt; 0){ 
        printf("Can't detach shared memory\n");
        exit(-1);
    }
    return 0;
}
</PRE><SPAN class="objectName">
            Листинг 
            6.3a.
            Программа 1 (06-3а.с) для иллюстрации некорректной работы с разделяемой памятью.</SPAN></DIV><A name="example.6.3b"></A><DIV class="example"><PRE>
/* Программа 2 (06-3b.c) для иллюстрации 
некорректной работы с разделяемой памятью */ 
/* Мы организуем разделяемую память для массива из трех 
целых чисел. Первый элемент массива является счетчиком 
числа запусков программы 1, т. е. данной программы, 
второй элемент массива – счетчиком числа запусков 
программы 2, третий элемент массива – счетчиком числа 
запусков обеих программ */ 
#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
int main()
{
int *array; /* Указатель на разделяемую память */
    int shmid; /* IPC дескриптор для области 
        разделяемой памяти */
    int new = 1; /* Флаг необходимости инициализации 
    элементов массива */
    char pathname[] = "06-3a.c"; /* Имя файла, 
        использующееся для генерации ключа. Файл с таким
        именем должен существовать в текущей директории */
    key_t key; /* IPC ключ */
    long i; 
    /* Генерируем IPC ключ из имени файла 06-3a.c в текущей
    директории и номера экземпляра области разделяемой 
    памяти 0 */
    if((key = ftok(pathname,0)) &lt; 0){
        printf("Can\'t generate key\n");
        exit(-1);
    }
    /* Пытаемся эксклюзивно создать разделяемую память для
    сгенерированного ключа, т.е. если для этого ключа она 
    уже существует, системный вызов вернет отрицательное 
    значение. Размер памяти определяем как размер массива 
    из трех целых переменных, права доступа 0666 – чтение 
    и запись разрешены для всех */
    if((shmid = shmget(key, 3*sizeof(int), 
        0666|IPC_CREAT|IPC_EXCL)) &lt; 0){
    /* В случае ошибки пытаемся определить, возникла ли она
    из-за того, что сегмент разделяемой памяти уже существует 
    или по другой причине */
        if(errno != EEXIST){
            /* Если по другой причине – прекращаем работу */
            printf("Can\'t create shared memory\n");
            exit(-1);
        } else {
            /* Если из-за того, что разделяемая память уже 
            существует – пытаемся получить ее IPC дескриптор 
            и, в случае удачи, сбрасываем флаг необходимости
            инициализации элементов массива */
            if((shmid = shmget(key, 
                3*sizeof(int), 0)) &lt; 0){
                printf("Can\'t find shared memory\n");
                exit(-1);
            }
            new = 0;
        }
    }
    /* Пытаемся отобразить разделяемую память в адресное 
    пространство текущего процесса. Обратите внимание на то, 
    что  для правильного сравнения мы явно преобразовываем 
    значение -1 к указателю на целое.*/ 
    if((array = (int *)shmat(shmid, NULL, 0)) == 
        (int *)(-1)){
        printf("Can't attach shared memory\n");
        exit(-1);    
    }
    /* В зависимости от значения флага new либо 
инициализируем массив, либо увеличиваем 
соответствующие счетчики */ 
    if(new){
        array[0] = 0;
        array[1] = 1;
        array[2] = 1;
    } else {
        array[1] += 1;
        for(i=0; i&lt;1000000000L; i++); 
        /* Предельное значение для i может меняться в зависимости
        от производительности компьютера */
        array[2] += 1;
    }
    /* Печатаем новые значения счетчиков, удаляем разделяемую
    память из адресного пространства текущего процесса и завершаем
    работу */
    printf("Program 1 was spawn %d times, 
        program 2 - %d times, total - %d times\n",
        array[0], array[1], array[2]);
        if(shmdt(array) &lt; 0){ 
            printf("Can't detach shared memory\n");
            exit(-1);
        }
        return 0;
}
</PRE><SPAN class="objectName">
            Листинг 
            6.3b.
            Программа 2 (06-3b.c) для иллюстрации некорректной работы с разделяемой памятью.</SPAN></DIV><P id="id_344">Наберите программы, сохраните под именами <SPAN class="texample">06-3а.с</SPAN> и <SPAN class="texample">06-3b.c</SPAN>  cоответственно, откомпилируйте их и запустите любую из них один раз для создания и инициализации <SPAN class="keyword">разделяемой памяти</SPAN>. Затем запустите другую и, пока она находится в цикле, запустите, например, с другого виртуального терминала, снова первую программу. Вы получите неожиданный результат: количество запусков по отдельности не будет соответствовать количеству запусков вместе. </P><DIV class="lecture_mark" id="mark_344"></DIV><P id="id_347">Как мы видим, для написания корректно работающих программ необходимо обеспечивать взаимоисключение при работе с <SPAN class="keyword">разделяемой памятью</SPAN> и, может быть, взаимную очередность доступа к ней. Это можно сделать с помощью рассмотренных в лекции 6 алгоритмов синхронизации, например, алгоритма Петерсона или алгоритма булочной. </P><DIV class="lecture_mark" id="mark_347"></DIV><P id="id_348"><B>Задача повышенной сложности</B>: модифицируйте программы из этого раздела для корректной работы с помощью алгоритма Петерсона.</P><DIV class="lecture_mark" id="mark_348"></DIV><P id="id_349">На следующем семинаре мы рассмотрим семафоры, которые являются средством <SPAN class="keyword">System V IPC</SPAN>, предназначенным для синхронизации процессов.</P><DIV class="lecture_mark" id="mark_349"></DIV>


	</TD>
	</TR>
	<TR><TD height="8"><IMG src="./4. Средства System V IPC. Организация работы с разделяемой памятью в UNIX. Понятие нитей исполнения (thread)_files/empty.gif" width="1" height="8"></TD></TR>
	</TBODY></TABLE>
	<!-- /content -->

</TD>
<TD><IMG src="./4. Средства System V IPC. Организация работы с разделяемой памятью в UNIX. Понятие нитей исполнения (thread)_files/empty.gif" width="8" height="1"></TD>
</TR>
</TBODY></TABLE>
<!-- /bottom -->
<TABLE border="0" cellpadding="0" cellspacing="0" width="100%">
<TBODY><TR><TD class="orang" height="1"><IMG src="./4. Средства System V IPC. Организация работы с разделяемой памятью в UNIX. Понятие нитей исполнения (thread)_files/empty.gif" width="1" height="1"></TD></TR>
<TR><TD class="ltxt" align="center">© INTUIT.ru, 2003-2009. Все права защищены.</TD>
</TR>
</TBODY></TABLE>
<!-- /bottom -->

<SCRIPT src="./4. Средства System V IPC. Организация работы с разделяемой памятью в UNIX. Понятие нитей исполнения (thread)_files/urchin.js" type="text/javascript">
</SCRIPT>
<SCRIPT type="text/javascript">
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>


</BODY></HTML>